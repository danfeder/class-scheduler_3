This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-24T18:10:24.955Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
docs/
  ai_onboarding.md
  architecture_overview.md
  directory_index.md
  performance_guide.md
  system_overview.md
  technical_implementation.md
  testing_guide.md
memlog/
  algorithm_performance.md
  changelog.md
  constraint_tracking.md
  stability_checklist.md
  tasks.md
  url_debug_checklist.md
public/
  vite.svg
src/
  __tests__/
    utils/
      assertions.ts
      builders.test.ts
      builders.ts
    conflictHandling.test.ts
    constraints.test.ts
    parallelScheduler.test.ts
    scheduleEngine.test.ts
    scheduleQuality.test.ts
    scoring.test.ts
    simulatedAnnealing.test.ts
  assets/
    react.svg
  components/
    schedule/
      ExportButton.tsx
      MonthView.tsx
      ScheduleCell.tsx
      ScheduleHeader.tsx
    ui/
      Button.tsx
      Card.tsx
      dropdown-menu.tsx
      Tooltip.tsx
    ClassForm.tsx
    GradeGroupBuilder.tsx
    ScheduleConstraints.tsx
    ScheduleDisplay.tsx
    ScheduleGenerator.tsx
  types/
    index.ts
  utils/
    cn.ts
    export.ts
    parallelScheduler.ts
    schedule.ts
    scheduleEngine.ts
    schedulerWorker.js
    schedulerWorker.ts
    simulatedAnnealing.ts
    storage.ts
  App.tsx
  index.css
  main.tsx
  types.ts
  vite-env.d.ts
tests/
  conflict_handling.test.ts
  performance.test.ts
.gitignore
AI_RULES_AND_GUIDELINES.md
eslint.config.js
index.html
jest.config.ts
package.json
postcss.config.js
project_summary.md
README.md
storage-inspector.html
tailwind.config.js
tsconfig.app.json
tsconfig.json
tsconfig.node.json
tsconfig.node.tsbuildinfo
tsconfig.tsbuildinfo
vite.config.d.ts
vite.config.js
vite.config.ts

================================================================
Repository Files
================================================================

================
File: docs/ai_onboarding.md
================
# AI Assistant Onboarding Guide

## Initial Prompt for New AI Assistants

Please help me continue development on the ClassRotation scheduling system. To understand the project:

1. **Start with the Documentation Map**:
   - **`/docs/directory_index.md`**: This is your primary navigation tool. It contains:
     - Complete documentation structure
     - Documentation guidelines
     - File dependencies and relationships
     - Documentation categories and purposes

2. **Then read these core documentation files in order**:
   - **`/docs/system_overview.md`**: Understand the system's purpose, inputs, outputs, and key features
   - **`/docs/architecture_overview.md`**: Learn the technical reasoning behind our architectural choices
   - **`/docs/technical_implementation.md`**: Detailed implementation patterns and strategies
   - **`/docs/performance_guide.md`**: Performance considerations and optimization strategies

3. **Then, examine these core implementation files**:
   - **`/src/types/index.ts`**: Core type definitions
   - **`/src/scheduleEngine.ts`**: Base scheduling logic
   - **`/src/simulatedAnnealing.ts`**: Optimization algorithm
   - **`/src/parallelScheduler.ts`**: Parallel processing implementation

4. **Review the testing documentation and infrastructure**:
   - **`/docs/testing_guide.md`**: Comprehensive testing strategy
   - **`/src/__tests__/simulatedAnnealing.test.ts`**: Current test scenarios
   - **`/src/__tests__/scheduleEngine.test.ts`**: Core logic validation

5. **Finally, check recent changes**:
   - **`/project_summary.md`**: Current project status

## Key Areas to Focus On

1. **Algorithm Understanding**
   - **Simulated Annealing Implementation**:
     - Temperature management
     - Cooling schedules
     - Acceptance probabilities
   - **Mutation Strategies**:
     - Single class moves
     - Class swaps
     - Grade group operations
   - **Scoring System**:
     - Component weights
     - Score calculation
     - Performance impact

2. **Constraint System**
   - **Hard Constraints**:
     - Teacher conflicts
     - Room availability
     - Period limits
   - **Soft Constraints**:
     - Grade cohesion
     - Distribution quality
     - Teacher preferences
   - **Validation Strategies**:
     - Incremental validation
     - Caching mechanisms
     - Performance optimization
   - **Class-Specific Conflicts**:
     - Total Conflicts (Hard Constraints):
       * Periods where classes absolutely cannot be scheduled
       * Includes teacher unavailability
       * Must be strictly enforced
     - Partial Conflicts (Soft Constraints):
       * Periods where scheduling is discouraged
       * 70% probability of causing a conflict
       * Affects schedule scoring
     - Implementation Details:
       * Conflicts are stored per-class
       * Each conflict specifies date, period, and type
       * Validation occurs in scheduleEngine.ts
   - **Conflict Resolution**:
     - Total conflicts are never violated
     - Partial conflicts use probabilistic acceptance
     - Scoring penalties for partial conflict scheduling
     - Complex scenarios with overlapping conflicts
   - **Performance Considerations**:
     - Efficient conflict checking
     - Caching of conflict validation results
     - Optimized date comparisons

3. **Performance Optimization**
   - **Current Metrics**:
     - **Large Schedules (30+ classes)**: 73-74% optimization rate
     - **Test Suite Execution Time**: ~350 seconds
     - **Memory Usage**: ~200MB peak
   - **Target Metrics**:
     - **Large Schedules (30+ classes)**: 95% optimization rate
     - **Test Suite Execution Time**: < 100 seconds
     - **Memory Usage**: < 150MB peak
   - **Optimization Strategies**:
     - Constraint validation improvements
     - Memory pooling
     - Worker coordination
     - Shared memory usage

4. **Documentation Categories**

   - **Entry Points**:
     - **Purpose**: Quick project understanding
     - **Update**: Major changes
     - **Examples**: `README.md`, `directory_index.md`

   - **System Understanding**:
     - **Purpose**: Functional overview
     - **Update**: Feature changes
     - **Examples**: `system_overview.md`

   - **Architecture & Design**:
     - **Purpose**: Technical decisions
     - **Update**: Design changes
     - **Examples**: `architecture_overview.md`

   - **Technical Implementation**:
     - **Purpose**: Code patterns
     - **Update**: Implementation changes
     - **Examples**: `technical_implementation.md`

   - **Testing & Quality**:
     - **Purpose**: Test strategy
     - **Update**: Test changes
     - **Examples**: `testing_guide.md`

   - **Performance**:
     - **Purpose**: Optimization
     - **Update**: Performance changes
     - **Examples**: `performance_guide.md`

## Development Guidelines

1. **Code Organization**

   ```typescript
   // Core scheduling components
   interface ScheduleEngine {
     schedule(): Promise<Schedule>;
     validate(schedule: Schedule): boolean;
     score(schedule: Schedule): number;
   }

   // Optimization strategy
   class SimulatedAnnealingScheduler implements ScheduleEngine {
     private temperature: number;
     private coolingRate: number;

     constructor(config: SchedulerConfig) {
       this.temperature = config.initialTemp;
       this.coolingRate = config.coolingRate;
     }

     async schedule(): Promise<Schedule> {
       // Implementation
     }
   }

   // Worker coordination
   interface WorkerMessage {
     type: 'START' | 'RESULT' | 'BEST_SOLUTION';
     payload: any;
   }
   ```

2. **Testing Strategy**

   ```typescript
   // Test suite organization
   describe('Schedule Generation', () => {
     // Unit tests
     describe('Constraint Validation', () => {
       it('should validate teacher conflicts', () => {
         // Test implementation
       });
     });

     // Integration tests
     describe('End-to-End Generation', () => {
       it('should generate valid schedule', async () => {
         // Test implementation
       });
     });

     // Performance tests
     describe('Performance', () => {
       it('should complete within time limit', () => {
         // Test implementation
       });
     });
   });
   ```

3. **Performance Considerations**

   - Use incremental validation where possible
   - Implement caching for expensive operations
   - Consider memory usage in worker communication
   - Profile and optimize hot paths

## Impact Analysis

When making changes, consider:

1. **Algorithm Impact**

   - How will changes affect scheduling success rate?
   - What's the impact on execution time?
   - Are there memory usage implications?
   - How does it affect solution quality?

2. **Code Quality Impact**

   - Does it maintain type safety?
   - Are tests comprehensive?
   - Is documentation updated?
   - Are performance metrics tracked?

3. **Maintenance Impact**

   - Is the change easy to understand?
   - Can it be easily modified?
   - Are dependencies minimal?
   - Is debugging straightforward?

## Common Pitfalls

1. **Performance**

   - O(n²) constraint validation
   - Excessive schedule copying
   - Poor worker communication
   - Memory leaks in long runs

2. **Algorithm**

   - Poor temperature management
   - Ineffective mutation strategies
   - Unbalanced scoring weights
   - Stuck in local optima

3. **Testing**

   - Incomplete test coverage
   - Slow test execution
   - Flaky tests
   - Missing edge cases

================
File: docs/architecture_overview.md
================
# Architecture Overview

## System Architecture

### High-Level Components
```
Frontend (React/TypeScript)
└── Schedule Management
    ├── Class Input
    │   └── Conflict Management
    ├── Schedule Generation
    │   ├── Simulated Annealing Engine
    │   └── Parallel Workers
    └── Schedule Display
        └── Interactive Adjustments
```

## Core Algorithm Selection

### 1. Simulated Annealing

#### Decision Context
Need to solve complex scheduling problem with multiple competing constraints and preferences.

#### Why Simulated Annealing?
- Natural fit for schedule optimization
- Good balance of exploration and exploitation
- Flexible constraint handling
- Efficient mutation operations
- Parallelizable algorithm

#### Alternatives Considered

1. **Constraint Programming**
   - ✅ Guaranteed optimal solution
   - ✅ Clear constraint expression
   - ❌ Poor scaling with problem size
   - ❌ Too slow for real-world class sizes
   - ❌ Complex implementation

2. **Genetic Algorithms**
   - ✅ Good at global optimization
   - ✅ Natural parallelization
   - ❌ Complex chromosome representation
   - ❌ Harder to incorporate domain knowledge
   - ❌ Difficult constraint handling

3. **Simulated Annealing (Chosen)**
   - ✅ Natural schedule mutations
   - ✅ Easy constraint incorporation
   - ✅ Simple to implement and understand
   - ✅ Good performance in prototypes
   - ❌ No guarantee of optimal solution
   - ❌ Requires parameter tuning

#### Implementation Strategy
```typescript
class SimulatedAnnealingScheduler {
  // Core algorithm components
  temperature: Temperature
  mutationManager: MutationManager
  constraintValidator: ConstraintValidator
  scoreCalculator: ScoreCalculator
  
  // Optimization parameters
  initialTemp: number
  coolingRate: number
  iterationsPerTemp: number
  minTemp: number
  
  // Execution strategy
  async schedule(): Promise<Schedule> {
    let current = this.generateInitialSchedule()
    let best = current
    
    while (!this.isTerminated()) {
      // Multiple iterations at each temperature
      for (let i = 0; i < this.iterationsPerTemp; i++) {
        const neighbor = this.mutationManager.mutate(current)
        if (this.shouldAccept(current, neighbor)) {
          current = neighbor
          if (current.score > best.score) {
            best = current
          }
        }
      }
      this.temperature.cool()
    }
    
    return best
  }
}
```

### 2. Parallel Processing

#### Decision Context
Need to improve performance for large schedules and enable multiple concurrent optimization attempts.

#### Why Worker Threads?
- Lightweight threading model
- Shared memory capabilities
- Good for CPU-bound tasks
- Easy coordination

#### Implementation Strategy
```typescript
class ParallelScheduler {
  private workers: Worker[]
  private results: Map<number, Schedule>
  
  async schedule(): Promise<Schedule> {
    // Launch multiple workers with different:
    // - Starting temperatures
    // - Mutation probabilities
    // - Initial schedules
    this.initializeWorkers()
    
    // Collect and combine results
    const results = await this.gatherResults()
    return this.selectBestSchedule(results)
  }
}
```

## Core Design Patterns

### 1. Type System Architecture
```typescript
// Core types with strict hierarchies
interface BaseSchedule {
  classes: Class[]
  periods: Period[]
}

interface PartialSchedule extends BaseSchedule {
  unscheduledClasses: Class[]
  score?: number
}

interface CompleteSchedule extends BaseSchedule {
  score: number
  metrics: ScheduleMetrics
}

// Strategy pattern for mutations
interface MutationStrategy {
  apply(schedule: Schedule): Schedule
  probability: number
}

// Composite pattern for constraints
interface Constraint {
  validate(schedule: Schedule): boolean
  score(schedule: Schedule): number
}
```

### 2. Grade Group Design
Grade groups are first-class concepts with dedicated:
- Type definitions
- Mutation strategies
- Scoring components
- Visualization support

### 3. Constraint System
Flexible constraint system supporting:
- Hard vs soft constraints
- Complex relationships
- Custom scoring
- Efficient validation

## Technical Evolution

### 1. Current Technical Debt

#### Constraint Validation Performance
- **Issue**: O(n²) validation in some cases
- **Impact**: Slows down large schedules
- **Plan**: Implement incremental validation
- **Status**: Planned for next sprint

#### Worker Communication
- **Issue**: Basic message passing
- **Impact**: Not utilizing shared memory
- **Plan**: Implement SharedArrayBuffer
- **Status**: Under investigation

#### Test Data Generation
- **Issue**: Manual test data
- **Impact**: Limited test scenarios
- **Plan**: Implement procedural generation
- **Status**: In progress

### 2. Future Technical Directions

#### Machine Learning Integration
- Parameter optimization
- Starting point prediction
- Mutation guidance
- Constraint weight learning

#### Advanced Parallelization
- SharedArrayBuffer implementation
- Dynamic work distribution
- Result aggregation strategies
- Load balancing

#### UI/UX Improvements
- Interactive adjustments
- Real-time feedback
- Comparison tools
- Visualization enhancements

## Performance Considerations

### Current Metrics
- 50 classes: 56% success rate
- Test suite: ~350 seconds
- Memory usage: ~200MB peak

### Target Metrics
- 50 classes: 95% success rate
- Test suite: < 100 seconds
- Memory usage: < 150MB peak

### Performance Patterns
1. **CPU Usage**
   - Constraint checking: 45%
   - Schedule mutation: 30%
   - Score calculation: 15%
   - Other: 10%

2. **Memory Patterns**
   - Peaks during mutations
   - Worker communication overhead
   - Schedule representation impact

## Key Implementation Insights

### 1. Mutation Strategies
- Single-class moves often insufficient
- Grade-group moves more effective
- Need mutation variety
- Temperature-dependent selection

### 2. Temperature Management
- Initial temperature critical
- Slow cooling more effective
- Multiple restarts beneficial
- Adaptive cooling helps

### 3. Constraint Handling
- Balance between hard/soft
- Careful weight tuning needed
- Grade cohesion important
- Incremental validation key

### 4. Parallel Processing
- Worker coordination overhead
- Result aggregation strategy
- Memory sharing benefits
- Load balancing impact

================
File: docs/directory_index.md
================
# Project Documentation Directory Index

## Documentation Structure

### Core Documentation
- `README.md`: Project overview, setup instructions, and basic usage
- `AI_RULES_AND_GUIDELINES.md`: Guidelines for AI development and interaction
- `docs/system_overview.md`: Comprehensive functional overview of the system
- `docs/architecture_overview.md`: Technical architecture and design decisions
- `docs/technical_implementation.md`: Detailed implementation patterns and strategies
- `docs/performance_guide.md`: Performance optimization and monitoring
- `docs/testing_guide.md`: Testing strategy and guidelines
- `docs/ai_onboarding.md`: Detailed guide for onboarding new AI assistants
- `docs/directory_index.md`: This file - maps all documentation files

### Project Status
1. **Task Tracking**
   - `tasks.md`: Active, completed, blocked, and future tasks
   - Update: Before each development session
   - Purpose: Track task progress and dependencies

2. **Change Documentation**
   - `changelog.md`: All project changes and updates
   - Update: After each significant change
   - Purpose: Version history and change tracking

3. **Project Overview**
   - `project_summary.md`: High-level project status and architecture
   - Update: After major milestones or architectural changes
   - Purpose: Maintain current project overview

### Source Code (`/src/`)
1. **Core Components**
   - `types/`: Core type definitions
   - `engine/`: Scheduling logic
   - `constraints/`: Constraint system
   - `workers/`: Parallel processing

2. **Tests**
   - `__tests__/unit/`: Unit tests
   - `__tests__/integration/`: Integration tests
   - `__tests__/performance/`: Performance tests
   - `__tests__/fixtures/`: Test data and utilities

## Update Guidelines

### When to Update Each File

1. **For Code Changes:**
   - Update `changelog.md`
   - Update `technical_implementation.md` if patterns change
   - Update `performance_guide.md` if performance-related
   - Update `system_overview.md` if functionality changes

2. **For New Features:**
   - Update `README.md`
   - Update `project_summary.md`
   - Update `system_overview.md`
   - Update `technical_implementation.md`
   - Add/update relevant tests

3. **For Architecture Changes:**
   - Update `architecture_overview.md`
   - Update `project_summary.md`
   - Update `changelog.md`
   - Update affected documentation

4. **For Performance Changes:**
   - Update `performance_guide.md`
   - Update `changelog.md`
   - Update performance test suite

### Documentation Categories

1. **Entry Points**
   - Purpose: Quick project understanding
   - Files: README.md, directory_index.md
   - Update: Major changes
   - Audience: All developers

2. **System Understanding**
   - Purpose: Functional overview
   - Files: system_overview.md
   - Update: Feature changes
   - Audience: All developers

3. **Technical Details**
   - Purpose: Implementation details
   - Files: architecture_overview.md, technical_implementation.md
   - Update: Technical changes
   - Audience: Core developers

4. **Performance**
   - Purpose: Optimization guidance
   - Files: performance_guide.md
   - Update: Performance changes
   - Audience: Core developers

5. **Testing**
   - Purpose: Test strategy
   - Files: testing_guide.md
   - Update: Test changes
   - Audience: All developers

### File Dependencies

1. Core Dependencies:
   ```
   code change → changelog.md → project_summary.md → system_overview.md
   ```

2. Technical Dependencies:
   ```
   architecture change → architecture_overview.md → technical_implementation.md
   performance change → performance_guide.md → technical_implementation.md
   ```

3. Test Dependencies:
   ```
   test change → testing_guide.md → technical_implementation.md
   ```

### Most Frequently Updated
1. `changelog.md` - Every change
2. `tasks.md` - Every session
3. `performance_guide.md` - Performance changes
4. `project_summary.md` - Major updates

### Documentation Best Practices

1. **File Organization**
   - Keep related files together
   - Use consistent naming
   - Maintain clear hierarchy
   - Follow established structure

2. **Content Management**
   - Keep descriptions concise
   - Use consistent formatting
   - Include relevant examples
   - Maintain up-to-date status

3. **Updates**
   - Follow dependency order
   - Update all affected files
   - Maintain consistency
   - Keep cross-references valid

4. **Quality Control**
   - Verify file paths
   - Check cross-references
   - Validate code examples
   - Ensure accuracy

================
File: docs/performance_guide.md
================
# Performance Guide

## Overview

The class scheduler is designed to handle large-scale scheduling tasks efficiently. This guide provides insights into performance characteristics and optimization strategies.

## Performance Metrics

### Current Performance

1. **Test Coverage**
   - Statement Coverage: 96%
   - Branch Coverage: 82%
   - Function Coverage: 100%

2. **Schedule Generation Times**
   - Small Schedules (20 classes): < 1 second
   - Medium Schedules (50 classes): 1-3 seconds
   - Large Schedules (100+ classes): 3-10 seconds

3. **Memory Usage**
   - Base Memory: ~50MB
   - Per 100 Classes: +10MB
   - Peak Usage: ~200MB for largest schedules

### Optimization Targets

1. **Schedule Quality**
   - Total Length Score: > 0.95
   - Grade Group Cohesion: > 0.7
   - Distribution Quality: > 0.8
   - Zero total conflicts

2. **Resource Utilization**
   - CPU Usage: < 50% during generation
   - Memory Growth: Linear with class count
   - Disk I/O: Minimal

## Best Practices

### 1. Constraint Management

- **Use Total Conflicts Sparingly**
  - Reserve for absolute requirements
  - Each total conflict reduces flexibility
  - Can impact generation time

- **Leverage Partial Conflicts**
  - Use for soft constraints
  - No performance penalty
  - Provides scheduling flexibility

### 2. Schedule Generation

- **Initial Solution**
  - Fast generation with 99% slot acceptance
  - Randomization for diverse solutions
  - Minimal constraint checking

- **Optimization Phase**
  - Focuses on critical metrics
  - Efficient score calculation
  - Early termination when targets met

### 3. Data Management

- **Class Organization**
  - Group similar classes together
  - Pre-calculate common values
  - Use efficient data structures

- **Memory Management**
  - Clear unused schedules
  - Limit solution history
  - Regular garbage collection

## Optimization Tips

### 1. Algorithm Tuning

```typescript
// Optimal configuration for balance of speed and quality
const config = {
  maxAttempts: 50,
  maxIterations: 1000,
  acceptanceRate: 0.99,
  scoreWeights: {
    totalLength: 1,
    gradeGroupCohesion: 0.5,
    distributionQuality: 0.3,
    constraintViolations: -100,
    partialConflictPenalty: 0
  }
};
```

### 2. Resource Management

- **CPU Optimization**
  - Batch similar operations
  - Use efficient algorithms
  - Limit recursive operations

- **Memory Optimization**
  - Reuse objects when possible
  - Clear temporary data
  - Monitor memory growth

### 3. Scaling Strategies

- **Horizontal Scaling**
  - Parallel schedule generation
  - Distributed constraint checking
  - Load balancing

- **Vertical Scaling**
  - Increase memory limits
  - Optimize core algorithms
  - Enhance data structures

## Troubleshooting

### Common Issues

1. **Slow Generation**
   - Too many total conflicts
   - Inefficient constraint checking
   - Resource contention

2. **Poor Quality**
   - Insufficient iterations
   - Unbalanced weights
   - Conflicting constraints

3. **Resource Issues**
   - Memory leaks
   - CPU bottlenecks
   - I/O congestion

### Solutions

1. **Performance**
   - Review and reduce constraints
   - Optimize critical paths
   - Monitor resource usage

2. **Quality**
   - Adjust score weights
   - Increase iteration count
   - Review constraint logic

3. **Resources**
   - Implement cleanup routines
   - Use efficient algorithms
   - Monitor system metrics

## Monitoring

### Key Metrics

1. **Schedule Quality**
   - Success rate
   - Constraint satisfaction
   - Score distribution

2. **Performance**
   - Generation time
   - Resource usage
   - Error rates

3. **System Health**
   - Memory usage
   - CPU utilization
   - I/O patterns

### Tools

1. **Built-in**
   - Performance logging
   - Error tracking
   - Quality metrics

2. **External**
   - System monitors
   - Profiling tools
   - Load testers

## Future Optimizations

### Planned Improvements

1. **Algorithm**
   - Enhanced conflict resolution
   - Better initial solutions
   - Smarter optimization

2. **Performance**
   - Parallel processing
   - Improved caching
   - Better memory management

3. **Quality**
   - Machine learning optimization
   - Advanced constraints
   - Real-time adjustments

## Performance Goals

### Current Metrics
- Small schedules (3-15 classes): 92-98% optimization
- Medium schedules (20-22 classes): 85-97% optimization
- Large schedules (30+ classes): 73-74% optimization
- Memory usage: ~150MB peak
- Average optimization time: 
  * Small schedules: < 5 seconds
  * Medium schedules: < 15 seconds
  * Large schedules: < 30 seconds

### Target Metrics
- Large schedules (30+ classes): > 85% optimization
- Memory usage: < 100MB peak
- Average optimization time for large schedules: < 20 seconds

## Optimization Strategies

### 1. Simulated Annealing Parameters

#### Temperature Control
```typescript
class SimulatedAnnealing {
  private calculateTemperature(iteration: number): number {
    const completionRate = this.getCompletionRate()
    const baseRate = this.config.coolingRate
    
    // Adjust cooling rate based on completion
    return this.initialTemp * Math.pow(
      baseRate + (1 - completionRate) * 0.1, 
      iteration
    )
  }
}
```

#### Adaptive Shake Operation
```typescript
class SimulatedAnnealing {
  private shakeSchedule(schedule: Schedule): void {
    // Remove 2-20% of classes based on schedule size
    const removalRate = Math.min(0.2, 0.02 + schedule.size * 0.005)
    const numToRemove = Math.max(2, Math.floor(schedule.size * removalRate))
    
    this.removeRandomClasses(schedule, numToRemove)
  }
}
```

### 2. Memory Optimization

#### Schedule Cloning
```typescript
class Schedule {
  clone(): Schedule {
    // Efficient cloning using structured clone
    return {
      ...this,
      classes: structuredClone(this.classes),
      metrics: { ...this.metrics }
    }
  }
}
```

#### Memory Pooling
```typescript
class SchedulePool {
  private pool: Schedule[] = []
  private maxPoolSize = 100

  acquire(): Schedule {
    return this.pool.pop() || new Schedule()
  }

  release(schedule: Schedule): void {
    if (this.pool.length < this.maxPoolSize) {
      schedule.reset()
      this.pool.push(schedule)
    }
  }
}
```

### 3. Score Calculation

#### Incremental Updates
```typescript
class ScoreCalculator {
  private updateScore(schedule: Schedule, change: ScheduleChange): number {
    const affectedMetrics = this.getAffectedMetrics(change)
    
    return affectedMetrics.reduce((score, metric) => {
      const oldValue = schedule.metrics[metric]
      const newValue = this.calculateMetric(schedule, metric)
      schedule.metrics[metric] = newValue
      
      return score - (oldValue * this.weights[metric]) + 
             (newValue * this.weights[metric])
    }, schedule.score)
  }
}
```

## Performance Bottlenecks

### 1. Constraint Validation Examples

#### Original Implementation (O(n²))
```typescript
class TeacherConflictConstraint {
  validate(schedule: Schedule): boolean {
    // O(n²) implementation
    return schedule.periods.every(period => {
      const teachers = new Set()
      for (const classId of period.assignedClasses) {
        const teacher = schedule.classes.get(classId).classInfo.teacher
        if (teachers.has(teacher)) return false
        teachers.add(teacher)
      }
      return true
    })
  }
}
```

#### Optimized Implementation (O(n))
```typescript
class TeacherConflictConstraint {
  validate(schedule: Schedule): boolean {
    // O(n) implementation with pre-computed index
    return schedule.periods.every(period => {
      const teacherIndex = this.getTeacherIndex(period)
      return Object.values(teacherIndex).every(count => count <= 1)
    })
  }

  private getTeacherIndex(period: Period): Record<TeacherId, number> {
    return Array.from(period.assignedClasses).reduce((index, classId) => {
      const teacher = this.classes.get(classId).classInfo.teacher
      index[teacher] = (index[teacher] || 0) + 1
      return index
    }, {})
  }
}
```

### 2. Profiling Tools and Techniques

#### Memory Profiling
```typescript
class MemoryProfiler {
  private snapshots: MemorySnapshot[] = []
  
  takeSnapshot(): void {
    this.snapshots.push({
      timestamp: Date.now(),
      usage: process.memoryUsage(),
      allocation: this.getDetailedAllocation()
    })
  }
  
  analyzeGrowth(): MemoryGrowthReport {
    return {
      heapGrowth: this.calculateHeapGrowth(),
      leakSuspects: this.findLeakSuspects(),
      recommendations: this.generateRecommendations()
    }
  }

  private getDetailedAllocation(): AllocationDetails {
    return {
      schedules: this.countScheduleInstances(),
      caches: this.getCacheSizes(),
      workers: this.getWorkerMemory()
    }
  }
}
```

#### Performance Profiling
```typescript
class PerformanceProfiler {
  private marks: Map<string, number> = new Map()
  private measurements: PerformanceMeasurement[] = []
  
  mark(label: string): void {
    this.marks.set(label, performance.now())
  }
  
  measure(start: string, end: string): number {
    const duration = this.marks.get(end)! - this.marks.get(start)!
    
    this.measurements.push({
      operation: `${start}->${end}`,
      duration,
      timestamp: Date.now()
    })
    
    return duration
  }
  
  generateReport(): PerformanceReport {
    return {
      totalTime: this.calculateTotalTime(),
      breakdowns: this.calculateBreakdowns(),
      hotspots: this.findHotspots(),
      recommendations: this.generateOptimizationSuggestions()
    }
  }

  private findHotspots(): HotspotAnalysis[] {
    return this.measurements
      .groupBy('operation')
      .map(group => ({
        operation: group.operation,
        totalTime: group.sum('duration'),
        avgTime: group.average('duration'),
        frequency: group.length,
        impact: this.calculateImpact(group)
      }))
      .sort((a, b) => b.impact - a.impact)
  }
}
```

#### Worker Profiling
```typescript
class WorkerProfiler {
  private workerMetrics: Map<number, WorkerMetrics> = new Map()
  
  trackWorker(workerId: number): void {
    this.workerMetrics.set(workerId, {
      startTime: Date.now(),
      schedules: 0,
      successRate: 0,
      avgGenerationTime: 0,
      memoryUsage: 0,
      lastActive: Date.now()
    })
  }
  
  updateMetrics(workerId: number, result: ScheduleResult): void {
    const metrics = this.workerMetrics.get(workerId)!
    metrics.schedules++
    metrics.successRate = this.calculateSuccessRate(metrics)
    metrics.avgGenerationTime = this.calculateAvgTime(metrics)
    metrics.lastActive = Date.now()
  }

  generateWorkerReport(): WorkerReport {
    return {
      totalWorkers: this.workerMetrics.size,
      activeWorkers: this.countActiveWorkers(),
      averageSuccessRate: this.calculateOverallSuccessRate(),
      workerUtilization: this.calculateWorkerUtilization(),
      recommendations: this.generateWorkerRecommendations()
    }
  }
}
```

## Performance Monitoring

### 1. Metrics Collection
```typescript
interface PerformanceMetrics {
  optimizationScore: number
  timeElapsed: number
  memoryUsage: number
  iterationCount: number
  temperature: number
  acceptanceRate: number
}

class PerformanceMonitor {
  private metrics: PerformanceMetrics[] = []
  
  collect(metrics: PerformanceMetrics): void {
    this.metrics.push({
      ...metrics,
      timestamp: Date.now()
    })
  }
  
  analyze(): PerformanceAnalysis {
    return {
      averageScore: this.calculateAverageScore(),
      averageTime: this.calculateAverageTime(),
      memoryProfile: this.analyzeMemoryUsage(),
      acceptanceRateProfile: this.analyzeAcceptanceRate()
    }
  }
}
```

### 2. Performance Reporting
```typescript
interface PerformanceReport {
  timestamp: number
  scheduleSize: number
  optimizationScore: number
  executionTime: number
  memoryUsage: number
  acceptanceRate: number
}

class PerformanceReporter {
  generateReport(metrics: PerformanceMetrics[]): PerformanceReport {
    return {
      timestamp: Date.now(),
      scheduleSize: this.currentSchedule.size,
      optimizationScore: this.calculateFinalScore(),
      executionTime: this.getExecutionTime(),
      memoryUsage: process.memoryUsage().heapUsed,
      acceptanceRate: this.calculateAcceptanceRate()
    }
  }
}
```

## Optimization Guidelines

### 1. Schedule Size Optimization
- Use appropriate initial temperature based on schedule size
- Adjust cooling rate based on completion progress
- Implement adaptive shake operation intensity

### 2. Memory Management
- Implement schedule object pooling
- Use efficient cloning strategies
- Maintain bounded result storage
- Clear unused caches regularly

### 3. Algorithm Tuning
- Adjust weights based on schedule size:
  * Small schedules: Higher weight on distribution
  * Large schedules: Higher weight on completeness
- Use adaptive neighbor generation:
  * More aggressive early in optimization
  * More conservative as schedule improves
- Implement smart restart strategies

### 4. Parallel Processing
- Distribute work across available cores
- Use SharedArrayBuffer for efficient communication
- Implement work stealing for load balancing
- Aggregate results incrementally

================
File: docs/system_overview.md
================
# ClassRotation: Advanced Class Scheduling System

## Purpose & Goals
ClassRotation is designed to create optimized schedules for rotating classes through different periods and days. The system aims to:
1. Schedule all provided classes across available time slots
2. Manage scheduling constraints through class-specific unavailable periods
3. Optimize for grade-level grouping and progression
4. Ensure robust conflict resolution via total and partial conflicts
5. Support parallel processing for efficient schedule generation

## System Performance

### Schedule Optimization
The system achieves the following optimization scores:
- Small schedules (3-15 classes): 92-98% optimization
- Medium schedules (20-22 classes): 85-97% optimization
- Large schedules (30+ classes): 73-74% optimization

### Optimization Weights
Schedule quality is evaluated using three primary metrics:
1. Completeness (40%): Ratio of scheduled to total classes
2. Cohesion (30%): Grade group scheduling effectiveness
3. Distribution (30%): Even spread of classes across periods

## Input Components

### 1. Classes
Each class has:
- Class number and name
- Teacher name
- Grade level (Pre-K through 5th, or mixed)
- Scheduling Constraints:
  * Total Conflicts: Periods when the class absolutely cannot be scheduled (includes teacher unavailability)
  * Partial Conflicts: Periods when scheduling is discouraged (70% probability of conflict)
- Can be input manually or imported via JSON

### 2. Constraint System
The system manages scheduling through two primary constraint types:

#### Hard Constraints
- Classes cannot be scheduled during their specified total conflicts
- This includes teacher unavailability and other absolute restrictions
- Maximum periods per day and week limits are enforced

#### Soft Constraints
- Partial conflicts are handled probabilistically (70% chance of conflict)
- Grade group cohesion preferences
- Distribution preferences for even class spread

### 3. Grade Groups & Preferences
- Grade groups: Custom groupings of classes by grade level
- Preferences:
  * Whether to keep same grade levels together in a day
  * Grade progression preference (high-to-low, low-to-high, or none)
  * Grade group cohesion importance

### 4. Period Structure
- 8 possible periods per day
- 5 days per week (Monday-Friday)
- Support for blackout periods (globally blocked time slots)

## Scheduling Algorithm

The class scheduler uses a sophisticated algorithm designed to generate optimal schedules while respecting various constraints and preferences. Here's how it works:

### Core Components

1. **Schedule Engine**
   - Handles the core scheduling logic
   - Manages class assignments and conflict resolution
   - Calculates schedule scores based on multiple metrics

2. **Score Calculation**
   - Total Length: Ratio of scheduled classes to total classes
   - Grade Group Cohesion: Measures how well classes of the same grade group are scheduled together
   - Distribution Quality: Evaluates the spread of classes across available days
   - Constraint Violations: Heavily penalizes violations of hard constraints

### Conflict Resolution

The scheduler employs a two-tier conflict resolution system:

1. **Total Conflicts**
   - Strictly enforced - no classes can be scheduled in slots with total conflicts
   - Used for absolute scheduling constraints (e.g., teacher unavailability)
   - Highest priority in the scheduling process

2. **Partial Conflicts**
   - Flexibly handled - allowed but monitored
   - Used for soft constraints or preferences
   - Does not affect schedule score, allowing for more adaptable solutions

### Scheduling Strategy

The algorithm follows these steps:

1. **Initial Solution Generation**
   - Creates an initial schedule respecting total conflicts
   - Uses a high acceptance rate (99%) for valid slots
   - Employs randomization to explore diverse solutions

2. **Schedule Optimization**
   - Focuses on maximizing class distribution and cohesion
   - Maintains grade group relationships where possible
   - Balances class load across available days

3. **Solution Refinement**
   - Iteratively improves initial solutions
   - Uses simulated annealing for optimization
   - Accepts improvements based on overall schedule score

### Performance Characteristics

- Statement Coverage: ~96%
- Branch Coverage: ~82%
- Function Coverage: 100%
- Handles up to 100+ classes efficiently
- Quick generation of initial solutions
- Robust handling of complex constraints

### Best Practices

1. **Constraint Definition**
   - Define total conflicts for hard constraints
   - Use partial conflicts for flexible preferences
   - Keep constraints realistic and necessary

2. **Schedule Generation**
   - Start with essential constraints only
   - Add additional constraints incrementally
   - Monitor schedule quality after changes

3. **Performance Optimization**
   - Limit unnecessary constraints
   - Use appropriate time windows
   - Balance between quality and generation speed

### Configuration Options

The scheduler can be configured through:

1. **Schedule Constraints**
   - Maximum periods per day
   - Maximum classes per day
   - Maximum consecutive periods

2. **Schedule Preferences**
   - Grade group cohesion weights
   - Distribution quality preferences
   - Schedule length optimization

### Future Considerations

1. **Potential Enhancements**
   - Configurable conflict penalties
   - Advanced machine learning optimization
   - Real-time schedule adjustment capabilities

2. **Scalability Plans**
   - Enhanced performance for larger datasets
   - Distributed scheduling capabilities
   - Improved constraint handling mechanisms

### Monitoring and Maintenance

Regular monitoring of:
- Schedule generation times
- Constraint satisfaction rates
- Resource utilization
- User satisfaction metrics

## Processing & Optimization

### Core Algorithm
1. Base ScheduleEngine:
   - Handles constraint validation
   - Manages candidate solutions
   - Scores schedules based on multiple factors

2. Simulated Annealing:
   - Adaptive temperature control
   - Multi-objective optimization
   - Shake operation for escaping local optima
   - Removes 2-20% of classes during shake
   - Weighted scoring system

### **Future Development: Parallel Processing**
- Plan to implement multiple concurrent optimization attempts
- Utilize worker threads for parallel execution
- Develop inter-worker communication protocols
- Implement load balancing and resource optimization

### Worker System Architecture
1. Worker Pool Management:
   - Dynamic worker creation and termination
   - Resource-aware worker allocation
   - Worker health monitoring
   - Automatic worker recovery

2. Inter-Worker Communication:
   - SharedArrayBuffer for efficient data sharing
   - Atomic operations for synchronization
   - Message-based control flow
   - Result aggregation protocol

3. Work Distribution:
   - Dynamic load balancing
   - Work stealing algorithm
   - Priority-based scheduling
   - Resource utilization optimization

## Schedule Generation Process

1. Initial Schedule Creation:
   - Random initial class placement
   - Basic constraint validation
   - Initial score calculation

2. Optimization Phase:
   - Simulated annealing iterations
   - Temperature-based acceptance
   - Periodic schedule shaking
   - Best solution tracking

3. Solution Refinement:
   - Grade group cohesion improvement
   - Distribution balancing
   - Final constraint validation

## Output & Results

### Schedule Format
- Complete class assignments
- Period allocations
- Grade group distributions

### Quality Metrics
1. Completeness Score:
   - Percentage of scheduled classes
   - Distribution across periods

2. Cohesion Score:
   - Grade group integrity
   - Teacher schedule efficiency
   - Progression adherence

3. Distribution Score:
   - Period utilization balance
   - Daily class spread
   - Weekly distribution

## Next Development Steps

1. Constraint Validation Optimization:
   - Improve performance of schedule validation
   - Implement caching and incremental checks

2. User Interface Development:
   - Schedule visualization
   - Manual adjustment tools
   - Preference configuration

3. Data Management:
   - Persistence layer
   - Import/export functionality
   - Template system

4. Future Features:
   - Parallel processing implementation
   - Real-time schedule updates
   - Collaborative editing
   - Schedule versioning

================
File: docs/technical_implementation.md
================
# Technical Implementation Guide

## Core Components

### 1. Schedule Engine

#### Schedule Interface
```typescript
interface Schedule {
  classes: ScheduledClass[]
  getUnscheduledClasses(): Class[]
  getScheduledClassCount(): number
  getTotalClassCount(): number
  addClass(cls: ScheduledClass): void
  removeClass(cls: ScheduledClass): void
  clone(): Schedule
}

interface ScheduledClass {
  class: Class
  date: Date
  period: number
}
```

#### Score Calculation
The engine uses a weighted scoring system to evaluate schedule quality:

```typescript
weights = {
  totalLength: 1,          // Importance of scheduling all classes
  gradeGroupCohesion: 0.5, // How well classes in same grade are grouped
  distributionQuality: 0.3, // Even distribution across available days
  constraintViolations: -100, // Heavy penalty for breaking hard constraints
  partialConflictPenalty: 0   // No penalty for partial conflicts
}
```

#### Core Algorithm
```typescript
class SimulatedAnnealing {
  public optimize(schedule: Schedule): Schedule {
    let currentSolution = schedule.clone()
    let currentScore = this.calculateWeightedScore(currentSolution)
    let temperature = this.config.initialTemperature

    while (temperature > this.config.minTemperature) {
      for (let i = 0; i < this.config.iterationsPerTemp; i++) {
        const neighbor = this.generateNeighbor(currentSolution)
        const neighborScore = this.calculateWeightedScore(neighbor)

        if (this.acceptSolution(currentScore, neighborScore, temperature)) {
          currentSolution = neighbor
          currentScore = neighborScore
        }

        if (neighborScore > this.bestScore) {
          this.bestSolution = neighbor.clone()
          this.bestScore = neighborScore
        }
      }

      temperature *= this.config.coolingRate
    }

    return this.bestSolution
  }
}
```

#### Neighbor Generation
```typescript
class SimulatedAnnealing {
  private generateNeighbor(schedule: Schedule): Schedule {
    const neighbor = schedule.clone()
    const completionRate = schedule.getScheduledClassCount() / schedule.getTotalClassCount()
    
    // Adaptive probability based on completion rate
    const addUnscheduledProb = Math.min(0.9, 0.6 + (1 - completionRate) * 0.5)
    
    if (Math.random() < addUnscheduledProb) {
      this.addUnscheduledClass(neighbor)
    } else {
      this.shakeSchedule(neighbor)
    }

    return neighbor
  }

  private shakeSchedule(schedule: Schedule): void {
    const numToRemove = Math.max(2, Math.floor(schedule.classes.length * 0.2))
    const classesToRemove = [...schedule.classes]
      .sort(() => Math.random() - 0.5)
      .slice(0, numToRemove)
    
    classesToRemove.forEach(cls => schedule.removeClass(cls))
  }
}
```

### 2. Simulated Annealing Implementation

#### Configuration
```typescript
interface SimulatedAnnealingConfig {
  initialTemperature: number
  coolingRate: number
  minTemperature: number
  iterationsPerTemp: number
  maxRestarts: number
}
```

#### Initial Solution Generation

The initial schedule is generated using a probabilistic approach:

1. **Class Placement**
   - Randomly shuffles available dates and periods
   - Uses 99% acceptance rate for valid slots
   - Strictly enforces total conflict constraints
   - Ignores partial conflicts for flexibility

2. **Slot Selection**
   ```typescript
   if (!hasTotalConflict) {
     if (Math.random() < 0.99) {
       // Schedule the class in this slot
     }
   }
   ```

### 2. Constraint System

#### Constraint Types
```typescript
interface Constraint {
  id: string
  type: 'HARD' | 'SOFT'
  weight: number
  validate(schedule: Schedule): boolean
  score(schedule: Schedule): number
  getAffectedPeriods(schedule: Schedule): Period[]
  getDependentConstraints(): Constraint[]
}

class TeacherConflictConstraint implements Constraint {
  id = 'teacher_conflict'
  type = 'HARD'
  weight = 1000

  validate(schedule: Schedule): boolean {
    return schedule.periods.every(period => {
      const teachers = new Set()
      for (const classId of period.assignedClasses) {
        const teacher = schedule.classes.get(classId).classInfo.teacher
        if (teachers.has(teacher)) return false
        teachers.add(teacher)
      }
      return true
    })
  }

  score(schedule: Schedule): number {
    let conflicts = 0
    schedule.periods.forEach(period => {
      const teachers = new Map<string, number>()
      period.assignedClasses.forEach(classId => {
        const teacher = schedule.classes.get(classId).classInfo.teacher
        teachers.set(teacher, (teachers.get(teacher) || 0) + 1)
      })
      teachers.forEach(count => {
        if (count > 1) conflicts += count - 1
      })
    })
    return Math.max(0, 1 - (conflicts * this.weight))
  }

  getAffectedPeriods(schedule: Schedule): Period[] {
    return schedule.periods.filter(period => {
      const teachers = new Set()
      for (const classId of period.assignedClasses) {
        const teacher = schedule.classes.get(classId).classInfo.teacher
        if (teachers.has(teacher)) return true
        teachers.add(teacher)
      }
      return false
    })
  }

  getDependentConstraints(): Constraint[] {
    return [] // No dependent constraints
  }
}

class RoomCapacityConstraint implements Constraint {
  id = 'room_capacity'
  type = 'HARD'
  weight = 800

  constructor(private roomCapacities: Map<string, number>) {}

  validate(schedule: Schedule): boolean {
    return schedule.periods.every(period => {
      const rooms = new Map<string, number>()
      for (const classId of period.assignedClasses) {
        const room = schedule.classes.get(classId).classInfo.room
        const currentCount = rooms.get(room) || 0
        if (currentCount >= this.roomCapacities.get(room)!) return false
        rooms.set(room, currentCount + 1)
      }
      return true
    })
  }

  score(schedule: Schedule): number {
    let overages = 0
    schedule.periods.forEach(period => {
      const rooms = new Map<string, number>()
      period.assignedClasses.forEach(classId => {
        const room = schedule.classes.get(classId).classInfo.room
        const count = (rooms.get(room) || 0) + 1
        rooms.set(room, count)
        if (count > this.roomCapacities.get(room)!) {
          overages += count - this.roomCapacities.get(room)!
        }
      })
    })
    return Math.max(0, 1 - (overages * this.weight))
  }

  getAffectedPeriods(schedule: Schedule): Period[] {
    return schedule.periods.filter(period => {
      const rooms = new Map<string, number>()
      for (const classId of period.assignedClasses) {
        const room = schedule.classes.get(classId).classInfo.room
        const count = (rooms.get(room) || 0) + 1
        if (count > this.roomCapacities.get(room)!) return true
        rooms.set(room, count)
      }
      return false
    })
  }

  getDependentConstraints(): Constraint[] {
    return [] // No dependent constraints
  }
}

interface ClassConflict {
  date: Date
  period: number
  type: 'total' | 'partial'
}

interface Class {
  id: string
  name: string
  teacher: string
  gradeLevel: string
  totalConflicts: ClassConflict[]
  partialConflicts: ClassConflict[]
}

class ClassConflictConstraint implements Constraint {
  id = 'class_conflict'
  type = 'HARD'
  weight = 1000

  validate(schedule: Schedule): boolean {
    return schedule.classes.every(cls => {
      const conflicts = cls.class.totalConflicts.filter(conflict =>
        conflict.date.getTime() === cls.date.getTime() &&
        conflict.period === cls.period
      )
      return conflicts.length === 0
    })
  }

  score(schedule: Schedule): number {
    let conflicts = 0
    schedule.classes.forEach(cls => {
      const conflicts = cls.class.totalConflicts.filter(conflict =>
        conflict.date.getTime() === cls.date.getTime() &&
        conflict.period === cls.period
      )
      conflicts += conflicts.length
    })
    return Math.max(0, 1 - (conflicts * this.weight))
  }

  getAffectedPeriods(schedule: Schedule): Period[] {
    return schedule.periods.filter(period => {
      const classes = period.assignedClasses.map(classId => schedule.classes.get(classId)!)
      return classes.some(cls => cls.class.totalConflicts.some(conflict =>
        conflict.date.getTime() === cls.date.getTime() &&
        conflict.period === cls.period
      ))
    })
  }

  getDependentConstraints(): Constraint[] {
    return [] // No dependent constraints
  }
}

class ClassPartialConflictConstraint implements Constraint {
  id = 'class_partial_conflict'
  type = 'SOFT'
  weight = 500

  validate(schedule: Schedule): boolean {
    return schedule.classes.every(cls => {
      const conflicts = cls.class.partialConflicts.filter(conflict =>
        conflict.date.getTime() === cls.date.getTime() &&
        conflict.period === cls.period
      )
      return conflicts.length === 0
    })
  }

  score(schedule: Schedule): number {
    let conflicts = 0
    schedule.classes.forEach(cls => {
      const conflicts = cls.class.partialConflicts.filter(conflict =>
        conflict.date.getTime() === cls.date.getTime() &&
        conflict.period === cls.period
      )
      conflicts += conflicts.length
    })
    return Math.max(0, 1 - (conflicts * this.weight))
  }

  getAffectedPeriods(schedule: Schedule): Period[] {
    return schedule.periods.filter(period => {
      const classes = period.assignedClasses.map(classId => schedule.classes.get(classId)!)
      return classes.some(cls => cls.class.partialConflicts.some(conflict =>
        conflict.date.getTime() === cls.date.getTime() &&
        conflict.period === cls.period
      ))
    })
  }

  getDependentConstraints(): Constraint[] {
    return [] // No dependent constraints
  }
}
```

#### Constraint Validation System
```typescript
class ConstraintValidator {
  private constraints: Map<string, Constraint>
  private validationCache: Map<string, boolean>
  private dependencyGraph: Map<string, Set<string>>

  constructor(constraints: Constraint[]) {
    this.constraints = new Map(
      constraints.map(c => [c.id, c])
    )
    this.buildDependencyGraph()
  }

  validateAll(schedule: Schedule): boolean {
    return Array.from(this.constraints.values())
      .filter(c => c.type === 'HARD')
      .every(c => this.validateConstraint(schedule, c))
  }

  validateIncremental(schedule: Schedule, change: ScheduleChange): boolean {
    const affectedConstraints = this.getAffectedConstraints(change)
    return affectedConstraints
      .filter(c => c.type === 'HARD')
      .every(c => this.validateConstraint(schedule, c))
  }

  private validateConstraint(
    schedule: Schedule, 
    constraint: Constraint
  ): boolean {
    const cacheKey = this.getCacheKey(schedule, constraint)
    
    if (this.validationCache.has(cacheKey)) {
      return this.validationCache.get(cacheKey)!
    }

    const result = constraint.validate(schedule)
    this.validationCache.set(cacheKey, result)
    return result
  }

  private getAffectedConstraints(change: ScheduleChange): Constraint[] {
    const directlyAffected = new Set<string>()
    
    // Find constraints directly affected by the change
    this.constraints.forEach(constraint => {
      const affectedPeriods = constraint.getAffectedPeriods(change.schedule)
      if (affectedPeriods.some(p => change.affectsPeriod(p))) {
        directlyAffected.add(constraint.id)
      }
    })

    // Add dependent constraints
    const allAffected = new Set<string>(directlyAffected)
    directlyAffected.forEach(id => {
      this.getDependentConstraints(id).forEach(depId => {
        allAffected.add(depId)
      })
    })

    return Array.from(allAffected)
      .map(id => this.constraints.get(id)!)
  }

  private buildDependencyGraph(): void {
    this.dependencyGraph = new Map()
    
    this.constraints.forEach(constraint => {
      const dependents = new Set<string>()
      constraint.getDependentConstraints().forEach(dep => {
        dependents.add(dep.id)
      })
      this.dependencyGraph.set(constraint.id, dependents)
    })
  }

  private getDependentConstraints(constraintId: string): Set<string> {
    const result = new Set<string>()
    const toProcess = [constraintId]
    
    while (toProcess.length > 0) {
      const current = toProcess.pop()!
      const dependents = this.dependencyGraph.get(current) || new Set()
      
      dependents.forEach(dep => {
        if (!result.has(dep)) {
          result.add(dep)
          toProcess.push(dep)
        }
      })
    }
    
    return result
  }

  private getCacheKey(schedule: Schedule, constraint: Constraint): string {
    return `${schedule.hash()}-${constraint.id}`
  }
}
```

### 3. Parallel Processing

#### Worker Communication
```typescript
interface WorkerMessage {
  type: 'START' | 'RESULT' | 'ERROR'
  payload: {
    schedule?: Schedule
    score?: number
    error?: string
  }
}

class ParallelScheduler {
  private workers: Worker[]
  private results: Map<number, Schedule>

  async generateSchedule(): Promise<Schedule> {
    const promises = this.workers.map(worker => 
      this.runWorker(worker)
    )
    
    const schedules = await Promise.all(promises)
    return this.selectBestSchedule(schedules)
  }
}
```

### 4. Grade Group System

#### Grade Group Management
```typescript
interface GradeGroup {
  id: string
  grades: string[]
  preferences: GradePreferences
  constraints: GradeConstraint[]
}

interface GradePreferences {
  keepGradesTogether: boolean
  progressionDirection: 'high-to-low' | 'low-to-high' | 'none'
  cohesionWeight: number
}

class GradeGroupManager {
  private groups: Map<string, GradeGroup>
  private groupScores: Map<string, number>

  validateGroupConstraints(schedule: Schedule): boolean {
    return Array.from(this.groups.values())
      .every(group => this.validateGroup(schedule, group))
  }

  scoreGroupCohesion(schedule: Schedule): number {
    return Array.from(this.groups.values())
      .reduce((score, group) => 
        score + this.calculateGroupCohesion(schedule, group), 0)
  }

  private calculateGroupCohesion(schedule: Schedule, group: GradeGroup): number {
    const classes = this.getGroupClasses(schedule, group)
    const periods = this.getGroupPeriods(classes)
    
    return this.evaluateCohesion(classes, periods, group.preferences)
  }

  private evaluateCohesion(
    classes: ScheduledClass[], 
    periods: Period[], 
    preferences: GradePreferences
  ): number {
    let score = 0
    
    if (preferences.keepGradesTogether) {
      score += this.evaluateGradeProximity(classes)
    }
    
    if (preferences.progressionDirection !== 'none') {
      score += this.evaluateProgression(classes, preferences.progressionDirection)
    }
    
    return score * preferences.cohesionWeight
  }
}
```

#### Grade Progression
```typescript
class GradeProgressionValidator {
  validateProgression(
    schedule: Schedule, 
    direction: 'high-to-low' | 'low-to-high'
  ): boolean {
    const sortedClasses = this.getSortedClasses(schedule)
    const periods = this.getPeriodsInOrder(schedule)
    
    return this.checkProgression(sortedClasses, periods, direction)
  }

  private checkProgression(
    classes: ScheduledClass[], 
    periods: Period[], 
    direction: 'high-to-low' | 'low-to-high'
  ): boolean {
    let lastGrade = direction === 'high-to-low' ? Infinity : -Infinity
    
    for (const period of periods) {
      const periodGrade = this.getPeriodAverageGrade(classes, period)
      
      if (direction === 'high-to-low' && periodGrade > lastGrade) {
        return false
      }
      if (direction === 'low-to-high' && periodGrade < lastGrade) {
        return false
      }
      
      lastGrade = periodGrade
    }
    
    return true
  }
}
```

## Implementation Patterns

### 1. Immutable State Management
- All schedule modifications create new instances
- Original schedule objects are never modified
- Enables efficient state tracking and undo/redo

### 2. Adaptive Parameters
- Temperature cooling rate adjusts based on progress
- Neighbor generation probability adapts to completion rate
- Shake operation intensity varies with schedule size

### 3. Performance Optimization
- Efficient schedule cloning
- Cached score calculations
- Minimal object creation in hot paths
- Smart constraint validation

## Current Performance Characteristics

### 1. Time Complexity
- Schedule Generation: O(n * m)
  * n = number of classes
  * m = number of available periods
- Score Calculation: O(n)
- Constraint Validation: O(n * log n)

### 2. Space Complexity
- Base Schedule: O(n)
- Working Memory: O(n * w)
  * w = number of workers
- Result Storage: O(n * r)
  * r = number of retained solutions

### 3. Optimization Scores
- Small schedules (3-15 classes): 92-98%
- Medium schedules (20-22 classes): 85-97%
- Large schedules (30+ classes): 73-74%

## Next Implementation Steps

### 1. Performance Improvements
- Implement incremental constraint validation
- Optimize memory usage in worker communication
- Add result caching for similar schedules

### 2. Feature Implementation
- Add UI components for schedule visualization
- Implement data persistence layer
- Create export/import functionality

### 3. Code Quality
- Add comprehensive error handling
- Improve logging and monitoring
- Enhance test coverage

### 4. Architecture
- Implement true worker threads
- Add schedule template system
- Create collaborative editing support

================
File: docs/testing_guide.md
================
# Testing Guide

## Test Organization

### 1. Unit Tests
Located in `__tests__/unit`

#### Core Components
- `Schedule.test.ts`
- `Constraints.test.ts`
- `Mutations.test.ts`
- `GradeGroups.test.ts`

#### Test Data
```typescript
// __tests__/fixtures/scheduleFixtures.ts
export const createTestSchedule = (config: Partial<ScheduleConfig> = {}): Schedule => ({
  classes: new Map([
    [1, createTestClass({ id: 1, teacher: 'T1', grade: '9' })],
    [2, createTestClass({ id: 2, teacher: 'T2', grade: '10' })],
    // ... more test classes
  ]),
  periods: [
    createTestPeriod({ day: 'MONDAY', timeSlot: 1 }),
    createTestPeriod({ day: 'MONDAY', timeSlot: 2 }),
    // ... more test periods
  ],
  ...config
})

export const createTestClass = (config: Partial<ClassConfig> = {}): Class => ({
  id: config.id || 1,
  name: config.name || `Class ${config.id || 1}`,
  teacher: config.teacher || 'T1',
  gradeLevel: config.gradeLevel || '9',
  totalConflicts: config.totalConflicts || [],
  partialConflicts: config.partialConflicts || [],
  ...config
})

export const createScheduleWithClass = (cls: Class): Schedule => ({
  classes: new Map([[cls.id, cls]]),
  periods: [
    createTestPeriod({ day: 'MONDAY', timeSlot: 1 }),
    createTestPeriod({ day: 'MONDAY', timeSlot: 2 }),
    createTestPeriod({ day: 'MONDAY', timeSlot: 3 })
  ]
})

export const createScheduleWithClasses = (classes: Class[]): Schedule => ({
  classes: new Map(classes.map(cls => [cls.id, cls])),
  periods: [
    createTestPeriod({ day: 'MONDAY', timeSlot: 1 }),
    createTestPeriod({ day: 'MONDAY', timeSlot: 2 }),
    createTestPeriod({ day: 'MONDAY', timeSlot: 3 })
  ]
})
```

### 2. Integration Tests
Located in `__tests__/integration`

#### End-to-End Flows
- Schedule generation
- Constraint validation
- Grade group optimization
- Worker coordination

#### Test Scenarios
```typescript
// __tests__/integration/scheduleGeneration.test.ts
describe('Schedule Generation', () => {
  const scenarios = [
    {
      name: 'small schedule',
      classes: 10,
      expectedSuccess: true,
      maxDuration: 1000
    },
    {
      name: 'medium schedule',
      classes: 50,
      expectedSuccess: true,
      maxDuration: 5000
    },
    {
      name: 'large schedule',
      classes: 100,
      expectedSuccess: true,
      maxDuration: 15000
    }
  ]

  scenarios.forEach(scenario => {
    it(`should handle ${scenario.name}`, async () => {
      const result = await generateSchedule(scenario)
      expect(result.success).toBe(scenario.expectedSuccess)
      expect(result.duration).toBeLessThan(scenario.maxDuration)
    })
  })
})

#### Conflict Handling Tests
```typescript
// __tests__/integration/conflictHandling.test.ts
describe('Class Conflict Handling', () => {
  describe('Total Conflicts', () => {
    it('should never schedule classes during total conflicts', () => {
      const class1 = createTestClass({
        id: 1,
        totalConflicts: [
          { date: new Date('2024-01-01'), period: 1, type: 'total' }
        ]
      })
      const schedule = createScheduleWithClass(class1)
      const result = scheduleEngine.generateSchedule(schedule)
      
      expect(result.classes.some(cls => 
        cls.date.getTime() === class1.totalConflicts[0].date.getTime() &&
        cls.period === class1.totalConflicts[0].period
      )).toBeFalsy()
    })

    it('should handle overlapping total conflicts', () => {
      const class1 = createTestClass({
        id: 1,
        totalConflicts: [
          { date: new Date('2024-01-01'), period: 1, type: 'total' }
        ]
      })
      const class2 = createTestClass({
        id: 2,
        totalConflicts: [
          { date: new Date('2024-01-01'), period: 1, type: 'total' }
        ]
      })
      const schedule = createScheduleWithClasses([class1, class2])
      const result = scheduleEngine.generateSchedule(schedule)
      
      expect(result.isValid()).toBeTruthy()
    })
  })

  describe('Partial Conflicts', () => {
    it('should handle partial conflicts probabilistically', () => {
      const class1 = createTestClass({
        id: 1,
        partialConflicts: [
          { date: new Date('2024-01-01'), period: 1, type: 'partial' }
        ]
      })
      
      // Run multiple times to test probabilistic behavior
      const trials = 100
      let conflictCount = 0
      
      for (let i = 0; i < trials; i++) {
        const schedule = createScheduleWithClass(class1)
        const result = scheduleEngine.generateSchedule(schedule)
        
        if (result.classes.some(cls =>
          cls.date.getTime() === class1.partialConflicts[0].date.getTime() &&
          cls.period === class1.partialConflicts[0].period
        )) {
          conflictCount++
        }
      }
      
      // Expect roughly 30% scheduling during partial conflicts
      expect(conflictCount / trials).toBeCloseTo(0.3, 1)
    })
  })

  describe('Complex Scenarios', () => {
    it('should handle mixed total and partial conflicts', () => {
      const class1 = createTestClass({
        id: 1,
        totalConflicts: [
          { date: new Date('2024-01-01'), period: 1, type: 'total' }
        ],
        partialConflicts: [
          { date: new Date('2024-01-01'), period: 2, type: 'partial' }
        ]
      })
      
      const schedule = createScheduleWithClass(class1)
      const result = scheduleEngine.generateSchedule(schedule)
      
      // Verify total conflicts are never scheduled
      expect(result.classes.some(cls =>
        cls.date.getTime() === class1.totalConflicts[0].date.getTime() &&
        cls.period === class1.totalConflicts[0].period
      )).toBeFalsy()
      
      // Verify partial conflicts are handled
      const hasPartialConflict = result.classes.some(cls =>
        cls.date.getTime() === class1.partialConflicts[0].date.getTime() &&
        cls.period === class1.partialConflicts[0].period
      )
      
      // Should be either scheduled or not, but schedule should be valid
      expect(result.isValid()).toBeTruthy()
    })
  })
})
```

### 3. Performance Tests
Located in `__tests__/performance`

#### Benchmarks
- Schedule generation time
- Memory usage
- Worker efficiency
- Constraint validation speed

#### Performance Metrics
```typescript
// __tests__/performance/metrics.ts
interface PerformanceMetrics {
  generationTime: number
  peakMemory: number
  constraintChecks: number
  mutationCount: number
  successRate: number
}

class PerformanceMonitor {
  private metrics: PerformanceMetrics = {
    generationTime: 0,
    peakMemory: 0,
    constraintChecks: 0,
    mutationCount: 0,
    successRate: 0
  }

  startMonitoring(): void {
    this.resetMetrics()
    this.startTime = performance.now()
    this.memoryUsage = process.memoryUsage()
  }

  stopMonitoring(): PerformanceMetrics {
    this.metrics.generationTime = performance.now() - this.startTime
    this.metrics.peakMemory = Math.max(
      ...Object.values(process.memoryUsage())
    )
    return this.metrics
  }
}
```

## Test Data Management

### 1. Test Data Generation
```typescript
// __tests__/utils/dataGenerator.ts
class TestDataGenerator {
  generateClasses(count: number): Class[] {
    return Array.from({ length: count }, (_, i) => ({
      id: i + 1,
      name: `Class ${i + 1}`,
      teacher: this.generateTeacher(),
      grade: this.generateGrade(),
      requirements: this.generateRequirements()
    }))
  }

  generateSchedule(classCount: number): Schedule {
    const classes = this.generateClasses(classCount)
    const periods = this.generatePeriods()
    return new Schedule(classes, periods)
  }
}
```

### 2. Test Fixtures
```typescript
// __tests__/fixtures/index.ts
export const fixtures = {
  smallSchedule: {
    classes: [/* 10 classes */],
    periods: [/* 30 periods */],
    constraints: [/* basic constraints */]
  },
  mediumSchedule: {
    classes: [/* 50 classes */],
    periods: [/* 30 periods */],
    constraints: [/* all constraints */]
  },
  largeSchedule: {
    classes: [/* 100 classes */],
    periods: [/* 30 periods */],
    constraints: [/* all constraints */]
  }
}
```

## Testing Strategies

### 1. Constraint Testing
```typescript
describe('Constraint Testing', () => {
  it('should handle teacher conflicts', () => {
    const schedule = createScheduleWithConflict('teacher')
    const validator = new ConstraintValidator()
    expect(validator.validate(schedule)).toBe(false)
    expect(validator.getViolations(schedule))
      .toContain('TeacherConflict')
  })

  it('should handle room conflicts', () => {
    const schedule = createScheduleWithConflict('room')
    const validator = new ConstraintValidator()
    expect(validator.validate(schedule)).toBe(false)
    expect(validator.getViolations(schedule))
      .toContain('RoomConflict')
  })
})
```

### 2. Mutation Testing
```typescript
describe('Mutation Testing', () => {
  it('should maintain valid state after mutations', () => {
    const schedule = createValidSchedule()
    const mutator = new ScheduleMutator()
    
    for (let i = 0; i < 100; i++) {
      const newSchedule = mutator.mutate(schedule)
      expect(validateSchedule(newSchedule)).toBe(true)
    }
  })
})
```

### 3. Grade Group Testing
```typescript
describe('Grade Group Testing', () => {
  it('should optimize grade group cohesion', () => {
    const schedule = createScheduleWithGrades()
    const optimizer = new GradeOptimizer()
    const optimized = optimizer.optimize(schedule)
    
    expect(calculateGradeCohesion(optimized))
      .toBeGreaterThan(calculateGradeCohesion(schedule))
  })
})
```

## Test Automation

### 1. CI/CD Integration
```yaml
# .github/workflows/test.yml
name: Test Suite
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install dependencies
        run: npm install
      - name: Run unit tests
        run: npm run test:unit
      - name: Run integration tests
        run: npm run test:integration
      - name: Run performance tests
        run: npm run test:performance
```

### 2. Test Reports
```typescript
// __tests__/utils/reporter.ts
class TestReporter {
  generateReport(results: TestResults): TestReport {
    return {
      summary: this.generateSummary(results),
      details: this.generateDetails(results),
      performance: this.generatePerformanceReport(results)
    }
  }

  private generatePerformanceReport(results: TestResults): PerformanceReport {
    return {
      averageGenerationTime: this.calculateAverage(
        results.map(r => r.metrics.generationTime)
      ),
      peakMemoryUsage: Math.max(
        ...results.map(r => r.metrics.peakMemory)
      ),
      successRate: this.calculateSuccessRate(results)
    }
  }
}
```

## Debugging Guide

### 1. Common Issues
```typescript
// __tests__/utils/debugger.ts
class ScheduleDebugger {
  analyzeFailure(schedule: Schedule): DebugReport {
    return {
      constraintViolations: this.findConstraintViolations(schedule),
      gradeGroupIssues: this.findGradeGroupIssues(schedule),
      resourceConflicts: this.findResourceConflicts(schedule)
    }
  }

  private findConstraintViolations(schedule: Schedule): Violation[] {
    return this.constraints
      .filter(c => !c.validate(schedule))
      .map(c => ({
        constraint: c.name,
        details: c.getViolationDetails(schedule)
      }))
  }
}
```

### 2. Debugging Tools
```typescript
// __tests__/utils/tools.ts
export const debugTools = {
  visualizeSchedule: (schedule: Schedule): string => {
    // Generate ASCII visualization of schedule
    return generateScheduleGrid(schedule)
  },

  analyzePerformance: (metrics: PerformanceMetrics): string => {
    // Generate performance analysis report
    return generatePerformanceReport(metrics)
  },

  traceConstraints: (schedule: Schedule): string => {
    // Generate constraint validation trace
    return generateConstraintTrace(schedule)
  }
}
```

## Performance Testing

### 1. Load Tests
```typescript
describe('Load Testing', () => {
  const loads = [10, 50, 100, 200, 500]
  
  loads.forEach(classCount => {
    it(`should handle ${classCount} classes`, async () => {
      const schedule = await generateSchedule(classCount)
      expect(schedule.classes.size).toBe(classCount)
      expect(validateSchedule(schedule)).toBe(true)
    })
  })
})
```

### 2. Stress Tests
```typescript
describe('Stress Testing', () => {
  it('should handle continuous mutations', () => {
    const schedule = createLargeSchedule()
    const mutator = new ScheduleMutator()
    
    // Perform 1000 mutations
    for (let i = 0; i < 1000; i++) {
      const newSchedule = mutator.mutate(schedule)
      expect(validateSchedule(newSchedule)).toBe(true)
    }
  })
})
```

### 3. Memory Tests
```typescript
describe('Memory Testing', () => {
  it('should maintain stable memory usage', () => {
    const initialMemory = process.memoryUsage()
    const schedule = createLargeSchedule()
    
    // Generate 100 schedules
    for (let i = 0; i < 100; i++) {
      generateSchedule()
    }
    
    const finalMemory = process.memoryUsage()
    expect(finalMemory.heapUsed - initialMemory.heapUsed)
      .toBeLessThan(MAX_MEMORY_GROWTH)
  })
})
```

================
File: memlog/algorithm_performance.md
================
# Algorithm Performance Log

## Performance Metrics
- Average rotation length
- Constraint satisfaction rates
- Solution generation time
- Backtracking frequency
- Grade group cohesion scores
- Class scheduling completeness rate

## Optimization History
*Track algorithm improvements and their impact*

### 2024-01-24: New Backtracking Implementation
#### Algorithm Components
- Multiple candidate solution tracking (max 3 solutions)
- Scoring system with weighted components:
  * Total length: -2x weight (minimize)
  * Grade group cohesion: 50x weight (primary)
  * Distribution quality: 30x weight
  * Grade progression: 10x weight (when enabled)
  * Constraint violations: -100x weight

#### Performance Characteristics
1. Time Complexity
   - O(n * p * d) per iteration where:
     * n = number of classes
     * p = periods per day (8)
     * d = maximum days to consider (42)
   - Limited to 1000 iterations maximum

2. Space Complexity
   - O(n * s) where:
     * n = number of classes
     * s = number of solutions maintained (3)

3. Optimization Strategies
   - Period prioritization based on grade group cohesion
   - Early pruning of unpromising solutions (score < 90% of best)
   - Smart backtracking with variation generation
   - Efficient grade progression scoring:
     * Only computed when enabled
     * Limited to inter-group transitions
     * Uses sorted date comparison

4. Constraint Optimizations
   - Configurable consecutive period limits (1-2)
   - Configurable break requirements (1-2 periods)
   - Runtime validation of constraints
   - Early filtering of invalid period combinations

#### Performance Impact of Recent Changes
1. Consecutive Period Constraints
   - Improved period filtering reduces search space
   - Validation in constructor prevents invalid configurations
   - O(1) constraint checking per period

2. Grade Progression Scoring
   - O(n log n) for initial sort by date
   - O(n) for progression checking
   - Only computed when preference enabled
   - Caches grade group lookups

3. Areas for Monitoring
1. Solution Quality Metrics
   - Total schedule length
   - Grade group cohesion percentage
   - Distribution evenness
   - Constraint violation count

2. Performance Bottlenecks
   - Score calculation frequency
   - Backtracking frequency
   - Constraint checking overhead

3. Memory Usage
   - Candidate solution pool size
   - Date object creation frequency
   - Array operations in scoring

#### Future Optimizations
1. Potential Improvements
   - Parallel solution exploration
   - Smarter initial class ordering
   - Adaptive scoring weights
   - Memory pooling for date objects

2. Investigation Needed
   - Impact of grade group size on performance
   - Optimal number of candidate solutions
   - Score threshold tuning
   - Maximum iteration limit tuning

### 2024-01-24
- Enhanced tryScheduleClass to explore all periods
- Added scoring-guided placement
- Increased MAX_ITERATIONS to 10000
- Increased MAX_SOLUTIONS to 100
- Results:
  - Scheduling completeness: 28/50 classes (56%)
  - Test execution time: ~350s for full suite
  - Solution quality score: 2.0 (baseline)

### 2024-01-25: Small Dataset Testing Success
#### Test Configuration
- Dataset: 4 classes
- Initial state: 2 scheduled, 2 unscheduled
- Simulated Annealing Parameters:
  * Initial temperature: 100
  * Cooling rate: 0.95
  * Minimum temperature: 0.1
  * Iterations per temp: 100
  * Max restarts: 3

#### Performance Results
1. Scheduling Success
   - Initial state: 2/4 classes (50%)
   - Final state: 4/4 classes (100%)
   - Score improvement: 0.63 → 1.0
   - No restarts needed

2. Algorithm Behavior
   - First improvement at temp=100: 3/4 classes (score: 0.78)
   - Second improvement at temp=100: 4/4 classes (score: 0.97)
   - Final optimization at temp=95: perfect score (1.0)
   - Total iterations needed: ~200

3. Test Coverage
   - simulatedAnnealing.ts: 91.02% coverage
   - Remaining gaps:
     * Error handling paths
     * Edge case scenarios
     * Restart mechanism

#### Analysis
1. Positives
   - Successfully schedules all classes
   - Achieves perfect score
   - Quick convergence
   - No restarts needed

2. Limitations
   - Small dataset may not represent real-world complexity
   - Need to test with larger datasets (50+ classes)
   - Performance with constraints needs more testing

3. Next Steps
   - Test with medium dataset (20-30 classes)
   - Test with full dataset (50+ classes)
   - Add performance profiling
   - Test grade progression scenarios

### 2024-01-22: Latest Performance Update

#### Algorithm Changes
1. Added Restart Mechanism
   - Detects when algorithm is stuck (no improvements)
   - Restarts with 50% of initial temperature
   - Keeps best schedule but tries new starting point
   - Maximum 5 restarts before termination

2. Improved Temperature Parameters
   - Initial temperature: 2000 (was 1000)
   - Cooling rate: 0.995 (was 0.98)
   - Minimum temperature: 0.1 (was 0.01)
   - Iterations per temperature: 300 (was 200)

3. Enhanced Mutation Strategies
   - 60% chance to add unscheduled classes
   - 20% chance to swap two classes
   - 20% chance to remove and reschedule class
   - Prioritizes adding unscheduled classes

4. Better Scoring System
   - Normalized scores to 0-1 range
   - Completeness weight: 2000 (was 1000)
   - Grade cohesion weight: 500
   - Distribution weight: 300

#### Expected Impact
1. Scheduling Completeness
   - Higher initial temperature allows more exploration
   - Slower cooling helps find better solutions
   - Restart mechanism prevents getting stuck
   - Expected improvement: 56% → 80-90%

2. Solution Quality
   - Better balance of exploration vs exploitation
   - More emphasis on completeness
   - Maintains grade cohesion importance
   - Expected improvement: 20-30%

3. Performance
   - Slightly longer runtime due to:
     * More iterations per temperature
     * Slower cooling rate
     * Potential restarts
   - Expected increase: 350s → 400-450s

#### Next Steps
1. Monitor scheduling completeness
2. Fine-tune weights if needed
3. Consider adaptive cooling rate
4. Profile performance impact

## Latest Performance Metrics (2024-11-23)

### Schedule Optimization Scores
1. Small Schedules (3-15 classes)
   - Optimization Rate: 92-98%
   - Average Time: < 5 seconds
   - Memory Usage: ~100MB

2. Medium Schedules (20-22 classes)
   - Optimization Rate: 85-97%
   - Average Time: < 15 seconds
   - Memory Usage: ~150MB

3. Large Schedules (30+ classes)
   - Optimization Rate: 73-74%
   - Average Time: < 30 seconds
   - Memory Usage: ~200MB

### Optimization Weights
- Completeness: 40%
- Cohesion: 30%
- Distribution: 30%

### Performance Improvements
1. Constraint Validation
   - Implemented incremental validation
   - Added validation caching
   - Reduced complexity from O(n²) to O(n)

2. Memory Management
   - Implemented schedule object pooling
   - Optimized cloning strategies
   - Reduced peak memory usage

3. Parallel Processing
   - Added SharedArrayBuffer communication
   - Implemented work stealing
   - Improved worker coordination

### Target Metrics
1. Large Schedule Performance
   - Target Optimization Rate: > 85%
   - Target Processing Time: < 20 seconds
   - Target Memory Usage: < 100MB

2. General Improvements
   - Reduce constraint validation overhead
   - Optimize memory usage in worker communication
   - Improve cache hit rates

## Known Bottlenecks
*Document performance bottlenecks and potential solutions*

### Current Bottlenecks
1. Incomplete class scheduling
   - Only 56% of classes scheduled
   - Possible causes:
     - Scoring threshold too strict (-1000)
     - Not enough exploration of solution space
     - Getting stuck in local optima

2. Solution Quality
   - Multi-worker solutions not improving over single worker
   - Possible causes:
     - Mock workers not truly parallel
     - Parameter distribution not optimal
     - Need better coordination between workers

3. Performance
   - Test suite taking ~350s to run
   - Large number of iterations needed
   - Possible improvements:
     - True parallel processing
     - More efficient scoring
     - Better initial solutions

## Test Scenarios
*Document test cases and their results*

### Basic Scheduling
- Small dataset (10 classes)
  - All classes scheduled
  - Constraints satisfied
  - Good performance

### Large Scale Testing
- Medium dataset (50 classes)
  - Only 56% scheduled
  - Constraints satisfied for scheduled classes
  - Performance needs improvement

### Parallel Processing
- Multiple workers
  - Basic functionality works
  - Not improving solution quality
  - Need true parallel implementation

## Comparative Analysis
*Compare different algorithm versions and approaches*

### Base vs Current Version
- Base version:
  - Simple greedy scheduling
  - Fast but poor solutions
  - No optimization

- Current version:
  - Simulated annealing with parallel processing
  - Better solution quality
  - Incomplete scheduling
  - Slower but more thorough

### Algorithm Variations
1. Simple Greedy:
   - Fast
   - Poor quality
   - Complete but with many conflicts

2. Backtracking:
   - Complete solutions
   - Very slow for large datasets
   - Good constraint satisfaction

3. Current (Simulated Annealing + Parallel):
   - Better solution quality
   - Incomplete scheduling
   - Moderate performance
   - Needs improvement

## Next Steps
1. Adjust scoring threshold in tryScheduleClass
2. Implement more aggressive simulated annealing parameters
3. Add restart mechanism for stuck states
4. Test with various initial temperatures
5. Profile scheduling algorithm for bottlenecks

================
File: memlog/changelog.md
================
# ClassRotation Changelog

## [Unreleased]
### Added
- Project initialization
- Basic project structure
- AI guidelines and rules
- Memlog system setup
- Class Scheduler Development Log
- Enhanced simulated annealing test suite:
  - Added test for schedule optimization with unscheduled classes
  - Verified algorithm can successfully add unscheduled classes
  - Confirmed constraint enforcement during optimization
  - Added logging for optimization progress tracking
  - Test shows 100% scheduling success on small dataset (4 classes)
- Adaptive scoring weights system:
  - Dynamic weights based on completion rate
  - Increased focus on completeness when needed
  - Gradual transition to cohesion and distribution
- Schedule "shake" operation for escaping local optima
- Adaptive class scheduling attempts based on restart count

### Changed
- Improved simulated annealing test infrastructure:
  - Better Schedule object mocking
  - More comprehensive test scenarios
  - Enhanced type safety in test data
- Enhanced simulated annealing parameters:
  - Increased initial temperature to 3000
  - More aggressive initial cooling rate (0.99)
  - Increased iterations per temperature to 400
  - Doubled max restarts to 10
- Improved neighbor generation:
  - Adaptive probability for unscheduled classes
  - Up to 90% focus on unscheduled when needed
  - Smart class removal when stuck
- Enhanced class management:
  - More attempts after restarts
  - Improved swap and reschedule logic

### Fixed
- Type issues in simulated annealing tests:
  - Added missing Class interface properties
  - Fixed Schedule interface implementation
  - Corrected ScheduledClass type usage

### Removed

## 2024-11-23
### Added
- Documentation update entry to changelog

## 2024-11-22
### Added
- Enhanced UI components:
  - Improved grade group builder with better UX
  - Fixed settings tab rendering
  - Added proper form validation
  - Enhanced state management
- Updated type system:
  - Stricter typing for constraints
  - Better type definitions for preferences
  - Enhanced error handling types
  - Improved type safety throughout

### Changed
- Refactored preferences handling:
  - Simplified state management
  - Added proper storage integration
  - Improved initialization
- Enhanced form components:
  - Better validation feedback
  - Clearer UI organization
  - Improved error states

### Fixed
- Settings tab rendering issues
- Grade group builder state management
- Preferences initialization
- Type mismatches in components

## 2024-11-21
### Added
- Created new `scheduleEngine.ts` implementing advanced scheduling algorithm
  - Multiple candidate solution tracking
  - Sophisticated scoring system for schedule quality
  - Smart period selection with grade group cohesion
  - Backtracking capability
  - Comprehensive constraint handling

### Changed
- Enhanced consecutive period constraints:
  - Configurable maximum (1 or 2 periods)
  - Configurable break length (1 or 2 periods)
  - Runtime validation of settings
- Added flexible grade progression preferences:
  - Optional high-to-low or low-to-high progression
  - Can be disabled when not needed
  - Preserves grade group cohesion as primary factor
- Updated scoring system weights:
  - Grade group cohesion: 50x (primary)
  - Distribution quality: 30x
  - Grade progression: 10x (when enabled)
  - Total length: -2x
  - Constraint violations: -100x
- Replaced simple forward-filling approach with sophisticated backtracking algorithm
- Enhanced grade group handling with prioritization options
- Improved conflict handling to support both total and partial conflicts
- Updated `schedule.ts` to use new ScheduleEngine
  - Added wrapper function for backward compatibility
  - Enhanced logging for schedule generation analysis
  - Exposed additional utility functions

### Technical Details
- Added `ScheduleEngine` class with:
  - Score calculation for schedule quality metrics
  - Grade group cohesion optimization
  - Distribution quality measurements
  - Constraint violation tracking
  - Multiple solution path exploration
- Improved constraint validation in constructor
- Added type safety for consecutive period settings
- Enhanced scoring system with configurable progression
- Improved logging and debugging capabilities in schedule generation wrapper

## 2024-11-20
### Added
- Test infrastructure:
  - Jest configuration with TypeScript support
  - Test utility builders for test data generation
  - Comprehensive assertion utilities
  - Test data helpers for common scenarios
- Test coverage:
  - Basic constraint validation tests
  - Builder utility tests
  - Test helper validation
- Test scripts in package.json:
  - `npm test`
  - `npm test:watch`
  - `npm test:coverage`

### Changed
- Enhanced development workflow with test-driven approach
- Improved code organization with builder pattern
- Updated project structure for testing

### Fixed
- TypeScript configuration for Jest
- Test utility imports
- Test file organization

## 2024-01-22
### Added
- Created `docs/directory_index.md` to track all documentation files and their update requirements
- Added comprehensive documentation update guidelines and dependency chains
- Added file maintenance rules and quick reference guides

### Changed
- Updated project documentation structure to follow new directory index guidelines
- Improved documentation organization and tracking system
- Enhanced simulated annealing implementation:
  - Added restart mechanism for stuck states
  - Improved temperature parameters:
    * Increased initial temperature (2000)
    * Slower cooling rate (0.995)
    * Higher minimum temperature (0.1)
  - Enhanced mutation strategies:
    * Higher probability for adding unscheduled classes
    * Improved class swapping logic
  - Better scoring weights:
    * Normalized scores to 0-1 range
    * Increased completeness weight (2000)
    * Added cohesion (500) and distribution (300) weights

## 2024-01-10: Refined Scoring System and Added Test Coverage

### Changes Made
1. Added `scoreExistingSchedule()` method to `ScheduleEngine`
   - Enables scoring of predefined schedules
   - Separates scoring logic from schedule generation
   - Improves testability of scoring mechanism

2. Enhanced Scoring System Implementation
   - Grade Group Cohesion (Weight: 50)
     * Perfect (1.0): One grade group per day
     * Mixed (0.5): Two grade groups per day
     * Further penalties for more mixing
   - Distribution Quality (Weight: 30)
     * Perfect (1.0): Even distribution across days
     * Scores based on deviation from average
   - Grade Progression (Weight: 10)
     * Supports high-to-low or low-to-high preferences
     * Optional (weight = 0 if preference is 'none')
   - Total Length (Weight: -2)
     * Prefers shorter schedules
     * Minor tiebreaker in scoring
   - Constraint Violations (Weight: -100)
     * Heavily penalizes rule violations
     * Includes period limits and break requirements

3. Conflict Handling Integration
   - Total Conflicts: 100% blocking
   - Partial Conflicts: 70% chance of blocking
   - Conflicts checked before scoring criteria

4. Updated Test Suite
   - All tests now use `scoreExistingSchedule()`
   - Comprehensive coverage of scoring scenarios
   - Improved test data setup with explicit dates/periods

### Technical Details
- Scoring weights chosen to prioritize:
  1. Constraint compliance (most important)
  2. Grade group cohesion
  3. Even distribution
  4. Grade progression (optional)
  5. Schedule length (tiebreaker)

### Files Changed
- `src/utils/scheduleEngine.ts`
- `src/__tests__/scoring.test.ts`
- `src/__tests__/utils/builders.ts`

### Next Steps
- Consider performance optimization for large schedules
- Add more edge case tests
- Explore machine learning possibilities for weight optimization

## Class Scheduler Development Log

### Current Status (As of Last Session)
- Working on improving parallel scheduling algorithm
- Base implementation in place but not scheduling all classes
- Tests showing 28/50 classes scheduled

### Latest Changes (Current Session)

### Algorithm Improvements
1. Modified ScheduleEngine
   - Made `classes` field protected for derived class access
   - Increased MAX_ITERATIONS to 10000 and MAX_SOLUTIONS to 100
   - Enhanced `tryScheduleClass` to:
     - Try all available periods for each day
     - Use scoring to guide placement decisions
     - Skip weekends automatically

2. Enhanced SimulatedAnnealingScheduler
   - Improved neighbor generation to prioritize unscheduled classes
   - Added completeness weighting to solution scoring
   - Modified mutation strategies for better exploration

### Current Challenges
1. Still not scheduling all classes (22/50 unscheduled)
2. Solution quality not improving with more workers
3. Performance within limits but could be improved

### Next Steps
1. Test the latest changes to verify improvement
2. If still not scheduling all classes:
   - Review scoring thresholds in tryScheduleClass
   - Consider more aggressive mutation strategies
   - Look into backtracking when stuck

### Technical Details
- Location: Working in:
  - `/src/utils/scheduleEngine.ts`
  - `/src/utils/simulatedAnnealing.ts`
  - `/src/utils/parallelScheduler.ts`
- Last Changes:
  1. Made scheduling engine more thorough in trying periods
  2. Added scoring-guided placement
  3. Enhanced simulated annealing to focus on completing schedule

### Current Test Status
```
ParallelScheduler
  ✓ should generate valid schedule with parallel processing
  ✕ should handle large number of classes efficiently
  ✓ should maintain schedule quality with parallel processing
  ✓ should handle conflicts in parallel
  ✓ should handle worker failures gracefully
  ✕ should improve solution quality with more workers
```

### NEXT SESSION START HERE
- Run tests with latest changes to verify improvements
- If still not scheduling all classes:
  1. Review and adjust scoring threshold in tryScheduleClass (currently -1000)
  2. Consider more aggressive temperature and cooling parameters
  3. Look into adding restart mechanism when stuck
  4. May need to implement true worker threads for better parallelization

### Environment Context
- Node.js/TypeScript
- Jest for testing
- Current focus on scheduling algorithm quality
- Performance is secondary to completeness

### Open Questions
1. Is the scoring threshold (-1000) appropriate?
2. Should we implement true worker threads now?
3. Do we need more sophisticated backtracking?

### Code Health
- Test coverage: ~90%
- Main areas needing improvement:
  - scheduleEngine.ts: 87.01%
  - simulatedAnnealing.ts: 96.29%
  - parallelScheduler.ts: 100%

## Documentation Updates (2024-11-23)

### Major Documentation Revisions
1. Updated system_overview.md:
   - Added current performance metrics for different schedule sizes
   - Updated optimization weights (40/30/30 split)
   - Enhanced parallel processing documentation
   - Added detailed Worker System Architecture section

2. Updated technical_implementation.md:
   - Updated schedule interface with current methods
   - Added weighted score calculation details
   - Restored detailed constraint system implementation
   - Added grade group system and progression validation

3. Updated performance_guide.md:
   - Updated current and target performance metrics
   - Added optimization strategies
   - Restored constraint validation examples
   - Enhanced profiling tools documentation

### Key Changes
- Preserved historical implementation context
- Added comprehensive parallel processing details
- Updated performance characteristics
- Enhanced documentation organization

### Performance Metrics
- Small schedules (3-15 classes): 92-98% optimization
- Medium schedules (20-22 classes): 85-97% optimization
- Large schedules (30+ classes): 73-74% optimization

### Next Steps
- Begin UI component development
- Implement data persistence layer
- Create schedule visualization
- Enhance worker thread implementation

================
File: memlog/constraint_tracking.md
================
# Constraint Tracking

## Active Constraints
### Hard Constraints
- Blackout periods
- Class conflicts
- Valid period range (1-8 per day)
- Consecutive period limits
  * Maximum consecutive periods (1 or 2)
  * Required break length (1 or 2 periods)

### Soft Constraints
- Maximum periods per day (must be ≤ 8)
- Maximum periods per week
- Grade group cohesion (primary)
- Optional grade progression
  * High-to-low or low-to-high
  * Can be disabled
- Distribution quality

## Constraint Impact Analysis
*Track how different constraints affect schedule quality*

## Constraint Violations
*Document and analyze constraint violations*

## Period Distribution
- Total periods per day: 8
- Valid period numbers: 1-8
- Typical scheduling window: Monday-Friday

## User Override Patterns
*Track when and why users override constraints*

## Future Constraints
*Document potential future constraints to consider*

## Current Constraints Implementation

### 2024-01-24: Enhanced Constraint System
#### Hard Constraints
1. Period Availability
   - 8 periods per day
   - Monday through Friday only
   - Blackout period checking
   - No double-booking periods

2. Consecutive Period Rules
   - Configurable maximum (1 or 2 periods)
   - Configurable break length (1 or 2 periods)
   - Runtime validation of settings
   - Tracked through checkConsecutivePeriods()
   - Strictly enforced during scheduling

3. Class Conflicts
   - Total conflicts (100% blocked)
   - Partial conflicts (70% chance of blocking)
   - Day and period specific

#### Soft Constraints
1. Grade Group Cohesion
   - Primary scheduling factor
   - 50x weight in scoring
   - Tracked per day
   - Affects period selection priority

2. Grade Progression (Optional)
   - Configurable direction preference
   - 10x weight when enabled
   - Only affects inter-group transitions
   - Preserves group cohesion priority

3. Distribution Quality
   - 30x weight in scoring
   - Variance-based calculation
   - Balanced across days and weeks

#### Constraint Weights in Scoring
- Constraint violations: -100 points
- Grade group cohesion: +50 points
- Distribution quality: +30 points
- Schedule length: -2 points per day

#### Constraint Validation
1. Runtime Checks
   - Constructor validation of consecutive period settings
   - Type safety through TypeScript
   - Early constraint violation detection

2. Performance Optimization
   - Early filtering of invalid periods
   - Cached constraint checks
   - Efficient violation tracking

#### Implementation Details
1. Constraint Checking
```typescript
if (
  periodsToday >= constraints.maxPeriodsPerDay ||
  periodsThisWeek >= constraints.maxPeriodsPerWeek ||
  isBlackoutPeriod(period, date) ||
  hasConflict(period, date, classToSchedule, scheduledClasses) ||
  checkConsecutivePeriods(period, date, scheduledClasses)
) {
  continue
}
```

2. Grade Group Priority
```typescript
if (dayHasMatchingGroup) {
  periods.unshift(period) // Higher priority
} else if (!dayHasDifferentGroup) {
  periods.push(period) // Lower priority
} else if (!preferences.preferSameGradeInDay) {
  periods.push(period) // If preference disabled
}
```

#### Monitoring Needs
1. Constraint Satisfaction
   - Track violation frequencies
   - Identify common override patterns
   - Monitor impact on schedule quality

2. Grade Group Impact
   - Success rate of group cohesion
   - Impact on schedule length
   - Trade-offs with other constraints

3. Performance Impact
   - Constraint checking overhead
   - Grade group calculation costs
   - Score calculation frequency

================
File: memlog/stability_checklist.md
================
# ClassRotation Stability Checklist

## Core Algorithm
- [ ] Basic scheduling with hard constraints
- [ ] Backtracking implementation
- [ ] Multiple solution tracking
- [ ] Progress reporting
- [ ] Stuck detection
- [ ] Performance optimization

## Grade Groups
- [ ] Data structure implementation
- [ ] Scheduling preferences
- [ ] Group cohesion scoring

## UI Components
- [ ] Schedule display
- [ ] Manual scheduling interface
- [ ] Unscheduled pool
- [ ] Grade group management

## Known Issues
*Document any known issues, bugs, or stability concerns here*

## Performance Metrics
*Track algorithm performance and optimization results here*

## Test Coverage
*Document test coverage and results here*

## Stability Checklist

### 2024-01-24: ScheduleEngine Implementation
- [x] Basic backtracking algorithm
- [x] Multiple solution tracking
- [x] Score calculation system
- [x] Grade group handling
- [x] Constraint enforcement
- [ ] Performance optimization
- [ ] Memory optimization
- [ ] Comprehensive testing

#### Stability Concerns
1. Score Calculation
   - Need to monitor weight balance
   - Potential for score thrashing
   - Impact on convergence speed

2. Memory Usage
   - Date object creation frequency
   - Candidate solution copies
   - Array operations in scoring

3. Performance
   - Score calculation overhead
   - Constraint checking frequency
   - Backtracking efficiency

#### Required Testing
1. Functional Tests
   - Constraint enforcement
   - Grade group cohesion
   - Backtracking effectiveness

2. Performance Tests
   - Large class sets (>100)
   - Complex grade groupings
   - Heavy constraint scenarios

3. Memory Tests
   - Long-running scenarios
   - Multiple concurrent schedules
   - Object creation patterns

#### Monitoring Needs
1. Algorithm Behavior
   - Convergence patterns
   - Backtracking frequency
   - Solution quality metrics

2. Resource Usage
   - Memory consumption
   - CPU utilization
   - Object creation rates

3. Error Conditions
   - Constraint violations
   - Infinite loops
   - Memory leaks

================
File: memlog/tasks.md
================
# ClassRotation Tasks Log

## Active Tasks
- [ ] Fix incomplete class scheduling (currently 22/50 unscheduled)
  - [x] Test latest algorithm improvements on small dataset
  - [ ] Test with medium dataset (20-30 classes)
  - [ ] Test with full dataset (50+ classes)
  - [ ] Adjust scoring threshold in tryScheduleClass
  - [ ] Review temperature and cooling parameters
  - [ ] Implement restart mechanism for stuck states
- [ ] Implement true parallel processing with Worker Threads
  - [ ] Add worker coordination mechanism
  - [ ] Optimize worker parameter distribution
- [ ] Create unit tests for scoring system
- [ ] Test solution generation algorithm
- [ ] Test constraint enforcement in scheduling
- [ ] Monitor and tune scoring weights based on real usage
- [ ] Test different grade progression preferences
- [ ] Validate consecutive period constraints in real scenarios
- [ ] Implement schedule visualization for debugging
- [ ] Profile algorithm performance with large datasets

## Documentation Tasks

### Completed
- [x] Review and update all documentation according to new directory_index.md guidelines
- [x] Ensure all existing documentation follows dependency chains
- [x] Clean up any outdated documentation sections
- [x] Update system_overview.md with current performance metrics
- [x] Update technical_implementation.md with current code patterns
- [x] Update performance_guide.md with optimization strategies
- [x] Document parallel processing architecture
- [x] Add detailed constraint system documentation
- [x] Document grade group system implementation
- [x] Update changelog with documentation changes

### In Progress
- [ ] Create API documentation for new components
- [ ] Document UI component specifications
- [ ] Create user guide for manual schedule adjustments

### Planned
- [ ] Document data persistence layer design
- [ ] Create schedule visualization documentation
- [ ] Document worker thread implementation details
- [ ] Create deployment guide

## Implementation Tasks

### In Progress
- [ ] UI component development
- [ ] Data persistence layer
- [ ] Schedule visualization
- [ ] Worker thread implementation

### Planned
- [ ] Manual schedule adjustment tools
- [ ] Schedule template system
- [ ] Export/import functionality
- [ ] Collaborative editing support

## Completed Tasks
- [x] Set up Jest test infrastructure
- [x] Create test utility builders (Class, GradeGroup, Constraints, Preferences)
- [x] Implement test assertions and helpers
- [x] Add basic constraint validation tests
- [x] Configure test coverage reporting
- [x] Create ScheduleEngine class with backtracking algorithm
- [x] Implement sophisticated scoring system
- [x] Add support for partial conflicts
- [x] Enhance grade group handling
- [x] Implement multiple solution tracking
- [x] Add configurable consecutive period constraints
- [x] Implement optional grade progression preferences
- [x] Add runtime validation for constraints
- [x] Fix settings tab rendering issues
- [x] Improve grade group builder UI
- [x] Add proper form validation
- [x] Enhance state management for preferences
- [x] Update type definitions for stricter typing
- [x] Basic parallel scheduler with mock workers
- [x] Initial scheduling functionality (partial success)
- [x] Implement basic simulated annealing test
  - [x] Test schedule optimization
  - [x] Verify unscheduled class handling
  - [x] Test constraint enforcement
  - [x] Add optimization progress logging
  - [x] Achieve 100% scheduling on small dataset

## Blocked Tasks
- [ ] Parallel solution exploration (needs performance baseline)
- [ ] Memory optimization (needs profiling data)
- [ ] Advanced visualization (depends on basic visualization)
- [ ] Grade progression weight tuning (needs real usage data)
- [ ] Machine learning integration (needs more usage data)

## Future Tasks
- [ ] Implement adaptive scoring weights
- [ ] Add machine learning for initial class ordering
- [ ] Create performance monitoring dashboard
- [ ] Optimize memory usage with object pooling
- [ ] Add support for dynamic constraint adjustment
- [ ] Consider more complex grade progression patterns
- [ ] Add configuration UI for advanced settings
- [ ] Implement undo/redo for schedule changes
- [ ] Add export/import functionality
- [ ] Create schedule templates system

## Notes
- Test utilities now provide foundation for comprehensive testing
- Builder pattern simplifies test data creation
- Need to focus on core algorithm testing next
- Grade progression is implemented as a soft preference
- Consecutive period constraints are working well but need real-world validation
- Need to gather data on typical grade progression patterns
- Consider making scoring weights configurable through UI
- UI improvements have significantly enhanced usability
- Type system improvements have reduced runtime errors
- Latest changes focus on improving scheduling completeness
- Current priority is fixing incomplete class scheduling issue
- Parallel processing improvements will follow once base scheduling works

================
File: memlog/url_debug_checklist.md
================
# ClassRotation URL Debug Checklist

## Development Environment
- [ ] Local development server (http://localhost:5173)
- [ ] Hot module replacement working
- [ ] Source maps functioning

## Routes
*Document and track the status of all application routes here*

## Component Loading
*Track any issues with component loading or rendering*

## State Management
*Document state management issues and debugging steps*

## Build/Deploy Issues
*Track any build or deployment-related issues*

================
File: public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: src/__tests__/utils/assertions.ts
================
import { Schedule, Class, GradeGroup } from '../../types';

/**
 * Schedule Assertions
 */
export const scheduleAssertions = {
  /**
   * Assert that classes in the same grade group are scheduled close together
   */
  hasGradeGroupCohesion: (schedule: Schedule, gradeGroups: GradeGroup[]): void => {
    // Implementation will depend on how we measure cohesion
    // This is a placeholder for the actual implementation
    expect(schedule).toBeDefined();
    expect(gradeGroups.length).toBeGreaterThan(0);
  },

  /**
   * Assert that the schedule respects maximum periods per day
   */
  respectsMaxPeriodsPerDay: (schedule: Schedule): void => {
    const maxPerDay = schedule.constraints.maxPeriodsPerDay;
    // TODO: Implement check for each day's period count
    expect(maxPerDay).toBeGreaterThan(0);
  },

  /**
   * Assert that the schedule respects maximum periods per week
   */
  respectsMaxPeriodsPerWeek: (schedule: Schedule): void => {
    const maxPerWeek = schedule.constraints.maxPeriodsPerWeek;
    // TODO: Implement check for weekly period count
    expect(maxPerWeek).toBeGreaterThan(0);
  },

  /**
   * Assert that consecutive period constraints are respected
   */
  respectsConsecutivePeriods: (schedule: Schedule): void => {
    const { maximum, requireBreak } = schedule.constraints.consecutivePeriods;
    // TODO: Implement check for consecutive periods and breaks
    expect(maximum).toBeDefined();
    expect(requireBreak).toBeDefined();
  }
};

/**
 * Class Assertions
 */
export const classAssertions = {
  /**
   * Assert that a class has valid grade levels
   */
  hasValidGradeLevels: (classObj: Class): void => {
    expect(classObj.gradeLevel).toBeDefined();
    if (classObj.allowedGrades) {
      expect(classObj.allowedGrades).toContain(classObj.gradeLevel);
    }
  },

  /**
   * Assert that class conflicts are valid
   */
  hasValidConflicts: (classObj: Class): void => {
    if (classObj.totalConflicts) {
      classObj.totalConflicts.forEach(conflict => {
        expect(conflict.classId).toBeDefined();
        expect(conflict.dayOfWeek).toBeGreaterThanOrEqual(0);
        expect(conflict.dayOfWeek).toBeLessThanOrEqual(4); // 0-4 for Monday-Friday
        expect(conflict.period).toBeGreaterThanOrEqual(1);
      });
    }

    if (classObj.partialConflicts) {
      classObj.partialConflicts.forEach(conflict => {
        expect(conflict.classId).toBeDefined();
        expect(conflict.dayOfWeek).toBeGreaterThanOrEqual(0);
        expect(conflict.dayOfWeek).toBeLessThanOrEqual(4);
        expect(conflict.period).toBeGreaterThanOrEqual(1);
      });
    }
  }
};

/**
 * Grade Group Assertions
 */
export const gradeGroupAssertions = {
  /**
   * Assert that grade groups are valid
   */
  isValid: (group: GradeGroup): void => {
    expect(group.id).toBeDefined();
    expect(group.name).toBeDefined();
    expect(group.grades).toBeDefined();
    expect(group.grades.length).toBeGreaterThan(0);
  },

  /**
   * Assert that grade groups don't overlap
   */
  noOverlap: (groups: GradeGroup[]): void => {
    const allGrades = new Set<string>();
    groups.forEach(group => {
      group.grades.forEach(grade => {
        expect(allGrades.has(grade)).toBeFalsy();
        allGrades.add(grade);
      });
    });
  }
};

/**
 * Test Data Generation Helpers
 */
export const testDataHelpers = {
  /**
   * Generate a range of dates for testing
   */
  dateRange: (startDate: Date, days: number): Date[] => {
    return Array.from({ length: days }, (_, i) => {
      const date = new Date(startDate);
      date.setDate(date.getDate() + i);
      return date;
    });
  },

  /**
   * Generate a sequence of class numbers
   */
  classNumbers: (count: number, startFrom: number = 1): number[] => {
    return Array.from({ length: count }, (_, i) => startFrom + i);
  },

  /**
   * Generate grade levels
   */
  gradeLevels: (min: number = 9, max: number = 12): string[] => {
    return Array.from({ length: max - min + 1 }, (_, i) => (min + i).toString());
  }
};

================
File: src/__tests__/utils/builders.test.ts
================
import { 
  ClassBuilder, 
  GradeGroupBuilder, 
  ConstraintsBuilder, 
  PreferencesBuilder 
} from './builders';
import { 
  classAssertions, 
  gradeGroupAssertions, 
  testDataHelpers 
} from './assertions';

describe('Test Utilities', () => {
  describe('ClassBuilder', () => {
    it('should create a valid class with default values', () => {
      const testClass = new ClassBuilder().build();
      expect(testClass.id).toBeDefined();
      expect(testClass.name).toBe('Test Class');
      expect(testClass.classNumber).toBe(1);
      classAssertions.hasValidGradeLevels(testClass);
    });

    it('should allow custom values', () => {
      const testClass = new ClassBuilder()
        .withName('Math 101')
        .withClassNumber(101)
        .withTeacher('Mr. Smith')
        .withGradeLevel('10')
        .withMaxStudents(25)
        .withAllowedGrades(['9', '10', '11'])
        .build();

      expect(testClass.name).toBe('Math 101');
      expect(testClass.classNumber).toBe(101);
      expect(testClass.teacher).toBe('Mr. Smith');
      expect(testClass.gradeLevel).toBe('10');
      expect(testClass.maxStudents).toBe(25);
      expect(testClass.allowedGrades).toEqual(['9', '10', '11']);
      classAssertions.hasValidGradeLevels(testClass);
    });

    it('should handle conflicts correctly', () => {
      const testClass = new ClassBuilder()
        .withTotalConflicts([
          { classId: 'class-1', dayOfWeek: 0, period: 1 }
        ])
        .withPartialConflicts([
          { classId: 'class-2', dayOfWeek: 1, period: 2 }
        ])
        .build();

      classAssertions.hasValidConflicts(testClass);
    });
  });

  describe('GradeGroupBuilder', () => {
    it('should create a valid grade group with default values', () => {
      const group = new GradeGroupBuilder().build();
      gradeGroupAssertions.isValid(group);
    });

    it('should allow custom values', () => {
      const group = new GradeGroupBuilder()
        .withName('Junior High')
        .withGrades(['7', '8', '9'])
        .build();

      expect(group.name).toBe('Junior High');
      expect(group.grades).toEqual(['7', '8', '9']);
      gradeGroupAssertions.isValid(group);
    });

    it('should create non-overlapping groups', () => {
      const group1 = new GradeGroupBuilder()
        .withGrades(['9', '10'])
        .build();
      const group2 = new GradeGroupBuilder()
        .withGrades(['11', '12'])
        .build();

      gradeGroupAssertions.noOverlap([group1, group2]);
    });
  });

  describe('ConstraintsBuilder', () => {
    it('should create valid constraints with default values', () => {
      const constraints = new ConstraintsBuilder().build();
      expect(constraints.maxPeriodsPerDay).toBe(6);
      expect(constraints.maxPeriodsPerWeek).toBe(30);
      expect(constraints.consecutivePeriods.maximum).toBe(2);
      expect(constraints.consecutivePeriods.requireBreak).toBe(1);
    });

    it('should allow custom values', () => {
      const constraints = new ConstraintsBuilder()
        .withMaxPeriodsPerDay(5)
        .withMaxPeriodsPerWeek(25)
        .withConsecutivePeriods(1, 2)
        .build();

      expect(constraints.maxPeriodsPerDay).toBe(5);
      expect(constraints.maxPeriodsPerWeek).toBe(25);
      expect(constraints.consecutivePeriods.maximum).toBe(1);
      expect(constraints.consecutivePeriods.requireBreak).toBe(2);
    });
  });

  describe('PreferencesBuilder', () => {
    it('should create valid preferences with default values', () => {
      const preferences = new PreferencesBuilder().build();
      expect(preferences.gradeGroups).toEqual([]);
      expect(preferences.preferSameGradeInDay).toBe(true);
      expect(preferences.gradeProgression).toBe('none');
    });

    it('should allow custom values', () => {
      const group = new GradeGroupBuilder().build();
      const preferences = new PreferencesBuilder()
        .withGradeGroups([group])
        .withPreferSameGradeInDay(false)
        .withGradeProgression('high-to-low')
        .build();

      expect(preferences.gradeGroups).toHaveLength(1);
      expect(preferences.preferSameGradeInDay).toBe(false);
      expect(preferences.gradeProgression).toBe('high-to-low');
    });
  });

  describe('TestDataHelpers', () => {
    it('should generate correct date ranges', () => {
      const startDate = new Date('2024-11-22');
      const dates = testDataHelpers.dateRange(startDate, 5);
      
      expect(dates).toHaveLength(5);
      expect(dates[0]).toEqual(startDate);
      expect(dates[4].getDate()).toBe(startDate.getDate() + 4);
    });

    it('should generate correct class numbers', () => {
      const numbers = testDataHelpers.classNumbers(3, 100);
      expect(numbers).toEqual([100, 101, 102]);
    });

    it('should generate correct grade levels', () => {
      const grades = testDataHelpers.gradeLevels(9, 12);
      expect(grades).toEqual(['9', '10', '11', '12']);
    });
  });
});

================
File: src/__tests__/utils/builders.ts
================
import { 
  GradeGroup, 
  ScheduleConstraints, 
  SchedulePreferences,
  GradeProgressionPreference,
  MaxConsecutivePeriods,
  ConsecutiveBreakLength,
  ScheduledClass,
  Schedule,
  Class
} from '../../types';

/**
 * Class Builder
 */
export class ClassBuilder {
  private class: Partial<ScheduledClass> = {};

  constructor() {
    // Set default values
    this.class = {
      id: `class-${Math.random().toString(36).substr(2, 9)}`,
      name: 'Test Class',
      classNumber: 1,
      teacher: 'Test Teacher',
      gradeLevel: '9',
      maxStudents: 30
    };
  }

  withId(id: string): ClassBuilder {
    this.class.id = id;
    return this;
  }

  withName(name: string): ClassBuilder {
    this.class.name = name;
    return this;
  }

  withClassNumber(num: number): ClassBuilder {
    this.class.classNumber = num;
    return this;
  }

  withTeacher(teacher: string): ClassBuilder {
    this.class.teacher = teacher;
    return this;
  }

  withGradeLevel(grade: string): ClassBuilder {
    this.class.gradeLevel = grade;
    return this;
  }

  withMaxStudents(max: number): ClassBuilder {
    this.class.maxStudents = max;
    return this;
  }

  withAllowedGrades(grades: string[]): ClassBuilder {
    this.class.allowedGrades = grades;
    return this;
  }

  withDate(date: Date): ClassBuilder {
    this.class.date = date;
    return this;
  }

  withPeriod(period: number): ClassBuilder {
    this.class.period = period;
    return this;
  }

  withTotalConflicts(conflicts: Array<{ classId: string; dayOfWeek: number; period: number }>): ClassBuilder {
    this.class.totalConflicts = conflicts;
    return this;
  }

  withPartialConflicts(conflicts: Array<{ classId: string; dayOfWeek: number; period: number }>): ClassBuilder {
    this.class.partialConflicts = conflicts;
    return this;
  }

  build(): ScheduledClass {
    return this.class as ScheduledClass;
  }
}

/**
 * Grade Group Builder
 */
export class GradeGroupBuilder {
  private group: Partial<GradeGroup> = {};

  constructor() {
    this.group = {
      id: `group-${Math.random().toString(36).substr(2, 9)}`,
      name: 'Test Group',
      grades: ['9', '10']
    };
  }

  withId(id: string): GradeGroupBuilder {
    this.group.id = id;
    return this;
  }

  withName(name: string): GradeGroupBuilder {
    this.group.name = name;
    return this;
  }

  withGrades(grades: string[]): GradeGroupBuilder {
    this.group.grades = grades;
    return this;
  }

  build(): GradeGroup {
    return this.group as GradeGroup;
  }
}

/**
 * Schedule Constraints Builder
 */
export class ConstraintsBuilder {
  private constraints: Partial<ScheduleConstraints> = {};

  constructor() {
    this.constraints = {
      maxPeriodsPerDay: 6,
      maxPeriodsPerWeek: 30,
      consecutivePeriods: {
        maximum: 2 as MaxConsecutivePeriods,
        requireBreak: 1 as ConsecutiveBreakLength
      }
    };
  }

  withMaxPeriodsPerDay(max: number): ConstraintsBuilder {
    this.constraints.maxPeriodsPerDay = max;
    return this;
  }

  withMaxPeriodsPerWeek(max: number): ConstraintsBuilder {
    this.constraints.maxPeriodsPerWeek = max;
    return this;
  }

  withConsecutivePeriods(maximum: MaxConsecutivePeriods, requireBreak: ConsecutiveBreakLength): ConstraintsBuilder {
    this.constraints.consecutivePeriods = { maximum, requireBreak };
    return this;
  }

  build(): ScheduleConstraints {
    return this.constraints as ScheduleConstraints;
  }
}

/**
 * Schedule Preferences Builder
 */
export class PreferencesBuilder {
  private preferences: Partial<SchedulePreferences> = {};

  constructor() {
    this.preferences = {
      gradeGroups: [],
      preferSameGradeInDay: true,
      gradeProgression: 'none' as GradeProgressionPreference
    };
  }

  withGradeGroups(groups: GradeGroup[]): PreferencesBuilder {
    this.preferences.gradeGroups = groups;
    return this;
  }

  withPreferSameGradeInDay(prefer: boolean): PreferencesBuilder {
    this.preferences.preferSameGradeInDay = prefer;
    return this;
  }

  withGradeProgression(progression: GradeProgressionPreference): PreferencesBuilder {
    this.preferences.gradeProgression = progression;
    return this;
  }

  build(): SchedulePreferences {
    return this.preferences as SchedulePreferences;
  }
}

/**
 * Schedule Builder
 */
export class ScheduleBuilder {
  private classes: Class[] = [];
  private startDate: Date = new Date();
  private constraints: ScheduleConstraints = {
    maxPeriodsPerDay: 4,
    maxPeriodsPerWeek: 16,
    consecutivePeriods: {
      maximum: 2,
      requireBreak: 1
    }
  };

  withClasses(classes: Class[]): ScheduleBuilder {
    this.classes = classes;
    return this;
  }

  withStartDate(date: Date): ScheduleBuilder {
    this.startDate = date;
    return this;
  }

  withConstraints(constraints?: Partial<ScheduleConstraints>): ScheduleBuilder {
    this.constraints = {
      maxPeriodsPerDay: 4,
      maxPeriodsPerWeek: 16,
      consecutivePeriods: {
        maximum: 2,
        requireBreak: 1
      },
      ...constraints
    }
    return this
  }

  build(): Schedule {
    if (!this.startDate) {
      this.startDate = new Date('2024-01-01')
    }

    // Convert classes to scheduled classes
    const scheduledClasses: ScheduledClass[] = this.classes.map((cls, index) => ({
      ...cls,
      date: new Date(this.startDate!.getTime() + Math.floor(index / 4) * 24 * 60 * 60 * 1000),
      period: (index % 4) + 1
    }))

    const schedule: Schedule = {
      classes: scheduledClasses,
      startDate: this.startDate,
      endDate: new Date(this.startDate.getTime() + 7 * 24 * 60 * 60 * 1000),
      constraints: this.constraints!,
      score: {
        totalLength: 0,
        gradeGroupCohesion: 0,
        distributionQuality: 0,
        constraintViolations: 0,
        gradeProgression: 0
      },

      clone(): Schedule {
        return {
          ...this,
          classes: [...this.classes],
          startDate: new Date(this.startDate),
          endDate: new Date(this.endDate),
          score: { ...this.score }
        }
      },

      getScheduledClassCount(): number {
        return this.classes.length
      },

      getTotalClassCount(): number {
        return this.classes.length
      },

      getUnscheduledClasses(): Class[] {
        const scheduledIds = new Set(this.classes.map(c => c.id))
        return this.classes.filter(c => !scheduledIds.has(c.id))
      },

      addClass(cls: ScheduledClass): void {
        this.classes.push(cls)
        this.endDate = new Date(Math.max(this.endDate.getTime(), cls.date.getTime()))
      },
      removeClass(cls: ScheduledClass): void {
        const index = this.classes.findIndex(c => c.id === cls.id)
        if (index !== -1) {
          this.classes.splice(index, 1)
        }
      }
    }

    return schedule
  }
}

================
File: src/__tests__/conflictHandling.test.ts
================
import { ScheduleEngine } from '../utils/scheduleEngine';
import { Class, GradeGroup, ScheduleConstraints, SchedulePreferences } from '../types';

describe('ScheduleEngine Conflict Handling', () => {
  const defaultConstraints: ScheduleConstraints = {
    maxPeriodsPerDay: 8,
    maxClassesPerDay: 6,
    maxConsecutivePeriods: 3,
    requiredBreakLength: 1
  };

  const defaultPreferences: SchedulePreferences = {
    gradeProgression: 'low-to-high'
  };

  const createTestClass = (id: string, gradeLevel: string, gradeGroup: GradeGroup, conflicts: { date: Date, period: number }[] = []): Class => ({
    id,
    name: `Test Class ${id}`,
    gradeLevel,
    gradeGroup,
    teacher: `Teacher ${id}`,
    totalConflicts: conflicts,
    partialConflicts: []
  });

  describe('generateSchedule - Basic Functionality', () => {
    it('should handle total conflicts correctly', () => {
      const startDate = new Date('2024-01-01');
      const conflictDate = new Date('2024-01-01');
      
      const classes: Class[] = [
        createTestClass('1', '9', 'high', [{ date: conflictDate, period: 1 }]),
        createTestClass('2', '9', 'high')
      ];

      const engine = new ScheduleEngine(classes, startDate, defaultConstraints, defaultPreferences);
      const schedule = engine.generateSchedule();

      // Verify no class is scheduled during its conflict time
      const conflictingSchedule = schedule.classes.find(
        cls => cls.id === '1' && 
        cls.date.getTime() === conflictDate.getTime() && 
        cls.period === 1
      );
      expect(conflictingSchedule).toBeUndefined();
    });

    it('should maintain grade progression preference', () => {
      const startDate = new Date('2024-01-01');
      const classes: Class[] = [
        createTestClass('1', '9', 'high'),
        createTestClass('2', '10', 'high'),
        createTestClass('3', '11', 'high')
      ];

      const engine = new ScheduleEngine(classes, startDate, defaultConstraints, defaultPreferences);
      const schedule = engine.generateSchedule();

      // Check if classes on the same day are scheduled in grade progression order
      const classesByDate = new Map<string, Array<{ grade: number, period: number }>>();
      schedule.classes.forEach(cls => {
        const dateKey = cls.date.toISOString().split('T')[0];
        const existing = classesByDate.get(dateKey) || [];
        existing.push({
          grade: parseInt(cls.gradeLevel),
          period: cls.period
        });
        classesByDate.set(dateKey, existing);
      });

      classesByDate.forEach(dayClasses => {
        // Sort by period to get the actual sequence
        dayClasses.sort((a, b) => a.period - b.period);
        
        // For low-to-high progression, check if grades are increasing
        for (let i = 1; i < dayClasses.length; i++) {
          expect(dayClasses[i].grade).toBeGreaterThanOrEqual(dayClasses[i-1].grade);
        }
      });
    });
  });

  describe('generateSchedule - Edge Cases', () => {
    it('should handle same grade level classes appropriately', () => {
      const startDate = new Date('2024-01-01');
      const classes: Class[] = [
        createTestClass('1', '9', 'high'),
        createTestClass('2', '9', 'high'),
        createTestClass('3', '9', 'high')
      ];

      const engine = new ScheduleEngine(classes, startDate, defaultConstraints, defaultPreferences);
      const schedule = engine.generateSchedule();

      // All classes should be scheduled
      expect(schedule.classes.length).toBe(classes.length);
      
      // Classes should be distributed across periods
      const periodsUsed = new Set(schedule.classes.map(c => c.period));
      expect(periodsUsed.size).toBeGreaterThan(1);
    });

    it('should handle non-linear grade progressions', () => {
      const startDate = new Date('2024-01-01');
      const classes = [
        createTestClass('1', '10', 'high'),
        createTestClass('2', '9', 'high'),
        createTestClass('3', '11', 'high')
      ];

      const engine = new ScheduleEngine(classes, startDate, defaultConstraints, defaultPreferences);
      const schedule = engine.generateSchedule();

      // Verify all classes are scheduled
      expect(schedule.classes.length).toBe(classes.length);

      // Verify no total conflicts
      schedule.classes.forEach(cls => {
        const conflictingClasses = schedule.classes.filter(
          other => 
            other.id !== cls.id &&
            other.date.getTime() === cls.date.getTime() &&
            other.period === cls.period
        );
        expect(conflictingClasses.length).toBe(0);
      });
    });

    it('should handle overlapping total and partial conflicts', () => {
      const startDate = new Date('2024-01-01');
      const conflictDate = new Date('2024-01-01');
      
      // Create a scenario where partial conflicts are unavoidable
      const classes: Class[] = [
        {
          ...createTestClass('1', '9', 'high'),
          totalConflicts: [{ date: conflictDate, period: 1 }],
          partialConflicts: [
            { date: conflictDate, period: 2 }
          ]
        },
        {
          ...createTestClass('2', '9', 'high'),
          totalConflicts: [{ date: conflictDate, period: 3 }],
          partialConflicts: [
            { date: conflictDate, period: 2 }
          ]
        }
      ];

      // Use very constrained scheduling to force partial conflicts
      const engine = new ScheduleEngine(classes, startDate, {
        ...defaultConstraints,
        maxPeriodsPerDay: 3,   // Only periods 1-3 available
        maxClassesPerDay: 2,   // Force classes on the same day
        maxConsecutivePeriods: 3  // Allow consecutive periods
      }, defaultPreferences);

      // Run multiple times to increase chance of getting partial conflicts
      let foundPartialConflict = false;
      let attempts = 0;
      const maxAttempts = 50;  // Increased attempts

      while (!foundPartialConflict && attempts < maxAttempts) {
        const schedule = engine.generateSchedule();
        
        // Check if any scheduled classes have partial conflicts
        const scheduledClasses = schedule.classes.filter(cls => 
          cls.date.getTime() === conflictDate.getTime()
        );

        // If we have multiple classes scheduled on the conflict date
        if (scheduledClasses.length > 1) {
          // Count how many classes are scheduled in period 2
          const period2Count = scheduledClasses.filter(cls => cls.period === 2).length;

          // If we have more than one class in period 2, we have a partial conflict
          if (period2Count > 0) {
            foundPartialConflict = true;
          }
        }

        attempts++;
      }

      // At least one run should have had partial conflicts
      expect(foundPartialConflict).toBe(true);

      // Verify that all classes were scheduled
      const finalSchedule = engine.generateSchedule();
      expect(finalSchedule.classes.length).toBe(classes.length);
    });

    it('should handle high-density conflict periods', () => {
      const startDate = new Date('2024-01-01');
      const conflictDate = new Date('2024-01-01');
      
      // Create many classes with conflicts in the same time slots
      const classes: Class[] = Array.from({ length: 5 }, (_, i) => ({
        ...createTestClass(`${i+1}`, '9', 'high'),
        totalConflicts: [
          { date: conflictDate, period: 1 },
          { date: conflictDate, period: 2 }
        ],
        partialConflicts: [
          { date: conflictDate, period: 3 },
          { date: conflictDate, period: 4 }
        ]
      }));

      const engine = new ScheduleEngine(classes, startDate, defaultConstraints, defaultPreferences);
      const schedule = engine.generateSchedule();

      // All classes should be scheduled
      expect(schedule.classes.length).toBe(classes.length);

      // No classes should be in total conflict slots
      const totalConflicts = schedule.classes.filter(
        cls => cls.date.getTime() === conflictDate.getTime() && 
        (cls.period === 1 || cls.period === 2)
      );
      expect(totalConflicts.length).toBe(0);

      // Classes should be distributed across available periods
      const periodsUsed = new Set(schedule.classes.map(c => c.period));
      expect(periodsUsed.size).toBeGreaterThanOrEqual(3);
    });

    it('should respect grade progression when no conflicts exist', () => {
      const startDate = new Date('2024-01-01');
      const classes: Class[] = [
        createTestClass('1', '9', 'high'),
        createTestClass('2', '10', 'high'),
        createTestClass('3', '11', 'high'),
        createTestClass('4', '12', 'high')
      ];

      const engine = new ScheduleEngine(
        classes,
        startDate,
        defaultConstraints,
        { gradeProgression: 'low-to-high' }
      );
      const schedule = engine.generateSchedule();

      // Check score reflects good grade progression
      expect(schedule.score.gradeProgression).toBeGreaterThan(0);
    });
  });

  describe('generateSchedule - Performance', () => {
    it('should handle maximum class load efficiently', () => {
      const startDate = new Date('2024-01-01');
      const maxClasses = defaultConstraints.maxClassesPerDay * 5; // One week worth of classes
      
      const classes: Class[] = Array.from({ length: maxClasses }, (_, i) => 
        createTestClass(`${i+1}`, '9', 'high')
      );

      const startTime = process.hrtime();
      const engine = new ScheduleEngine(
        classes,
        startDate,
        {
          ...defaultConstraints,
          maxPeriodsPerDay: 8,  // Ensure enough periods per day
          maxClassesPerDay: 6   // Maintain reasonable class load
        },
        defaultPreferences
      );
      const schedule = engine.generateSchedule();
      const [seconds, nanoseconds] = process.hrtime(startTime);
      const duration = seconds + nanoseconds / 1e9;

      // Schedule should complete within reasonable time
      expect(duration).toBeLessThan(2); // 2 seconds max

      // All classes should be scheduled
      expect(schedule.classes.length).toBe(classes.length);

      // Classes should be well-distributed across days
      const classesPerDay = new Map<string, number>();
      schedule.classes.forEach(cls => {
        const dateKey = cls.date.toISOString().split('T')[0];
        classesPerDay.set(dateKey, (classesPerDay.get(dateKey) || 0) + 1);
      });

      // No day should exceed max classes
      Array.from(classesPerDay.values()).forEach(count => {
        expect(count).toBeLessThanOrEqual(defaultConstraints.maxClassesPerDay);
      });

      // Verify we're using multiple days
      expect(classesPerDay.size).toBeGreaterThanOrEqual(5); // At least a week's worth of days
    });
  });
});

================
File: src/__tests__/constraints.test.ts
================
import { ScheduleConstraints, MaxConsecutivePeriods, ConsecutiveBreakLength } from '../types';

describe('Schedule Constraints Validation', () => {
  // Helper function to create valid base constraints
  const createValidConstraints = (): ScheduleConstraints => ({
    maxPeriodsPerDay: 6,
    maxPeriodsPerWeek: 30,
    consecutivePeriods: {
      maximum: 2 as MaxConsecutivePeriods,
      requireBreak: 1 as ConsecutiveBreakLength
    }
  });

  describe('maxPeriodsPerDay validation', () => {
    it('should accept valid periods per day', () => {
      const constraints = createValidConstraints();
      expect(validateMaxPeriodsPerDay(constraints.maxPeriodsPerDay)).toBe(true);
    });

    it('should reject negative periods per day', () => {
      const constraints = { ...createValidConstraints(), maxPeriodsPerDay: -1 };
      expect(validateMaxPeriodsPerDay(constraints.maxPeriodsPerDay)).toBe(false);
    });

    it('should reject zero periods per day', () => {
      const constraints = { ...createValidConstraints(), maxPeriodsPerDay: 0 };
      expect(validateMaxPeriodsPerDay(constraints.maxPeriodsPerDay)).toBe(false);
    });

    it('should reject more than 8 periods per day', () => {
      const constraints = { ...createValidConstraints(), maxPeriodsPerDay: 9 };
      expect(validateMaxPeriodsPerDay(constraints.maxPeriodsPerDay)).toBe(false);
    });
  });

  describe('maxPeriodsPerWeek validation', () => {
    it('should accept valid periods per week', () => {
      const constraints = createValidConstraints();
      expect(validateMaxPeriodsPerWeek(constraints.maxPeriodsPerWeek)).toBe(true);
    });

    it('should reject negative periods per week', () => {
      const constraints = { ...createValidConstraints(), maxPeriodsPerWeek: -1 };
      expect(validateMaxPeriodsPerWeek(constraints.maxPeriodsPerWeek)).toBe(false);
    });

    it('should reject zero periods per week', () => {
      const constraints = { ...createValidConstraints(), maxPeriodsPerWeek: 0 };
      expect(validateMaxPeriodsPerWeek(constraints.maxPeriodsPerWeek)).toBe(false);
    });

    it('should reject more than 40 periods per week', () => {
      const constraints = { ...createValidConstraints(), maxPeriodsPerWeek: 41 };
      expect(validateMaxPeriodsPerWeek(constraints.maxPeriodsPerWeek)).toBe(false);
    });

    it('should reject when less than maxPeriodsPerDay * 5', () => {
      const constraints = {
        ...createValidConstraints(),
        maxPeriodsPerDay: 6,
        maxPeriodsPerWeek: 25 // Less than 6 * 5 = 30
      };
      expect(validateMaxPeriodsPerWeek(constraints.maxPeriodsPerWeek, constraints.maxPeriodsPerDay)).toBe(false);
    });
  });

  describe('consecutivePeriods validation', () => {
    it('should accept valid consecutive period settings', () => {
      const constraints = createValidConstraints();
      expect(validateConsecutivePeriods(constraints.consecutivePeriods)).toBe(true);
    });

    it('should reject invalid maximum consecutive periods', () => {
      const constraints = {
        ...createValidConstraints(),
        consecutivePeriods: {
          ...createValidConstraints().consecutivePeriods,
          maximum: 3 as MaxConsecutivePeriods
        }
      };
      expect(validateConsecutivePeriods(constraints.consecutivePeriods)).toBe(false);
    });

    it('should reject invalid break length', () => {
      const constraints = {
        ...createValidConstraints(),
        consecutivePeriods: {
          ...createValidConstraints().consecutivePeriods,
          requireBreak: 3 as ConsecutiveBreakLength
        }
      };
      expect(validateConsecutivePeriods(constraints.consecutivePeriods)).toBe(false);
    });
  });
});

// Validation functions
function validateMaxPeriodsPerDay(maxPeriodsPerDay: number): boolean {
  return maxPeriodsPerDay > 0 && maxPeriodsPerDay <= 8;
}

function validateMaxPeriodsPerWeek(maxPeriodsPerWeek: number, maxPeriodsPerDay?: number): boolean {
  if (maxPeriodsPerWeek <= 0 || maxPeriodsPerWeek > 40) return false;
  if (maxPeriodsPerDay && maxPeriodsPerWeek < maxPeriodsPerDay * 5) return false;
  return true;
}

function validateConsecutivePeriods(consecutivePeriods: ScheduleConstraints['consecutivePeriods']): boolean {
  const validMaximums = [1, 2];
  const validBreakLengths = [1, 2];
  
  return (
    validMaximums.includes(consecutivePeriods.maximum) &&
    validBreakLengths.includes(consecutivePeriods.requireBreak)
  );
}

================
File: src/__tests__/parallelScheduler.test.ts
================
import { ParallelScheduler } from '../utils/parallelScheduler'
import { Class, ScheduleConstraints, SchedulePreferences, BlackoutPeriod } from '../types'
import { ClassBuilder } from './utils/builders'

describe('ParallelScheduler', () => {
  const startDate = new Date('2024-01-01')
  const constraints: ScheduleConstraints = {
    maxPeriodsPerDay: 4,
    maxPeriodsPerWeek: 16,
    consecutivePeriods: { maximum: 2, requireBreak: 1 }
  }
  const preferences: SchedulePreferences = {
    gradeProgression: 'none',
    gradeGroups: [
      { id: '1', name: '9th Grade', grades: ['9'] },
      { id: '2', name: '10th Grade', grades: ['10'] },
      { id: '3', name: '11th Grade', grades: ['11'] },
      { id: '4', name: '12th Grade', grades: ['12'] }
    ],
    preferSameGradeInDay: true
  }
  const blackoutPeriods: BlackoutPeriod[] = []

  // Helper to generate classes
  const generateClasses = (count: number, gradeDistribution: string[]): Class[] => {
    return Array(count).fill(null).map((_, i) => 
      new ClassBuilder()
        .withGradeLevel(gradeDistribution[i % gradeDistribution.length])
        .build()
    )
  }

  it('should generate valid schedule with parallel processing', async () => {
    const classes = generateClasses(10, ['9', '10'])
    const scheduler = new ParallelScheduler(
      classes,
      startDate,
      constraints,
      preferences,
      blackoutPeriods,
      2 // Use 2 workers for testing
    )

    const schedule = await scheduler.generateSchedule()

    expect(schedule.classes.length).toBe(classes.length)
    expect(schedule.startDate).toEqual(startDate)
    expect(schedule.constraints).toEqual(constraints)
  }, 10000) // Increase timeout for parallel processing

  it('should handle large number of classes efficiently', async () => {
    const classes = generateClasses(50, ['9', '10', '11', '12'])
    const scheduler = new ParallelScheduler(
      classes,
      startDate,
      constraints,
      preferences,
      blackoutPeriods,
      4 // Use 4 workers
    )

    const startTime = Date.now()
    const schedule = await scheduler.generateSchedule()
    const duration = Date.now() - startTime

    expect(schedule.classes.length).toBe(classes.length)
    // Should complete within reasonable time (adjust based on actual performance)
    expect(duration).toBeLessThan(30000)
  }, 30000)

  it('should maintain schedule quality with parallel processing', async () => {
    const classes = generateClasses(20, ['9', '10'])
    
    // Create schedules with different worker counts
    const singleWorkerScheduler = new ParallelScheduler(
      classes,
      startDate,
      constraints,
      preferences,
      blackoutPeriods,
      1
    )

    const multiWorkerScheduler = new ParallelScheduler(
      classes,
      startDate,
      constraints,
      preferences,
      blackoutPeriods,
      4
    )

    const [singleWorkerSchedule, multiWorkerSchedule] = await Promise.all([
      singleWorkerScheduler.generateSchedule(),
      multiWorkerScheduler.generateSchedule()
    ])

    // Multi-worker solution should be at least as good as single-worker
    expect(multiWorkerSchedule.score.gradeGroupCohesion)
      .toBeGreaterThanOrEqual(singleWorkerSchedule.score.gradeGroupCohesion * 0.9)
  }, 20000)

  it('should handle conflicts in parallel', async () => {
    const baseClass = new ClassBuilder().withGradeLevel('9').build()
    const classes: Class[] = [
      { ...baseClass, id: '1', totalConflicts: [
        { classId: '2', dayOfWeek: 1, period: 1 },
        { classId: '3', dayOfWeek: 2, period: 1 }
      ]},
      { ...baseClass, id: '2', totalConflicts: [{ classId: '1', dayOfWeek: 1, period: 1 }]},
      { ...baseClass, id: '3', totalConflicts: [{ classId: '1', dayOfWeek: 2, period: 1 }]}
    ]

    const scheduler = new ParallelScheduler(
      classes,
      startDate,
      constraints,
      preferences,
      blackoutPeriods,
      2
    )

    const schedule = await scheduler.generateSchedule()

    // Verify no conflicts in final schedule
    const class1 = schedule.classes.find(c => c.id === '1')!
    const class2 = schedule.classes.find(c => c.id === '2')!
    const class3 = schedule.classes.find(c => c.id === '3')!

    expect(
      class1.date.getDay() === class2.date.getDay() && 
      class1.period === class2.period
    ).toBeFalsy()

    expect(
      class1.date.getDay() === class3.date.getDay() && 
      class1.period === class3.period
    ).toBeFalsy()
  })

  it('should handle worker failures gracefully', async () => {
    const classes = generateClasses(15, ['9', '10', '11'])
    const scheduler = new ParallelScheduler(
      classes,
      startDate,
      constraints,
      preferences,
      blackoutPeriods,
      3
    )

    // Mock a worker failure by terminating one worker early
    setTimeout(() => {
      if (scheduler['workers'].length > 0) {
        scheduler['workers'][0].terminate()
      }
    }, 1000)

    const schedule = await scheduler.generateSchedule()

    // Should still produce valid schedule despite worker failure
    expect(schedule.classes.length).toBe(classes.length)
    expect(schedule.score).toBeDefined()
  }, 15000)

  it('should improve solution quality with more workers', async () => {
    const classes = generateClasses(30, ['9', '10', '11'])
    
    // Test with increasing worker counts
    const workerCounts = [1, 2, 4]
    const schedules = await Promise.all(
      workerCounts.map(count => 
        new ParallelScheduler(
          classes,
          startDate,
          constraints,
          preferences,
          blackoutPeriods,
          count
        ).generateSchedule()
      )
    )

    // Compare scores (should generally improve with more workers)
    const scores = schedules.map(s => 
      s.score.gradeGroupCohesion + 
      s.score.distributionQuality
    )

    // At least one multi-worker solution should be better than single worker
    expect(Math.max(scores[1], scores[2])).toBeGreaterThan(scores[0])
  }, 30000)
})

================
File: src/__tests__/scheduleEngine.test.ts
================
import { ScheduleEngine } from '../utils/scheduleEngine';
import { Class, ScheduleConstraints } from '../types';

describe('ScheduleEngine', () => {
  const startDate = new Date('2024-01-01');
  const endDate = new Date('2024-12-31');
  const maxPeriodsPerDay = 8;
  const maxPeriodsPerWeek = 30;

  const createTestConstraints = (): ScheduleConstraints => ({
    maxPeriodsPerDay,
    maxPeriodsPerWeek,
    blackoutPeriods: []
  });

  const createTestClass = (id: string, gradeGroup: string = 'A'): Class => ({
    id,
    name: `Test Class ${id}`,
    gradeGroup,
    teacher: `teacher-${Math.floor(parseInt(id) / 4)}`,
    totalConflicts: [],
    partialConflicts: []
  });

  let engine: ScheduleEngine;

  beforeEach(() => {
    engine = new ScheduleEngine(
      createTestConstraints(),
      startDate,
      endDate,
      maxPeriodsPerDay,
      maxPeriodsPerWeek
    );
  });

  describe('Schedule Generation', () => {
    test('should generate valid schedule', () => {
      const classes = Array.from({ length: 5 }, (_, i) => createTestClass(String(i)));
      const schedule = engine.generateSchedule();
      
      expect(schedule.classes.length).toBeGreaterThan(0);
      expect(schedule.classes.every(c => c.date && c.period)).toBe(true);
    });

    test('should respect maximum periods per day', () => {
      const constraints = createTestConstraints();
      constraints.maxPeriodsPerDay = 4;
      engine = new ScheduleEngine(
        constraints,
        startDate,
        endDate,
        constraints.maxPeriodsPerDay,
        constraints.maxPeriodsPerWeek
      );
      
      const schedule = engine.generateSchedule();
      
      // Group classes by date
      const classesByDate = schedule.classes.reduce((acc: Record<string, number>, cls) => {
        const dateStr = cls.date.toISOString().split('T')[0];
        acc[dateStr] = (acc[dateStr] || 0) + 1;
        return acc;
      }, {});
      
      // Check that no day has more than maxPeriodsPerDay classes
      expect(Object.values(classesByDate).every(count => count <= constraints.maxPeriodsPerDay))
        .toBe(true);
    });

    test('should respect maximum periods per week', () => {
      const constraints = createTestConstraints();
      constraints.maxPeriodsPerWeek = 15;
      engine = new ScheduleEngine(
        constraints,
        startDate,
        endDate,
        constraints.maxPeriodsPerDay,
        constraints.maxPeriodsPerWeek
      );
      
      const schedule = engine.generateSchedule();
      
      // Group classes by week
      const classesByWeek = schedule.classes.reduce((acc: Record<string, number>, cls) => {
        const weekStart = new Date(cls.date);
        weekStart.setDate(weekStart.getDate() - weekStart.getDay());
        const weekKey = weekStart.toISOString();
        acc[weekKey] = (acc[weekKey] || 0) + 1;
        return acc;
      }, {});
      
      // Check that no week has more than maxPeriodsPerWeek classes
      expect(Object.values(classesByWeek).every(count => count <= constraints.maxPeriodsPerWeek))
        .toBe(true);
    });
  });

  describe('Schedule Optimization', () => {
    test('should improve schedule quality through optimization', () => {
      const schedule = engine.generateSchedule();
      const optimizedSchedule = engine.optimizeSchedule(schedule);
      
      expect(optimizedSchedule.classes.length).toBeGreaterThanOrEqual(schedule.classes.length);
      expect(optimizedSchedule.score.totalLength).toBeGreaterThanOrEqual(schedule.score.totalLength);
    });

    test('should maintain schedule validity after optimization', () => {
      const schedule = engine.generateSchedule();
      const optimizedSchedule = engine.optimizeSchedule(schedule);
      
      // Check that all scheduled classes have valid dates and periods
      expect(optimizedSchedule.classes.every(c => c.date && c.period)).toBe(true);
      
      // Check that constraints are still respected
      expect(optimizedSchedule.score.constraintViolations).toBe(0);
    });
  });
});

================
File: src/__tests__/scheduleQuality.test.ts
================
import { ScheduleEngine } from '../utils/scheduleEngine';
import { Class, Schedule, ScheduleConstraints, SchedulePreferences, GradeGroup } from '../types';

const defaultConstraints: ScheduleConstraints = {
  maxPeriodsPerDay: 8,
  maxClassesPerDay: 6,
  maxConsecutivePeriods: 4,
  requiredBreakLength: 1
};

const defaultPreferences: SchedulePreferences = {
  gradeProgression: 'none'
};

function createTestClass(id: string, gradeLevel: string, gradeGroup: GradeGroup): Class {
  return {
    id,
    name: `Class ${id}`,
    gradeLevel,
    gradeGroup,
    teacher: `Teacher ${id}`,
    totalConflicts: [],
    partialConflicts: []
  };
}

function generateLargeClassSet(size: number): Class[] {
  const classes: Class[] = [];
  const gradeLevels = ['9', '10', '11', '12'];
  const gradeGroups: GradeGroup[] = ['elementary', 'middle', 'high'];

  for (let i = 0; i < size; i++) {
    const gradeLevel = gradeLevels[Math.floor(Math.random() * gradeLevels.length)];
    const gradeGroup = gradeGroups[Math.floor(Math.random() * gradeGroups.length)];
    classes.push(createTestClass(i.toString(), gradeLevel, gradeGroup));
  }

  // Add some conflicts
  classes.forEach(cls => {
    // 20% chance of having a total conflict
    if (Math.random() < 0.2) {
      cls.totalConflicts.push({
        date: new Date('2024-01-01'),
        period: Math.floor(Math.random() * 8) + 1
      });
    }

    // 30% chance of having a partial conflict
    if (Math.random() < 0.3) {
      cls.partialConflicts.push({
        date: new Date('2024-01-01'),
        period: Math.floor(Math.random() * 8) + 1
      });
    }
  });

  return classes;
}

function analyzeSchedule(schedule: Schedule) {
  const classesByDate = new Map<string, any[]>();
  const classesByGradeGroup = new Map<string, any[]>();
  const periodsUsedPerDay = new Map<string, Set<number>>();

  schedule.classes.forEach(cls => {
    // Group by date
    const dateKey = cls.date.toISOString().split('T')[0];
    if (!classesByDate.has(dateKey)) {
      classesByDate.set(dateKey, []);
    }
    classesByDate.get(dateKey)?.push(cls);

    // Group by grade group
    if (!classesByGradeGroup.has(cls.gradeGroup)) {
      classesByGradeGroup.set(cls.gradeGroup, []);
    }
    classesByGradeGroup.get(cls.gradeGroup)?.push(cls);

    // Track periods used per day
    if (!periodsUsedPerDay.has(dateKey)) {
      periodsUsedPerDay.set(dateKey, new Set());
    }
    periodsUsedPerDay.get(dateKey)?.add(cls.period);
  });

  return {
    totalClasses: schedule.classes.length,
    daysUsed: classesByDate.size,
    averageClassesPerDay: schedule.classes.length / classesByDate.size,
    gradeGroupDistribution: Object.fromEntries(
      Array.from(classesByGradeGroup.entries()).map(([group, classes]) => [
        group,
        classes.length
      ])
    ),
    averagePeriodsPerDay: Array.from(periodsUsedPerDay.values()).reduce(
      (acc, periods) => acc + periods.size,
      0
    ) / periodsUsedPerDay.size,
    score: schedule.score
  };
}

describe('Schedule Quality Analysis', () => {
  const startDate = new Date('2024-01-01');

  describe('Small Schedule (20 classes)', () => {
    it('should generate high-quality schedules', () => {
      const classes = generateLargeClassSet(20);
      const engine = new ScheduleEngine(classes, startDate, defaultConstraints, defaultPreferences);
      
      const schedules: any[] = [];
      const iterations = 10;

      console.time('Small Schedule Generation');
      for (let i = 0; i < iterations; i++) {
        const schedule = engine.generateSchedule();
        schedules.push(analyzeSchedule(schedule));
      }
      console.timeEnd('Small Schedule Generation');

      const averageScore = schedules.reduce((acc, s) => acc + s.score.totalLength, 0) / iterations;
      const averageClassesPerDay = schedules.reduce((acc, s) => acc + s.averageClassesPerDay, 0) / iterations;
      const averagePeriodsPerDay = schedules.reduce((acc, s) => acc + s.averagePeriodsPerDay, 0) / iterations;

      console.log('Small Schedule Metrics:', {
        averageScore,
        averageClassesPerDay,
        averagePeriodsPerDay,
        schedules: schedules[0] // Example of first schedule
      });

      expect(averageScore).toBeGreaterThan(0.9);
      expect(averageClassesPerDay).toBeLessThanOrEqual(defaultConstraints.maxClassesPerDay);
      expect(averagePeriodsPerDay).toBeLessThanOrEqual(defaultConstraints.maxPeriodsPerDay);
    });
  });

  describe('Medium Schedule (50 classes)', () => {
    it('should generate high-quality schedules', () => {
      const classes = generateLargeClassSet(50);
      const engine = new ScheduleEngine(classes, startDate, defaultConstraints, defaultPreferences);
      
      const schedules: any[] = [];
      const iterations = 5;

      console.time('Medium Schedule Generation');
      for (let i = 0; i < iterations; i++) {
        const schedule = engine.generateSchedule();
        schedules.push(analyzeSchedule(schedule));
      }
      console.timeEnd('Medium Schedule Generation');

      const averageScore = schedules.reduce((acc, s) => acc + s.score.totalLength, 0) / iterations;
      const averageClassesPerDay = schedules.reduce((acc, s) => acc + s.averageClassesPerDay, 0) / iterations;
      const averagePeriodsPerDay = schedules.reduce((acc, s) => acc + s.averagePeriodsPerDay, 0) / iterations;

      console.log('Medium Schedule Metrics:', {
        averageScore,
        averageClassesPerDay,
        averagePeriodsPerDay,
        schedules: schedules[0] // Example of first schedule
      });

      expect(averageScore).toBeGreaterThan(0.85);
      expect(averageClassesPerDay).toBeLessThanOrEqual(defaultConstraints.maxClassesPerDay);
      expect(averagePeriodsPerDay).toBeLessThanOrEqual(defaultConstraints.maxPeriodsPerDay);
    });
  });

  describe('Large Schedule (100 classes)', () => {
    it('should generate high-quality schedules', () => {
      const classes = generateLargeClassSet(100);
      const engine = new ScheduleEngine(classes, startDate, defaultConstraints, defaultPreferences);
      
      const schedules: any[] = [];
      const iterations = 3;

      console.time('Large Schedule Generation');
      for (let i = 0; i < iterations; i++) {
        const schedule = engine.generateSchedule();
        schedules.push(analyzeSchedule(schedule));
      }
      console.timeEnd('Large Schedule Generation');

      const averageScore = schedules.reduce((acc, s) => acc + s.score.totalLength, 0) / iterations;
      const averageClassesPerDay = schedules.reduce((acc, s) => acc + s.averageClassesPerDay, 0) / iterations;
      const averagePeriodsPerDay = schedules.reduce((acc, s) => acc + s.averagePeriodsPerDay, 0) / iterations;

      console.log('Large Schedule Metrics:', {
        averageScore,
        averageClassesPerDay,
        averagePeriodsPerDay,
        schedules: schedules[0] // Example of first schedule
      });

      expect(averageScore).toBeGreaterThan(0.8);
      expect(averageClassesPerDay).toBeLessThanOrEqual(defaultConstraints.maxClassesPerDay);
      expect(averagePeriodsPerDay).toBeLessThanOrEqual(defaultConstraints.maxPeriodsPerDay);
    });
  });
});

================
File: src/__tests__/scoring.test.ts
================
import { ScheduleEngine } from '../utils/scheduleEngine';
import { GradeGroup, ScheduleConstraints } from '../types';
import { ClassBuilder, GradeGroupBuilder, PreferencesBuilder } from './utils/builders';

describe('Schedule Scoring System', () => {
  // Common test data
  const startDate = new Date('2024-01-01');
  const defaultConstraints: ScheduleConstraints = {
    maxPeriodsPerDay: 8,
    maxPeriodsPerWeek: 40,
    consecutivePeriods: {
      maximum: 2,
      requireBreak: 1
    }
  };

  let gradeGroups: GradeGroup[];
  let defaultPreferences: any;
  
  beforeEach(() => {
    // Create two grade groups: Lower (1-3) and Upper (4-6)
    gradeGroups = [
      new GradeGroupBuilder()
        .withId('lower')
        .withName('Lower Grades')
        .withGrades(['1', '2', '3'])
        .build(),
      new GradeGroupBuilder()
        .withId('upper')
        .withName('Upper Grades')
        .withGrades(['4', '5', '6'])
        .build()
    ];

    defaultPreferences = new PreferencesBuilder()
      .withGradeGroups(gradeGroups)
      .withPreferSameGradeInDay(true)
      .withGradeProgression('none')
      .build();
  });

  describe('Grade Group Cohesion', () => {
    it('should score perfect cohesion when grade groups are scheduled on different days', () => {
      // Create classes for lower grades on Monday
      const lowerClasses = [
        new ClassBuilder()
          .withGradeLevel('1')
          .withClassNumber(1)
          .withDate(startDate)
          .withPeriod(1)
          .build(),
        new ClassBuilder()
          .withGradeLevel('2')
          .withClassNumber(2)
          .withDate(startDate)
          .withPeriod(2)
          .build()
      ];

      // Create classes for upper grades on Tuesday
      const nextDay = new Date(startDate);
      nextDay.setDate(nextDay.getDate() + 1);
      
      const upperClasses = [
        new ClassBuilder()
          .withGradeLevel('4')
          .withClassNumber(3)
          .withDate(nextDay)
          .withPeriod(1)
          .build(),
        new ClassBuilder()
          .withGradeLevel('5')
          .withClassNumber(4)
          .withDate(nextDay)
          .withPeriod(2)
          .build()
      ];

      const engine = new ScheduleEngine(
        [...lowerClasses, ...upperClasses],
        startDate,
        defaultConstraints,
        defaultPreferences,
        []
      );

      const schedule = engine.scoreExistingSchedule([...lowerClasses, ...upperClasses]);
      expect(schedule.score.gradeGroupCohesion).toBe(1); // Perfect cohesion
    });

    it('should score lower cohesion when grade groups are mixed on same day', () => {
      // Mix lower and upper grades on same day
      const mixedClasses = [
        new ClassBuilder()
          .withGradeLevel('1')
          .withClassNumber(1)
          .withDate(startDate)
          .withPeriod(1)
          .build(),
        new ClassBuilder()
          .withGradeLevel('4')
          .withClassNumber(2)
          .withDate(startDate)
          .withPeriod(2)
          .build(),
        new ClassBuilder()
          .withGradeLevel('2')
          .withClassNumber(3)
          .withDate(startDate)
          .withPeriod(3)
          .build(),
        new ClassBuilder()
          .withGradeLevel('5')
          .withClassNumber(4)
          .withDate(startDate)
          .withPeriod(4)
          .build()
      ];

      const engine = new ScheduleEngine(
        mixedClasses,
        startDate,
        defaultConstraints,
        defaultPreferences,
        []
      );

      const schedule = engine.scoreExistingSchedule(mixedClasses);
      expect(schedule.score.gradeGroupCohesion).toBe(0.5); // Two groups per day = 0.5 cohesion
    });
  });

  describe('Grade Progression', () => {
    it('should score perfect progression when high-to-low preference is followed', () => {
      const preferences = new PreferencesBuilder()
        .withGradeGroups(gradeGroups)
        .withPreferSameGradeInDay(true)
        .withGradeProgression('high-to-low')
        .build();

      const classes = [
        new ClassBuilder()
          .withGradeLevel('6')
          .withClassNumber(1)
          .withDate(startDate)
          .withPeriod(1)
          .build(),
        new ClassBuilder()
          .withGradeLevel('5')
          .withClassNumber(2)
          .withDate(startDate)
          .withPeriod(2)
          .build(),
        new ClassBuilder()
          .withGradeLevel('4')
          .withClassNumber(3)
          .withDate(startDate)
          .withPeriod(3)
          .build()
      ];

      const engine = new ScheduleEngine(
        classes,
        startDate,
        defaultConstraints,
        preferences,
        []
      );

      const schedule = engine.scoreExistingSchedule(classes);
      expect(schedule.score.gradeProgression).toBe(1); // Perfect progression
    });

    it('should score perfect progression when low-to-high preference is followed', () => {
      const preferences = new PreferencesBuilder()
        .withGradeGroups(gradeGroups)
        .withPreferSameGradeInDay(true)
        .withGradeProgression('low-to-high')
        .build();

      const classes = [
        new ClassBuilder()
          .withGradeLevel('1')
          .withClassNumber(1)
          .withDate(startDate)
          .withPeriod(1)
          .build(),
        new ClassBuilder()
          .withGradeLevel('2')
          .withClassNumber(2)
          .withDate(startDate)
          .withPeriod(2)
          .build(),
        new ClassBuilder()
          .withGradeLevel('3')
          .withClassNumber(3)
          .withDate(startDate)
          .withPeriod(3)
          .build()
      ];

      const engine = new ScheduleEngine(
        classes,
        startDate,
        defaultConstraints,
        preferences,
        []
      );

      const schedule = engine.scoreExistingSchedule(classes);
      expect(schedule.score.gradeProgression).toBe(1); // Perfect progression
    });
  });

  describe('Distribution Quality', () => {
    it('should score perfect distribution when classes are evenly distributed', () => {
      const classes = [
        // Monday - 2 classes
        new ClassBuilder()
          .withGradeLevel('1')
          .withClassNumber(1)
          .withDate(startDate)
          .withPeriod(1)
          .build(),
        new ClassBuilder()
          .withGradeLevel('2')
          .withClassNumber(2)
          .withDate(startDate)
          .withPeriod(2)
          .build(),
        // Tuesday - 2 classes
        new ClassBuilder()
          .withGradeLevel('3')
          .withClassNumber(3)
          .withDate(new Date(startDate.getTime() + 24 * 60 * 60 * 1000))
          .withPeriod(1)
          .build(),
        new ClassBuilder()
          .withGradeLevel('4')
          .withClassNumber(4)
          .withDate(new Date(startDate.getTime() + 24 * 60 * 60 * 1000))
          .withPeriod(2)
          .build()
      ];

      const engine = new ScheduleEngine(
        classes,
        startDate,
        defaultConstraints,
        defaultPreferences,
        []
      );

      const schedule = engine.scoreExistingSchedule(classes);
      expect(schedule.score.distributionQuality).toBe(1); // Perfect distribution
    });

    it('should score lower distribution when classes are unevenly distributed', () => {
      const classes = [
        // Monday - 1 class
        new ClassBuilder()
          .withGradeLevel('1')
          .withClassNumber(1)
          .withDate(startDate)
          .withPeriod(1)
          .build(),
        // Tuesday - 3 classes
        new ClassBuilder()
          .withGradeLevel('2')
          .withClassNumber(2)
          .withDate(new Date(startDate.getTime() + 24 * 60 * 60 * 1000))
          .withPeriod(1)
          .build(),
        new ClassBuilder()
          .withGradeLevel('3')
          .withClassNumber(3)
          .withDate(new Date(startDate.getTime() + 24 * 60 * 60 * 1000))
          .withPeriod(2)
          .build(),
        new ClassBuilder()
          .withGradeLevel('4')
          .withClassNumber(4)
          .withDate(new Date(startDate.getTime() + 24 * 60 * 60 * 1000))
          .withPeriod(3)
          .build()
      ];

      const engine = new ScheduleEngine(
        classes,
        startDate,
        defaultConstraints,
        defaultPreferences,
        []
      );

      const schedule = engine.scoreExistingSchedule(classes);
      expect(schedule.score.distributionQuality).toBeLessThan(1); // Imperfect distribution
    });
  });

  describe('Constraint Violations', () => {
    it('should count violations when max periods per day is exceeded', () => {
      const classes = Array.from({ length: 10 }, (_, i) => 
        new ClassBuilder()
          .withGradeLevel('1')
          .withClassNumber(i + 1)
          .withDate(startDate)
          .withPeriod(i + 1)
          .build()
      );

      const engine = new ScheduleEngine(
        classes,
        startDate,
        defaultConstraints,
        defaultPreferences,
        []
      );

      const schedule = engine.scoreExistingSchedule(classes);
      expect(schedule.score.constraintViolations).toBeGreaterThan(0);
    });

    it('should count violations when consecutive period limit is exceeded', () => {
      const classes = [
        new ClassBuilder()
          .withGradeLevel('1')
          .withClassNumber(1)
          .withDate(startDate)
          .withPeriod(1)
          .build(),
        new ClassBuilder()
          .withGradeLevel('1')
          .withClassNumber(2)
          .withDate(startDate)
          .withPeriod(2)
          .build(),
        new ClassBuilder()
          .withGradeLevel('1')
          .withClassNumber(3)
          .withDate(startDate)
          .withPeriod(3)
          .build()
      ];

      const engine = new ScheduleEngine(
        classes,
        startDate,
        defaultConstraints,
        defaultPreferences,
        []
      );

      const schedule = engine.scoreExistingSchedule(classes);
      expect(schedule.score.constraintViolations).toBeGreaterThan(0);
    });
  });

  describe('Total Length', () => {
    it('should prefer shorter schedules', () => {
      // Create a compact schedule (all on same day)
      const compactClasses = [
        new ClassBuilder()
          .withGradeLevel('1')
          .withClassNumber(1)
          .withDate(startDate)
          .withPeriod(1)
          .build(),
        new ClassBuilder()
          .withGradeLevel('2')
          .withClassNumber(2)
          .withDate(startDate)
          .withPeriod(2)
          .build()
      ];

      // Create a spread out schedule (on different days)
      const spreadClasses = [
        new ClassBuilder()
          .withGradeLevel('1')
          .withClassNumber(1)
          .withDate(startDate)
          .withPeriod(1)
          .build(),
        new ClassBuilder()
          .withGradeLevel('2')
          .withClassNumber(2)
          .withDate(new Date(startDate.getTime() + 2 * 24 * 60 * 60 * 1000))  // 2 days later
          .withPeriod(1)
          .build()
      ];

      const compactEngine = new ScheduleEngine(
        compactClasses,
        startDate,
        defaultConstraints,
        defaultPreferences,
        []
      );

      const spreadEngine = new ScheduleEngine(
        spreadClasses,
        startDate,
        defaultConstraints,
        defaultPreferences,
        []
      );

      const compactSchedule = compactEngine.scoreExistingSchedule(compactClasses);
      const spreadSchedule = spreadEngine.scoreExistingSchedule(spreadClasses);

      expect(compactSchedule.score.totalLength).toBeLessThan(spreadSchedule.score.totalLength);
    });
  });
});

================
File: src/__tests__/simulatedAnnealing.test.ts
================
import { SimulatedAnnealing } from '../utils/simulatedAnnealing';
import { ScheduleEngine } from '../utils/scheduleEngine';
import { Class, Schedule, ScheduleConstraints } from '../types';

describe('SimulatedAnnealing', () => {
  const createTestConstraints = (): ScheduleConstraints => ({
    maxPeriodsPerDay: 8,
    maxPeriodsPerWeek: 30,
    blackoutPeriods: []
  });

  const createTestClass = (id: string): Class => ({
    id,
    name: `Test Class ${id}`,
    gradeGroup: `group-${Math.floor(parseInt(id) / 3)}`,
    teacher: `teacher-${Math.floor(parseInt(id) / 4)}`,
    totalConflicts: [],
    partialConflicts: []
  });

  describe('Optimization Process', () => {
    let engine: ScheduleEngine;
    let annealing: SimulatedAnnealing;

    beforeEach(() => {
      engine = new ScheduleEngine(createTestConstraints());
      annealing = new SimulatedAnnealing(engine, {
        initialTemperature: 1000,
        coolingRate: 0.95,
        maxIterations: 1000,
        minTemperature: 0.01
      });
    });

    test('should generate valid initial solution', async () => {
      const classes = Array.from({ length: 5 }, (_, i) => createTestClass(String(i)));
      const result = await annealing.optimize(classes);
      expect(result.classes.length).toBeGreaterThan(0);
    });

    test('should improve schedule quality over iterations', async () => {
      const classes = Array.from({ length: 10 }, (_, i) => createTestClass(String(i)));
      const result = await annealing.optimize(classes);
      const score = engine.calculateScore(result);

      expect(score.totalLength).toBeGreaterThan(0.7);
      expect(score.partialConflictPenalty).toBeLessThan(0.3);
    });

    test('should handle partial conflicts appropriately', async () => {
      const date = new Date();
      const classes = [
        {
          ...createTestClass('1'),
          partialConflicts: [{ date, period: 1 }]
        },
        {
          ...createTestClass('2'),
          partialConflicts: [{ date, period: 1 }]
        }
      ];

      const result = await annealing.optimize(classes);
      const score = engine.calculateScore(result);

      expect(score.partialConflictPenalty).toBeLessThan(0.5);
    });

    test('should respect total conflicts', async () => {
      const date = new Date();
      const classes = [
        {
          ...createTestClass('1'),
          totalConflicts: [{ date, period: 1 }]
        },
        createTestClass('2')
      ];

      const result = await annealing.optimize(classes);
      
      // Verify no class is scheduled during total conflict
      const hasConflictingSchedule = result.classes.some(
        cls => cls.date.getTime() === date.getTime() && cls.period === 1
      );
      expect(hasConflictingSchedule).toBe(false);
    });
  });

  describe('Performance Characteristics', () => {
    test('should complete optimization within reasonable time', async () => {
      const engine = new ScheduleEngine(createTestConstraints());
      const annealing = new SimulatedAnnealing(engine, {
        initialTemperature: 1000,
        coolingRate: 0.95,
        maxIterations: 1000,
        minTemperature: 0.01
      });

      const classes = Array.from({ length: 20 }, (_, i) => createTestClass(String(i)));
      
      const startTime = process.hrtime();
      const result = await annealing.optimize(classes);
      const [seconds, nanoseconds] = process.hrtime(startTime);
      const duration = seconds + nanoseconds / 1e9;

      expect(duration).toBeLessThan(10); // Should complete within 10 seconds
      expect(result.classes.length).toBeGreaterThan(0);
    });

    test('should maintain quality with larger schedules', async () => {
      const engine = new ScheduleEngine(createTestConstraints());
      const annealing = new SimulatedAnnealing(engine, {
        initialTemperature: 1000,
        coolingRate: 0.95,
        maxIterations: 2000,
        minTemperature: 0.01
      });

      const classes = Array.from({ length: 50 }, (_, i) => createTestClass(String(i)));
      
      const result = await annealing.optimize(classes);
      const score = engine.calculateScore(result);

      expect(score.totalLength).toBeGreaterThan(0.7);
      expect(score.partialConflictPenalty).toBeLessThan(0.4);
    });
  });
});

================
File: src/assets/react.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

================
File: src/components/schedule/ExportButton.tsx
================
import { useState } from 'react'
import { Schedule } from '../../types'
import { exportUtils, downloadFile } from '../../utils/export'
import { Button } from '../ui/button'
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '../ui/dropdown-menu'

interface ExportButtonProps {
  schedule: Schedule
  startDate: Date
  endDate: Date
}

export function ExportButton({ schedule, startDate, endDate }: ExportButtonProps) {
  const [isExporting, setIsExporting] = useState(false)

  const handleExport = async (format: 'csv' | 'pdf', exportRange: 'current' | 'all' = 'current') => {
    try {
      setIsExporting(true)
      const content = await exportUtils.exportSchedule(schedule, {
        format,
        weekRange: exportRange === 'current' ? { start: startDate, end: endDate } : undefined
      })

      const filename = exportRange === 'current'
        ? `schedule-${startDate.toISOString().split('T')[0]}-to-${endDate.toISOString().split('T')[0]}.${format}`
        : `complete-schedule.${format}`

      downloadFile(content, filename)
    } catch (error) {
      console.error('Failed to export schedule:', error)
      // You might want to show a toast notification here
    } finally {
      setIsExporting(false)
    }
  }

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" disabled={isExporting}>
          {isExporting ? 'Exporting...' : 'Export'}
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent>
        <DropdownMenuItem onClick={() => handleExport('csv', 'current')}>
          Export Current Week (CSV)
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => handleExport('pdf', 'current')}>
          Export Current Week (PDF)
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => handleExport('csv', 'all')}>
          Export Complete Schedule (CSV)
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => handleExport('pdf', 'all')}>
          Export Complete Schedule (PDF)
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  )
}

================
File: src/components/schedule/MonthView.tsx
================
import { useMemo } from 'react'
import { Schedule, ScheduledClass, WeekSchedule, BlackoutPeriod } from '../../types'
import { scheduleUtils } from '../../utils/schedule'
import { ScheduleCell } from './ScheduleCell'

interface MonthViewProps {
  schedule?: Schedule
  weekSchedules: WeekSchedule[]
  blackoutPeriods: BlackoutPeriod[]
  startDate: Date
  onClassClick?: (scheduledClass: ScheduledClass) => void
  onClassDrop?: (classId: string, period: number, date: Date) => void
  onPeriodClick?: (period: number, date: Date) => void
}

export function MonthView({
  schedule,
  weekSchedules,
  blackoutPeriods,
  startDate,
  onClassClick,
  onClassDrop,
  onPeriodClick
}: MonthViewProps) {
  // Get the start of the month
  const monthStart = useMemo(() => {
    const date = new Date(startDate)
    date.setDate(1)
    return date
  }, [startDate])

  // Get the end of the month
  const monthEnd = useMemo(() => {
    const date = new Date(startDate)
    date.setMonth(date.getMonth() + 1)
    date.setDate(0)
    return date
  }, [startDate])

  // Get all days in the month
  const days = useMemo(() => {
    const result = []
    let currentDate = new Date(monthStart)

    // Start from the first Monday before the month start
    while (currentDate.getDay() !== 1) {
      currentDate.setDate(currentDate.getDate() - 1)
    }

    // Generate weeks until we reach the first Monday after month end
    while (currentDate <= monthEnd || currentDate.getDay() !== 1) {
      const weekDays = []
      for (let i = 0; i < 7; i++) {
        weekDays.push(new Date(currentDate))
        currentDate.setDate(currentDate.getDate() + 1)
      }
      result.push(weekDays)
    }

    return result
  }, [monthStart, monthEnd])

  // Find classes for a specific date
  const getClassesForDate = (date: Date) => {
    const week = weekSchedules.find(w => 
      date >= w.startDate && date <= w.endDate
    )
    if (!week) return []

    const day = week.days.find(d => 
      scheduleUtils.isSameDay(d.date, date)
    )
    return day?.classes || []
  }

  return (
    <div className="bg-card rounded-lg p-4">
      {/* Month Header */}
      <div className="text-xl font-semibold mb-4 text-center">
        {monthStart.toLocaleDateString(undefined, { month: 'long', year: 'numeric' })}
      </div>

      {/* Day Headers */}
      <div className="grid grid-cols-7 gap-2 mb-2">
        {['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].map(day => (
          <div key={day} className="text-sm font-medium text-center py-2">
            {day}
          </div>
        ))}
      </div>

      {/* Calendar Grid */}
      <div className="grid grid-cols-7 gap-2">
        {days.map((week, weekIndex) => 
          week.map((date, dayIndex) => {
            const isCurrentMonth = date.getMonth() === monthStart.getMonth()
            const isWeekend = date.getDay() === 0 || date.getDay() === 6
            const isBeforeStartDate = date < startDate
            const classes = getClassesForDate(date)

            return (
              <div
                key={`${weekIndex}-${dayIndex}`}
                className={`
                  min-h-[120px] p-2 rounded-lg
                  ${isCurrentMonth ? 'bg-card' : 'bg-muted/20'}
                  ${isWeekend ? 'opacity-50' : ''}
                  ${isBeforeStartDate ? 'opacity-30' : ''}
                `}
              >
                {/* Date Header */}
                <div className="text-sm font-medium mb-2">
                  {date.getDate()}
                </div>

                {/* Classes */}
                <div className="space-y-1">
                  {classes.map(cls => (
                    <div
                      key={cls.id}
                      className="text-xs p-1 rounded bg-primary/20 text-primary-foreground"
                      onClick={() => onClassClick?.(cls)}
                    >
                      P{cls.period}: {cls.classNumber}
                    </div>
                  ))}
                </div>
              </div>
            )
          })
        )}
      </div>
    </div>
  )
}

================
File: src/components/schedule/ScheduleCell.tsx
================
import { useDrop, useDrag } from 'react-dnd'
import { ScheduledClass, BlackoutPeriod } from '../../types'
import { scheduleUtils } from '../../utils/schedule'
import { Tooltip } from '../ui/Tooltip'

interface ScheduleCellProps {
  period: number
  date: Date
  scheduledClass?: ScheduledClass
  blackoutPeriods: BlackoutPeriod[]
  isBeforeStartDate: boolean
  onClassClick?: (scheduledClass: ScheduledClass) => void
  onClassDrop?: (classId: string, period: number, date: Date) => void
  onPeriodClick?: (period: number, date: Date) => void
  constraintSatisfaction?: number // 0-1 score for constraint satisfaction
}

export function ScheduleCell({
  period,
  date,
  scheduledClass,
  blackoutPeriods,
  isBeforeStartDate,
  onClassClick,
  onClassDrop,
  onPeriodClick,
  constraintSatisfaction = 1
}: ScheduleCellProps) {
  const isBlackout = blackoutPeriods.some(
    bp => bp.dayOfWeek === date.getDay() && 
         bp.period === period &&
         scheduleUtils.isSameDay(bp.date, date)
  )

  // Drag configuration for scheduled class
  const [{ isDragging }, drag] = useDrag(() => ({
    type: 'scheduledClass',
    item: scheduledClass,
    canDrag: !!scheduledClass && !isBeforeStartDate,
    collect: (monitor) => ({
      isDragging: monitor.isDragging()
    })
  }), [scheduledClass, isBeforeStartDate])

  // Drop configuration for receiving classes
  const [{ isOver, canDrop }, drop] = useDrop(() => ({
    accept: 'scheduledClass',
    canDrop: () => !isBeforeStartDate && !isBlackout,
    drop: (item: ScheduledClass) => {
      onClassDrop?.(item.id, period, date)
    },
    collect: (monitor) => ({
      isOver: monitor.isOver(),
      canDrop: monitor.canDrop()
    })
  }), [period, date, isBeforeStartDate, isBlackout])

  // Get background color based on state
  const getBgColor = () => {
    if (isBlackout) return 'bg-destructive/10 hover:bg-destructive/20'
    if (isDragging) return 'bg-primary/50'
    if (isOver && canDrop) return 'bg-primary/20'
    if (scheduledClass) {
      // Color based on constraint satisfaction
      const alpha = Math.max(0.3, constraintSatisfaction)
      return `bg-primary hover:bg-primary/90 bg-opacity-${Math.floor(alpha * 100)}`
    }
    return 'bg-secondary/20 hover:bg-secondary/30'
  }

  const cell = (
    <div
      ref={drop}
      className={`
        p-3 rounded-md cursor-pointer transition-colors
        ${getBgColor()}
        ${isDragging ? 'opacity-50' : ''}
        ${isOver && canDrop ? 'ring-2 ring-primary' : ''}
        ${scheduledClass ? 'text-primary-foreground' : 'text-secondary-foreground'}
      `}
      onClick={() => {
        if (scheduledClass && onClassClick) {
          onClassClick(scheduledClass)
        } else if (onPeriodClick) {
          onPeriodClick(period, date)
        }
      }}
    >
      <div className="text-sm font-medium">Period {period}</div>
      {scheduledClass && (
        <div ref={drag} className="mt-2 space-y-1">
          <div className="text-sm font-medium">
            Class {scheduledClass.classNumber}
          </div>
          <div className="text-xs">
            {scheduledClass.teacher}
          </div>
          <div className="text-xs">
            {scheduledClass.gradeLevel === 'mixed'
              ? 'Mixed Grades'
              : `Grade ${scheduledClass.gradeLevel}`}
          </div>
          {constraintSatisfaction < 1 && (
            <div className="text-xs text-destructive-foreground bg-destructive/20 px-1.5 py-0.5 rounded">
              {Math.floor(constraintSatisfaction * 100)}% optimal
            </div>
          )}
        </div>
      )}
    </div>
  )

  // Add tooltip if there are constraint issues
  if (scheduledClass && constraintSatisfaction < 1) {
    return (
      <Tooltip 
        content={
          <div className="space-y-1">
            <div className="font-medium">Constraint Issues</div>
            <div className="text-sm">This class placement has some constraint violations.</div>
            <div className="text-sm text-destructive-foreground">
              {Math.floor((1 - constraintSatisfaction) * 100)}% suboptimal
            </div>
          </div>
        }
      >
        {cell}
      </Tooltip>
    )
  }

  return cell
}

================
File: src/components/schedule/ScheduleHeader.tsx
================
import { WeekSchedule } from '../../types'
import { Button } from '../ui/button'

interface ScheduleHeaderProps {
  currentWeek: number
  totalWeeks: number
  displayedWeek: WeekSchedule
  onWeekChange: (week: number) => void
  onViewChange: (view: 'week' | 'month') => void
  view: 'week' | 'month'
}

export function ScheduleHeader({
  currentWeek,
  totalWeeks,
  displayedWeek,
  onWeekChange,
  onViewChange,
  view
}: ScheduleHeaderProps) {
  const dateFormat = new Intl.DateTimeFormat('en-US', {
    month: 'long',
    day: 'numeric',
    year: 'numeric'
  })

  const startDate = displayedWeek.startDate
  const endDate = new Date(startDate)
  endDate.setDate(endDate.getDate() + 4) // Show Monday-Friday

  return (
    <div className="flex items-center justify-between bg-card p-4 rounded-lg">
      <div className="flex items-center space-x-4">
        <Button
          variant="outline"
          onClick={() => onWeekChange(Math.max(0, currentWeek - 1))}
          disabled={currentWeek === 0}
        >
          Previous
        </Button>
        <Button
          variant="outline"
          onClick={() => onWeekChange(Math.min(totalWeeks - 1, currentWeek + 1))}
          disabled={currentWeek === totalWeeks - 1}
        >
          Next
        </Button>
      </div>
      
      <div className="text-lg font-semibold">
        {view === 'week' ? (
          `${dateFormat.format(startDate)} - ${dateFormat.format(endDate)}`
        ) : (
          dateFormat.format(startDate)
        )}
      </div>
      <div className="flex items-center space-x-2">
        <Button
          variant="outline"
          onClick={() => onViewChange('week')}
          className={view === 'week' ? 'bg-primary text-primary-foreground' : ''}
        >
          Week
        </Button>
        <Button
          variant="outline"
          onClick={() => onViewChange('month')}
          className={view === 'month' ? 'bg-primary text-primary-foreground' : ''}
        >
          Month
        </Button>
      </div>
    </div>
  )
}

================
File: src/components/ui/Button.tsx
================
import { ButtonHTMLAttributes, forwardRef } from 'react'

export interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'destructive'
  size?: 'sm' | 'md' | 'lg'
  fullWidth?: boolean
}

const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className = '', variant = 'primary', size = 'md', fullWidth = false, children, ...props }, ref) => {
    const baseClasses = 'btn'
    const variantClasses = {
      primary: 'btn-primary',
      secondary: 'btn-secondary',
      destructive: 'btn-destructive'
    }[variant]

    const sizeClasses = {
      sm: 'px-3 py-1.5 text-sm',
      md: 'px-4 py-2 text-base',
      lg: 'px-6 py-3 text-lg'
    }[size]

    const widthClass = fullWidth ? 'w-full' : ''

    const combinedClasses = `${baseClasses} ${variantClasses} ${sizeClasses} ${widthClass} ${className}`

    return (
      <button
        ref={ref}
        className={combinedClasses}
        {...props}
      >
        {children}
      </button>
    )
  }
)

Button.displayName = 'Button'

export { Button }

================
File: src/components/ui/Card.tsx
================
import { ReactNode } from 'react'

interface CardProps {
  title?: string
  children: ReactNode
  className?: string
}

export function Card({ title, children, className = '' }: CardProps) {
  return (
    <div className={`bg-card text-card-foreground rounded-lg shadow-sm p-6 ${className}`}>
      {title && (
        <h2 className="text-xl font-semibold text-card-foreground mb-4">
          {title}
        </h2>
      )}
      {children}
    </div>
  )
}

================
File: src/components/ui/dropdown-menu.tsx
================
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={`
        z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md
        data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2
        ${className}
      `}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={`
      relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50
      ${className}
    `}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
}

================
File: src/components/ui/Tooltip.tsx
================
import { ReactNode } from 'react'
import * as TooltipPrimitive from '@radix-ui/react-tooltip'

interface TooltipProps {
  children: ReactNode
  content: ReactNode
  side?: 'top' | 'right' | 'bottom' | 'left'
  align?: 'start' | 'center' | 'end'
}

export function Tooltip({ 
  children, 
  content,
  side = 'top',
  align = 'center'
}: TooltipProps) {
  return (
    <TooltipPrimitive.Provider>
      <TooltipPrimitive.Root>
        <TooltipPrimitive.Trigger asChild>
          {children}
        </TooltipPrimitive.Trigger>
        <TooltipPrimitive.Portal>
          <TooltipPrimitive.Content
            side={side}
            align={align}
            sideOffset={4}
            className="
              z-50 overflow-hidden rounded-md 
              bg-popover px-3 py-2 text-sm text-popover-foreground 
              shadow-md animate-in fade-in-0 zoom-in-95
              data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95
              data-[side=bottom]:slide-in-from-top-2 
              data-[side=left]:slide-in-from-right-2 
              data-[side=right]:slide-in-from-left-2 
              data-[side=top]:slide-in-from-bottom-2
            "
          >
            {content}
          </TooltipPrimitive.Content>
        </TooltipPrimitive.Portal>
      </TooltipPrimitive.Root>
    </TooltipPrimitive.Provider>
  )
}

================
File: src/components/ClassForm.tsx
================
import { useState, useEffect } from 'react'
import { Class, DayConflicts } from '../types'

interface ClassFormProps {
  onSubmit: (classData: Class) => void
  onCancel?: () => void
  initialClass?: Class | null
}

interface JsonClass {
  class: string
  teacher: string
  grade: string
  days: {
    [key: string]: number[]
  }
}

const DAYS = [
  { name: 'Monday', number: 1 },
  { name: 'Tuesday', number: 2 },
  { name: 'Wednesday', number: 3 },
  { name: 'Thursday', number: 4 },
  { name: 'Friday', number: 5 }
]

const PERIODS = Array.from({ length: 8 }, (_, i) => i + 1)

export function ClassForm({ onSubmit, onCancel, initialClass }: ClassFormProps) {
  const [classNumber, setClassNumber] = useState(initialClass?.classNumber || '')
  const [teacher, setTeacher] = useState(initialClass?.teacher || '')
  const [gradeLevel, setGradeLevel] = useState(initialClass?.gradeLevel || '5th')
  const [totalConflicts, setTotalConflicts] = useState<DayConflicts[]>(
    initialClass?.totalConflicts || 
    DAYS.map(day => ({ dayOfWeek: day.number, periods: [] }))
  )
  const [partialConflicts, setPartialConflicts] = useState<DayConflicts[]>(
    initialClass?.partialConflicts || 
    DAYS.map(day => ({ dayOfWeek: day.number, periods: [] }))
  )
  const [uploadedClasses, setUploadedClasses] = useState<JsonClass[]>([])
  const [currentClassIndex, setCurrentClassIndex] = useState<number>(-1)

  // Update form state when initialClass changes
  useEffect(() => {
    if (initialClass) {
      setClassNumber(initialClass.classNumber)
      setTeacher(initialClass.teacher)
      setGradeLevel(initialClass.gradeLevel)
      setTotalConflicts(initialClass.totalConflicts)
      setPartialConflicts(initialClass.partialConflicts)
    } else {
      // Reset form when initialClass becomes null
      setClassNumber('')
      setTeacher('')
      setGradeLevel('5th')
      setTotalConflicts(DAYS.map(day => ({ dayOfWeek: day.number, periods: [] })))
      setPartialConflicts(DAYS.map(day => ({ dayOfWeek: day.number, periods: [] })))
    }
  }, [initialClass])

  const gradeLevels = ['Pre-K', 'K', '1st', '2nd', '3rd', '4th', '5th', 'mixed']

  const gradeMap: { [key: string]: string } = {
    "Pre-K": "Pre-K",
    "K": "K",
    "1st Grade": "1st",
    "2nd Grade": "2nd",
    "3rd Grade": "3rd",
    "4th Grade": "4th",
    "5th Grade": "5th"
  }

  const loadClassData = (classData: JsonClass) => {
    setClassNumber(classData.class)
    setTeacher(classData.teacher)
    setGradeLevel(gradeMap[classData.grade] || classData.grade)

    const newTotalConflicts = DAYS.map(day => {
      const periods = classData.days[day.name] || []
      return {
        dayOfWeek: day.number,
        periods: periods
      }
    })
    setTotalConflicts(newTotalConflicts)
    setPartialConflicts(DAYS.map(day => ({ dayOfWeek: day.number, periods: [] })))
  }

  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0]
    if (!file) return

    const reader = new FileReader()
    reader.onload = (e) => {
      try {
        const jsonData = JSON.parse(e.target?.result as string)
        console.log('Parsed JSON data:', jsonData) // Debug log
        
        const classes = jsonData.schedule as JsonClass[]
        if (!classes?.length) {
          alert('No classes found in the JSON file. Make sure it has a "schedule" array.')
          return
        }
        
        console.log(`Found ${classes.length} classes in JSON`) // Debug log
        setUploadedClasses(classes)
        setCurrentClassIndex(0)
        loadClassData(classes[0])

        // Offer to submit all classes at once
        if (classes.length > 1) {
          const submitAll = window.confirm(
            `Found ${classes.length} classes. Would you like to add them all at once? ` +
            `Click OK to add all classes, or Cancel to add them one by one.`
          )
          if (submitAll) {
            handleSubmitAll()
          }
        }
      } catch (error) {
        console.error('Error parsing JSON file:', error)
        alert('Error parsing JSON file. Please make sure the file format is correct and contains a "schedule" array.')
      }
    }
    reader.readAsText(file)
  }

  const handleSubmitAll = () => {
    if (!uploadedClasses.length) return
    
    console.log(`Submitting all ${uploadedClasses.length} classes`) // Debug log
    uploadedClasses.forEach(classData => {
      const newTotalConflicts = DAYS.map(day => ({
        dayOfWeek: day.number,
        periods: classData.days[day.name] || []
      }))

      const newClass: Class = {
        id: Math.random().toString(36).substring(2),
        classNumber: classData.class,
        teacher: classData.teacher,
        gradeLevel: gradeMap[classData.grade] || classData.grade,
        totalConflicts: newTotalConflicts,
        partialConflicts: DAYS.map(day => ({ dayOfWeek: day.number, periods: [] }))
      }

      onSubmit(newClass)
    })

    // Reset form after submitting all
    setClassNumber('')
    setTeacher('')
    setGradeLevel('5th')
    setTotalConflicts(DAYS.map(day => ({ dayOfWeek: day.number, periods: [] })))
    setPartialConflicts(DAYS.map(day => ({ dayOfWeek: day.number, periods: [] })))
    setUploadedClasses([])
    setCurrentClassIndex(-1)
  }

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()

    const classData: Class = {
      id: initialClass?.id || Math.random().toString(36).substring(2),
      classNumber,
      teacher,
      gradeLevel,
      totalConflicts,
      partialConflicts
    }

    onSubmit(classData)

    if (currentClassIndex >= 0 && currentClassIndex < uploadedClasses.length - 1) {
      // Load next class
      setCurrentClassIndex(prev => prev + 1)
      loadClassData(uploadedClasses[currentClassIndex + 1])
    } else {
      // Reset form
      setClassNumber('')
      setTeacher('')
      setGradeLevel('5th')
      setTotalConflicts(DAYS.map(day => ({ dayOfWeek: day.number, periods: [] })))
      setPartialConflicts(DAYS.map(day => ({ dayOfWeek: day.number, periods: [] })))
      setUploadedClasses([])
      setCurrentClassIndex(-1)
    }
  }

  const togglePeriod = (dayOfWeek: number, period: number, type: 'total' | 'partial') => {
    if (type === 'total') {
      setTotalConflicts(prev => {
        const dayConflicts = prev.find(d => d.dayOfWeek === dayOfWeek)
        if (!dayConflicts) return prev

        const newPeriods = dayConflicts.periods.includes(period)
          ? dayConflicts.periods.filter(p => p !== period)
          : [...dayConflicts.periods, period]

        return prev.map(d =>
          d.dayOfWeek === dayOfWeek ? { ...d, periods: newPeriods } : d
        )
      })
      // Remove from partial conflicts if it exists
      setPartialConflicts(prev => {
        const dayConflicts = prev.find(d => d.dayOfWeek === dayOfWeek)
        if (!dayConflicts) return prev

        return prev.map(d =>
          d.dayOfWeek === dayOfWeek
            ? { ...d, periods: d.periods.filter(p => p !== period) }
            : d
        )
      })
    } else {
      setPartialConflicts(prev => {
        const dayConflicts = prev.find(d => d.dayOfWeek === dayOfWeek)
        if (!dayConflicts) return prev

        const newPeriods = dayConflicts.periods.includes(period)
          ? dayConflicts.periods.filter(p => p !== period)
          : [...dayConflicts.periods, period]

        return prev.map(d =>
          d.dayOfWeek === dayOfWeek ? { ...d, periods: newPeriods } : d
        )
      })
      // Remove from total conflicts if it exists
      setTotalConflicts(prev => {
        const dayConflicts = prev.find(d => d.dayOfWeek === dayOfWeek)
        if (!dayConflicts) return prev

        return prev.map(d =>
          d.dayOfWeek === dayOfWeek
            ? { ...d, periods: d.periods.filter(p => p !== period) }
            : d
        )
      })
    }
  }

  const toggleEntireDay = (dayOfWeek: number, type: 'total' | 'partial') => {
    const conflicts = type === 'total' ? totalConflicts : partialConflicts
    const dayConflicts = conflicts.find(d => d.dayOfWeek === dayOfWeek)
    const hasAllPeriods = dayConflicts && dayConflicts.periods.length === PERIODS.length

    if (type === 'total') {
      setTotalConflicts(prev => {
        return prev.map(d =>
          d.dayOfWeek === dayOfWeek
            ? { ...d, periods: hasAllPeriods ? [] : PERIODS }
            : d
        )
      })
      // Remove from partial conflicts if adding all periods
      if (!hasAllPeriods) {
        setPartialConflicts(prev => {
          return prev.map(d =>
            d.dayOfWeek === dayOfWeek ? { ...d, periods: [] } : d
          )
        })
      }
    } else {
      setPartialConflicts(prev => {
        return prev.map(d =>
          d.dayOfWeek === dayOfWeek
            ? { ...d, periods: hasAllPeriods ? [] : PERIODS }
            : d
        )
      })
      // Remove from total conflicts if adding all periods
      if (!hasAllPeriods) {
        setTotalConflicts(prev => {
          return prev.map(d =>
            d.dayOfWeek === dayOfWeek ? { ...d, periods: [] } : d
          )
        })
      }
    }
  }

  const togglePeriodAllDays = (period: number, type: 'total' | 'partial') => {
    const conflicts = type === 'total' ? totalConflicts : partialConflicts
    const allDaysHavePeriod = DAYS.every(day => 
      conflicts.find(d => d.dayOfWeek === day.number)?.periods.includes(period)
    )

    if (type === 'total') {
      setTotalConflicts(prev => {
        return prev.map(d => ({
          ...d,
          periods: allDaysHavePeriod
            ? d.periods.filter(p => p !== period)
            : [...new Set([...d.periods, period])]
        }))
      })
      // Remove from partial conflicts if adding
      if (!allDaysHavePeriod) {
        setPartialConflicts(prev => {
          return prev.map(d => ({
            ...d,
            periods: d.periods.filter(p => p !== period)
          }))
        })
      }
    } else {
      setPartialConflicts(prev => {
        return prev.map(d => ({
          ...d,
          periods: allDaysHavePeriod
            ? d.periods.filter(p => p !== period)
            : [...new Set([...d.periods, period])]
        }))
      })
      // Remove from total conflicts if adding
      if (!allDaysHavePeriod) {
        setTotalConflicts(prev => {
          return prev.map(d => ({
            ...d,
            periods: d.periods.filter(p => p !== period)
          }))
        })
      }
    }
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <div className="space-y-4">
        <div className="flex items-center gap-4">
          <div className="flex-1">
            <label className="block text-sm font-medium mb-1">Class Number</label>
            <input
              type="text"
              value={classNumber}
              onChange={e => setClassNumber(e.target.value)}
              className="w-full p-2 border rounded-md"
              required
            />
          </div>
          <div className="flex-1">
            <label className="block text-sm font-medium mb-1">Teacher</label>
            <input
              type="text"
              value={teacher}
              onChange={e => setTeacher(e.target.value)}
              className="w-full p-2 border rounded-md"
              required
            />
          </div>
          <div className="flex-1">
            <label className="block text-sm font-medium mb-1">Grade Level</label>
            <select
              value={gradeLevel}
              onChange={e => setGradeLevel(e.target.value)}
              className="w-full p-2 border rounded-md"
            >
              {gradeLevels.map(grade => (
                <option key={grade} value={grade}>
                  {grade}
                </option>
              ))}
            </select>
          </div>
        </div>

        <div className="mb-4">
          <label className="block text-sm font-medium mb-2">Import from JSON</label>
          <input
            type="file"
            accept=".json"
            onChange={handleFileUpload}
            className="w-full p-2 border rounded-md bg-white"
          />
          {uploadedClasses.length > 0 && (
            <div className="mt-2 space-y-2">
              <p className="text-sm text-muted-foreground">
                Loaded {uploadedClasses.length} classes. Currently viewing class {currentClassIndex + 1}.
              </p>
              <div className="flex gap-2">
                <button
                  type="button"
                  onClick={() => {
                    if (currentClassIndex > 0) {
                      setCurrentClassIndex(prev => prev - 1)
                      loadClassData(uploadedClasses[currentClassIndex - 1])
                    }
                  }}
                  disabled={currentClassIndex <= 0}
                  className="px-2 py-1 text-sm bg-secondary text-secondary-foreground rounded-md hover:bg-secondary/90 disabled:opacity-50"
                >
                  Previous Class
                </button>
                <button
                  type="button"
                  onClick={() => {
                    if (currentClassIndex < uploadedClasses.length - 1) {
                      setCurrentClassIndex(prev => prev + 1)
                      loadClassData(uploadedClasses[currentClassIndex + 1])
                    }
                  }}
                  disabled={currentClassIndex >= uploadedClasses.length - 1}
                  className="px-2 py-1 text-sm bg-secondary text-secondary-foreground rounded-md hover:bg-secondary/90 disabled:opacity-50"
                >
                  Next Class
                </button>
                <button
                  type="button"
                  onClick={handleSubmitAll}
                  className="px-2 py-1 text-sm bg-primary text-primary-foreground rounded-md hover:bg-primary/90"
                >
                  Submit All Classes
                </button>
              </div>
            </div>
          )}
        </div>

        <div>
          <label className="block text-sm font-medium text-foreground mb-4">
            Period Conflicts
          </label>
          <div className="grid grid-cols-6 gap-3">
            <div className="w-16">
              <div className="h-8"></div>
              {PERIODS.map(period => (
                <button
                  key={period}
                  type="button"
                  onClick={() => togglePeriodAllDays(period, 'total')}
                  className="px-1.5 py-1 mb-0.5 text-xs rounded bg-muted/50 text-muted-foreground hover:bg-muted/60 w-full"
                >
                  All P{period}
                </button>
              ))}
            </div>
            {DAYS.map(day => (
              <div key={day.number} className="space-y-1">
                <div className="flex justify-between items-center h-8">
                  <div className="font-medium text-sm">{day.name}</div>
                  <button
                    type="button"
                    onClick={() => toggleEntireDay(day.number, 'total')}
                    className="text-xs px-1.5 py-0.5 rounded bg-muted/50 text-muted-foreground hover:bg-muted/60"
                  >
                    All Day
                  </button>
                </div>
                <div className="space-y-0.5">
                  {PERIODS.map(period => {
                    const dayConflicts = totalConflicts.find(d => d.dayOfWeek === day.number)
                    const isConflict = dayConflicts?.periods.includes(period) || false
                    return (
                      <div
                        key={period}
                        onClick={() => togglePeriod(day.number, period, 'total')}
                        className={`px-2 py-1 rounded-md text-xs cursor-pointer ${
                          isConflict
                            ? 'bg-destructive/20 text-destructive-foreground hover:bg-destructive/30'
                            : 'bg-muted/50 text-muted-foreground hover:bg-muted/60'
                        }`}
                      >
                        P{period}
                      </div>
                    )
                  })}
                </div>
              </div>
            ))}
          </div>
        </div>
      </div>

      <div className="flex justify-end gap-2">
        {onCancel && (
          <button
            type="button"
            onClick={onCancel}
            className="px-4 py-2 text-sm bg-secondary text-secondary-foreground rounded-md hover:bg-secondary/90"
          >
            Cancel
          </button>
        )}
        <button
          type="submit"
          className="px-4 py-2 text-sm bg-primary text-primary-foreground rounded-md hover:bg-primary/90"
        >
          {initialClass ? 'Save Changes' : 'Add Class'}
        </button>
      </div>
    </form>
  )
}

================
File: src/components/GradeGroupBuilder.tsx
================
import { useState } from 'react'
import { GradeGroup, Class } from '../types'

const STANDARD_GRADES = ['Pre-K', 'K', '1st', '2nd', '3rd', '4th', '5th']

export interface GradeGroupBuilderProps {
  gradeGroups: GradeGroup[]
  onChange: (groups: GradeGroup[]) => void
  availableGrades: string[]
}

export function GradeGroupBuilder({
  gradeGroups,
  onChange,
  availableGrades
}: GradeGroupBuilderProps) {
  const [selectedGrades, setSelectedGrades] = useState<string[]>([])
  const [newGroupName, setNewGroupName] = useState('')

  const unusedGrades = availableGrades.filter(
    grade => !gradeGroups.some(group => group.grades.includes(grade))
  )

  const handleCreateGroup = () => {
    if (selectedGrades.length > 0) {
      const newGroup: GradeGroup = {
        id: Math.random().toString(36).substring(2),
        name: newGroupName || selectedGrades.join(' + '),
        grades: selectedGrades
      }
      onChange([...gradeGroups, newGroup])
      setSelectedGrades([])
      setNewGroupName('')
    }
  }

  const handleDeleteGroup = (groupId: string) => {
    onChange(gradeGroups.filter(group => group.id !== groupId))
  }

  const handleGradeToggle = (grade: string) => {
    setSelectedGrades(prev =>
      prev.includes(grade)
        ? prev.filter(g => g !== grade)
        : [...prev, grade]
    )
  }

  const handleUpdateGroupName = (groupId: string, newName: string) => {
    onChange(
      gradeGroups.map(group =>
        group.id === groupId
          ? { ...group, name: newName || group.grades.join(' + ') }
          : group
      )
    )
  }

  return (
    <div className="space-y-6">
      {/* Available Grades Pool */}
      <div className="space-y-2">
        <label className="block text-sm font-medium text-foreground">
          Available Grade Levels
        </label>
        <div className="flex flex-wrap gap-2 p-4 bg-muted rounded-lg min-h-[60px]">
          {unusedGrades.map(grade => (
            <button
              key={grade}
              onClick={() => handleGradeToggle(grade)}
              className={`px-3 py-1 rounded-md text-sm font-medium transition-colors ${
                selectedGrades.includes(grade)
                  ? 'bg-primary text-primary-foreground'
                  : 'bg-card text-card-foreground hover:bg-card/80'
              }`}
            >
              {grade}
            </button>
          ))}
          {unusedGrades.length === 0 && (
            <p className="text-sm text-muted-foreground">
              All grades have been grouped
            </p>
          )}
        </div>
      </div>

      {/* Create Group Button */}
      {selectedGrades.length > 0 && (
        <div className="space-y-4">
          <div className="flex items-center gap-4">
            <div className="flex-1">
              <p className="text-sm font-medium text-foreground mb-2">
                Selected: {selectedGrades.join(' + ')}
              </p>
              <input
                type="text"
                value={newGroupName}
                onChange={(e) => setNewGroupName(e.target.value)}
                placeholder="Group Name (optional)"
                className="w-full px-3 py-2 text-sm rounded-md border border-input bg-background"
              />
            </div>
            <button
              onClick={handleCreateGroup}
              className="px-4 py-2 bg-primary text-primary-foreground rounded-md hover:bg-primary/90 transition-colors"
            >
              Create Group
            </button>
          </div>
        </div>
      )}

      {/* Existing Groups */}
      {gradeGroups.length > 0 && (
        <div className="space-y-2">
          <label className="block text-sm font-medium text-foreground">
            Grade Groups
          </label>
          <div className="space-y-2">
            {gradeGroups.map(group => (
              <div
                key={group.id}
                className="flex items-center justify-between p-3 bg-card rounded-lg"
              >
                <div className="flex-1 space-y-1">
                  <input
                    type="text"
                    value={group.name}
                    onChange={(e) => handleUpdateGroupName(group.id, e.target.value)}
                    className="bg-transparent border-none p-0 font-medium focus:outline-none focus:ring-0 w-full"
                    placeholder={group.grades.join(' + ')}
                  />
                  <div className="flex flex-wrap gap-1 mt-1">
                    {group.grades.map(grade => (
                      <span
                        key={grade}
                        className="px-2 py-0.5 bg-muted rounded text-xs"
                      >
                        {grade}
                      </span>
                    ))}
                  </div>
                </div>
                <button
                  onClick={() => handleDeleteGroup(group.id)}
                  className="ml-2 p-1 text-destructive hover:text-destructive/80"
                >
                  Delete
                </button>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  )
}

================
File: src/components/ScheduleConstraints.tsx
================
import { useState } from 'react'
import { GradeGroupBuilder } from './GradeGroupBuilder'
import { Card } from './ui/Card'
import { Button } from './ui/Button'
import { 
  ScheduleConstraints, 
  SchedulePreferences, 
  Class, 
  GradeProgressionPreference,
  MaxConsecutivePeriods,
  ConsecutiveBreakLength
} from '../types'

const DEFAULT_CONSTRAINTS: ScheduleConstraints = {
  maxPeriodsPerDay: 8,
  maxPeriodsPerWeek: 40,
  consecutivePeriods: {
    maximum: 2,
    requireBreak: 1
  }
}

interface ScheduleConstraintsFormProps {
  initialConstraints: ScheduleConstraints
  initialPreferences: SchedulePreferences
  initialStartDate: Date
  classes: Class[]
  onSubmit: (data: {
    constraints: ScheduleConstraints
    preferences: SchedulePreferences
    startDate: Date
  }) => void
}

export function ScheduleConstraintsForm({
  initialConstraints,
  initialPreferences,
  initialStartDate,
  classes,
  onSubmit
}: ScheduleConstraintsFormProps) {
  // Constraint state
  const [maxPeriodsPerDay, setMaxPeriodsPerDay] = useState(
    initialConstraints.maxPeriodsPerDay || DEFAULT_CONSTRAINTS.maxPeriodsPerDay
  )
  const [maxPeriodsPerWeek, setMaxPeriodsPerWeek] = useState(
    initialConstraints.maxPeriodsPerWeek || DEFAULT_CONSTRAINTS.maxPeriodsPerWeek
  )
  const [maxConsecutivePeriods, setMaxConsecutivePeriods] = useState<MaxConsecutivePeriods>(
    initialConstraints.consecutivePeriods.maximum || DEFAULT_CONSTRAINTS.consecutivePeriods.maximum
  )
  const [requiredBreak, setRequiredBreak] = useState<ConsecutiveBreakLength>(
    initialConstraints.consecutivePeriods.requireBreak || DEFAULT_CONSTRAINTS.consecutivePeriods.requireBreak
  )

  // Preference state
  const [startDate, setStartDate] = useState(initialStartDate)
  const [gradeGroups, setGradeGroups] = useState(initialPreferences.gradeGroups)
  const [preferSameGradeInDay, setPreferSameGradeInDay] = useState(
    initialPreferences.preferSameGradeInDay
  )
  const [gradeProgression, setGradeProgression] = useState<GradeProgressionPreference>(
    initialPreferences.gradeProgression
  )

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    onSubmit({
      constraints: {
        maxPeriodsPerDay,
        maxPeriodsPerWeek,
        consecutivePeriods: {
          maximum: maxConsecutivePeriods,
          requireBreak: requiredBreak
        }
      },
      preferences: {
        gradeGroups,
        preferSameGradeInDay,
        gradeProgression
      },
      startDate
    })
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-8">
      <Card>
        <h2 className="text-lg font-semibold mb-4">Schedule Constraints</h2>
        
        {/* Basic constraints */}
        <div className="space-y-4 mb-6">
          <div>
            <label className="block text-sm font-medium mb-1">
              Maximum Periods Per Day
            </label>
            <input
              type="number"
              min="1"
              max="8"
              value={maxPeriodsPerDay}
              onChange={(e) => setMaxPeriodsPerDay(parseInt(e.target.value))}
              className="w-20 px-2 py-1 border rounded"
            />
          </div>

          <div>
            <label className="block text-sm font-medium mb-1">
              Maximum Periods Per Week
            </label>
            <input
              type="number"
              min="1"
              max="40"
              value={maxPeriodsPerWeek}
              onChange={(e) => setMaxPeriodsPerWeek(parseInt(e.target.value))}
              className="w-20 px-2 py-1 border rounded"
            />
          </div>
        </div>

        {/* Consecutive period settings */}
        <div className="space-y-4 mb-6">
          <h3 className="text-md font-medium">Consecutive Period Rules</h3>
          
          <div>
            <label className="block text-sm font-medium mb-2">
              Maximum Consecutive Periods
            </label>
            <div className="space-x-4">
              <label className="inline-flex items-center">
                <input
                  type="radio"
                  name="maxConsecutive"
                  value="1"
                  checked={maxConsecutivePeriods === 1}
                  onChange={() => setMaxConsecutivePeriods(1)}
                  className="mr-2"
                />
                <span>No consecutive periods</span>
              </label>
              <label className="inline-flex items-center">
                <input
                  type="radio"
                  name="maxConsecutive"
                  value="2"
                  checked={maxConsecutivePeriods === 2}
                  onChange={() => setMaxConsecutivePeriods(2)}
                  className="mr-2"
                />
                <span>Allow two consecutive periods</span>
              </label>
            </div>
          </div>

          <div>
            <label className="block text-sm font-medium mb-2">
              Required Break After Consecutive Periods
            </label>
            <div className="space-x-4">
              <label className="inline-flex items-center">
                <input
                  type="radio"
                  name="requiredBreak"
                  value="1"
                  checked={requiredBreak === 1}
                  onChange={() => setRequiredBreak(1)}
                  className="mr-2"
                />
                <span>One period break</span>
              </label>
              <label className="inline-flex items-center">
                <input
                  type="radio"
                  name="requiredBreak"
                  value="2"
                  checked={requiredBreak === 2}
                  onChange={() => setRequiredBreak(2)}
                  className="mr-2"
                />
                <span>Two period break</span>
              </label>
            </div>
          </div>
        </div>
      </Card>

      <Card>
        <h2 className="text-lg font-semibold mb-4">Schedule Preferences</h2>
        
        {/* Grade progression */}
        <div className="space-y-4 mb-6">
          <label className="block text-sm font-medium mb-2">
            Grade Progression Preference
          </label>
          <select
            value={gradeProgression}
            onChange={(e) => setGradeProgression(e.target.value as GradeProgressionPreference)}
            className="w-full px-2 py-1 border rounded"
          >
            <option value="none">No preference</option>
            <option value="high-to-low">Schedule higher grades first</option>
            <option value="low-to-high">Schedule lower grades first</option>
          </select>
        </div>

        {/* Same grade in day preference */}
        <div className="mb-6">
          <label className="inline-flex items-center">
            <input
              type="checkbox"
              checked={preferSameGradeInDay}
              onChange={(e) => setPreferSameGradeInDay(e.target.checked)}
              className="mr-2"
            />
            <span>Prefer scheduling same grade levels on the same day</span>
          </label>
        </div>

        {/* Grade groups */}
        <div className="mb-6">
          <h3 className="text-md font-medium mb-2">Grade Groups</h3>
          <GradeGroupBuilder
            gradeGroups={gradeGroups}
            onChange={setGradeGroups}
            availableGrades={Array.from(new Set(classes.map(c => c.gradeLevel)))}
          />
        </div>
      </Card>

      <Card>
        <h2 className="text-lg font-semibold mb-4">Schedule Timing</h2>
        
        <div>
          <label className="block text-sm font-medium mb-1">
            Start Date
          </label>
          <input
            type="date"
            value={startDate.toISOString().split('T')[0]}
            onChange={(e) => setStartDate(new Date(e.target.value))}
            className="w-full px-2 py-1 border rounded"
          />
        </div>
      </Card>

      <div className="flex justify-end">
        <Button type="submit">
          Save Schedule Settings
        </Button>
      </div>
    </form>
  )
}

================
File: src/components/ScheduleDisplay.tsx
================
import { useEffect, useState } from 'react'
import { DndProvider } from 'react-dnd'
import { HTML5Backend } from 'react-dnd-html5-backend'
import { Schedule, ScheduledClass, WeekSchedule, BlackoutPeriod } from '../types'
import { scheduleUtils } from '../utils/schedule'
import { ScheduleCell } from './schedule/ScheduleCell'
import { ScheduleHeader } from './schedule/ScheduleHeader'
import { MonthView } from './schedule/MonthView'
import { ExportButton } from './schedule/ExportButton'
import { Button } from './ui/button'

interface ScheduleDisplayProps {
  schedule?: Schedule
  startDate: Date
  blackoutPeriods: BlackoutPeriod[]
  onBlackoutChange: (blackoutPeriods: BlackoutPeriod[]) => void
  onClassClick?: (scheduledClass: ScheduledClass) => void
  onClassMove?: (classId: string, newPeriod: number, newDate: Date) => void
}

const PERIODS = Array.from({ length: 8 }, (_, i) => i + 1)

export function ScheduleDisplay({ 
  schedule,
  startDate,
  blackoutPeriods,
  onBlackoutChange,
  onClassClick,
  onClassMove
}: ScheduleDisplayProps) {
  const [weekSchedules, setWeekSchedules] = useState<WeekSchedule[]>([])
  const [currentWeek, setCurrentWeek] = useState(0)
  const [previewWeeks, setPreviewWeeks] = useState<WeekSchedule[]>([])
  const [view, setView] = useState<'week' | 'month'>('week')

  useEffect(() => {
    if (!schedule) {
      const weeks: WeekSchedule[] = []
      let currentDate = new Date(startDate)
      currentDate.setHours(0, 0, 0, 0)

      // Always start from Monday of the week containing the start date
      const monday = new Date(currentDate)
      const dayOfWeek = monday.getDay()
      if (dayOfWeek !== 1) { // If not Monday
        monday.setDate(monday.getDate() - (dayOfWeek - 1))
      }
      currentDate = monday

      // Generate 6 weeks of schedule
      for (let i = 0; i < 6; i++) {
        weeks.push(
          scheduleUtils.getWeekSchedule(
            currentDate,
            [],
            blackoutPeriods,
            startDate
          )
        )
        // Move to next Monday
        const nextDate = new Date(currentDate)
        nextDate.setDate(nextDate.getDate() + 7)
        currentDate = nextDate
      }

      setPreviewWeeks(weeks)
    }
  }, [startDate, blackoutPeriods, schedule])

  useEffect(() => {
    if (schedule) {
      const weeks: WeekSchedule[] = []
      let currentDate = new Date(schedule.startDate)
      currentDate.setHours(0, 0, 0, 0)

      // Always start from Monday of the week containing the start date
      const monday = new Date(currentDate)
      const dayOfWeek = monday.getDay()
      if (dayOfWeek !== 1) { // If not Monday
        monday.setDate(monday.getDate() - (dayOfWeek - 1))
      }
      currentDate = monday

      // Generate weeks until we reach the end date
      while (currentDate <= schedule.endDate) {
        weeks.push(
          scheduleUtils.getWeekSchedule(
            currentDate,
            schedule.classes,
            blackoutPeriods,
            schedule.startDate
          )
        )
        // Move to next Monday
        const nextDate = new Date(currentDate)
        nextDate.setDate(nextDate.getDate() + 7)
        currentDate = nextDate
      }

      setWeekSchedules(weeks)
    }
  }, [schedule, blackoutPeriods])

  useEffect(() => {
    setCurrentWeek(0)
  }, [startDate, schedule])

  const handlePeriodClick = (period: number, date: Date) => {
    if (!schedule) {
      const dayOfWeek = date.getDay()
      const isCurrentlyBlackout = blackoutPeriods.some(
        bp => bp.dayOfWeek === dayOfWeek && 
             bp.period === period &&
             scheduleUtils.isSameDay(bp.date, date)
      )

      if (isCurrentlyBlackout) {
        onBlackoutChange(
          blackoutPeriods.filter(
            bp => !(
              bp.dayOfWeek === dayOfWeek && 
              bp.period === period &&
              scheduleUtils.isSameDay(bp.date, date)
            )
          )
        )
      } else {
        onBlackoutChange([
          ...blackoutPeriods, 
          { dayOfWeek, period, date: new Date(date) }
        ])
      }
    }
  }

  const handleDayBlackout = (dayOfWeek: number, date: Date) => {
    if (!schedule) {
      const isFullDayBlackout = Array.from({ length: 8 }, (_, i) => i + 1).every(
        period =>
          blackoutPeriods.some(
            bp => bp.dayOfWeek === dayOfWeek && 
                 bp.period === period &&
                 scheduleUtils.isSameDay(bp.date, date)
          )
      )

      if (isFullDayBlackout) {
        onBlackoutChange(
          blackoutPeriods.filter(bp => !(
            bp.dayOfWeek === dayOfWeek &&
            scheduleUtils.isSameDay(bp.date, date)
          ))
        )
      } else {
        const newBlackouts = [...blackoutPeriods]
        Array.from({ length: 8 }, (_, i) => i + 1).forEach(period => {
          if (!blackoutPeriods.some(
            bp => bp.dayOfWeek === dayOfWeek && 
                 bp.period === period &&
                 scheduleUtils.isSameDay(bp.date, date)
          )) {
            newBlackouts.push({ dayOfWeek, period, date: new Date(date) })
          }
        })
        onBlackoutChange(newBlackouts)
      }
    }
  }

  const handlePeriodAllDaysClick = (period: number) => {
    if (!schedule) {
      // Check if all days in the current week have this period blacked out
      const allDaysHavePeriod = displayedWeek.days.every(day => 
        blackoutPeriods.some(bp => 
          bp.dayOfWeek === day.date.getDay() && 
          bp.period === period &&
          scheduleUtils.isSameDay(bp.date, day.date)
        )
      );

      if (allDaysHavePeriod) {
        // Remove this period from all days in the current week
        const newBlackoutPeriods = blackoutPeriods.filter(bp => 
          !(bp.period === period && displayedWeek.days.some(day => 
            scheduleUtils.isSameDay(bp.date, day.date)
          ))
        );
        onBlackoutChange(newBlackoutPeriods);
      } else {
        // Add this period to all days in the current week
        const newBlackoutPeriods = [...blackoutPeriods];
        displayedWeek.days.forEach(day => {
          if (!blackoutPeriods.some(bp => 
            bp.dayOfWeek === day.date.getDay() && 
            bp.period === period &&
            scheduleUtils.isSameDay(bp.date, day.date)
          )) {
            newBlackoutPeriods.push({ 
              dayOfWeek: day.date.getDay(), 
              period,
              date: new Date(day.date)
            });
          }
        });
        onBlackoutChange(newBlackoutPeriods);
      }
    }
  };

  const displayedWeeks = schedule ? weekSchedules : previewWeeks
  if (displayedWeeks.length === 0) {
    return (
      <div className="text-center text-muted-foreground">
        Loading schedule preview...
      </div>
    )
  }

  const displayedWeek = displayedWeeks[currentWeek]

  return (
    <DndProvider backend={HTML5Backend}>
      <div className="space-y-4">
        {/* Navigation and Controls */}
        <div className="flex justify-between items-center">
          <div className="flex items-center space-x-4">
            <Button
              variant="outline"
              onClick={() => setView(view === 'week' ? 'month' : 'week')}
            >
              {view === 'week' ? 'Switch to Month' : 'Switch to Week'}
            </Button>
            {schedule && (
              <ExportButton
                schedule={schedule}
                startDate={displayedWeek.startDate}
                endDate={displayedWeek.endDate}
              />
            )}
          </div>
          <ScheduleHeader
            currentWeek={currentWeek}
            totalWeeks={displayedWeeks.length}
            displayedWeek={displayedWeek}
            onWeekChange={setCurrentWeek}
            onViewChange={setView}
            view={view}
          />
        </div>

        {/* Block/Clear Controls */}
        {!schedule && (
          <div className="flex gap-2">
            <Button
              variant="secondary"
              onClick={() => {
                const allPeriods: BlackoutPeriod[] = []
                for (let day = 1; day <= 5; day++) {
                  for (let period = 1; period <= 8; period++) {
                    allPeriods.push({ dayOfWeek: day, period })
                  }
                }
                onBlackoutChange(allPeriods)
              }}
            >
              Block All Periods
            </Button>
            <Button
              variant="secondary"
              onClick={() => onBlackoutChange([])}
            >
              Clear All Blocks
            </Button>
          </div>
        )}

        {/* Schedule View */}
        {view === 'week' ? (
          <div className="bg-card rounded-lg p-4">
            <div className="grid grid-cols-6 gap-3">
              {/* Period Labels */}
              <div className="w-16">
                <div className="h-8"></div>
                <div className="space-y-2">
                  {PERIODS.map(period => {
                    const allDaysBlackedOut = displayedWeek.days.every(day => 
                      blackoutPeriods.some(bp => 
                        bp.dayOfWeek === day.date.getDay() && 
                        bp.period === period &&
                        scheduleUtils.isSameDay(bp.date, day.date)
                      )
                    );
                    return (
                      <button
                        key={period}
                        type="button"
                        onClick={() => handlePeriodAllDaysClick(period)}
                        className={`p-3 w-full text-sm rounded-md ${
                          allDaysBlackedOut
                            ? 'bg-destructive/10 text-destructive hover:bg-destructive/20'
                            : 'bg-secondary/20 text-secondary-foreground hover:bg-secondary/30'
                        }`}
                      >
                        P{period}
                      </button>
                    );
                  })}
                </div>
              </div>

              {/* Days */}
              {displayedWeek.days.map((day, dayIndex) => {
                const isBeforeStartDate = day.date < startDate
                return (
                  <div 
                    key={day.date.toISOString()} 
                    className={`${isBeforeStartDate ? 'opacity-50' : ''}`}
                  >
                    {/* Day Header */}
                    <div className="flex flex-col h-8 justify-between">
                      <div className="font-medium text-sm whitespace-nowrap">
                        {day.date.toLocaleDateString(undefined, { weekday: 'long' })}
                      </div>
                      <div className="flex justify-between items-center">
                        <div className="text-xs text-muted-foreground">
                          {day.date.toLocaleDateString()}
                        </div>
                        {!schedule && !isBeforeStartDate && (
                          <button
                            onClick={() => handleDayBlackout(day.date.getDay(), day.date)}
                            className="text-xs px-1.5 py-0.5 rounded bg-muted/50 text-muted-foreground hover:bg-muted/60"
                          >
                            All Day
                          </button>
                        )}
                      </div>
                    </div>

                    {/* Periods */}
                    {!isBeforeStartDate ? (
                      <div className="space-y-2">
                        {day.periods.map(period => {
                          const scheduledClass = day.classes.find(c => c.period === period.number)
                          return (
                            <ScheduleCell
                              key={period.number}
                              period={period.number}
                              date={day.date}
                              scheduledClass={scheduledClass}
                              blackoutPeriods={blackoutPeriods}
                              isBeforeStartDate={isBeforeStartDate}
                              onClassClick={onClassClick}
                              onClassDrop={onClassMove}
                              onPeriodClick={handlePeriodClick}
                              constraintSatisfaction={scheduledClass?.constraintSatisfaction}
                            />
                          )
                        })}
                      </div>
                    ) : (
                      <div className="p-3 bg-secondary/20 text-secondary-foreground rounded-md text-sm text-center">
                        Not Available
                      </div>
                    )}
                  </div>
                )
              })}
            </div>
          </div>
        ) : (
          <MonthView
            schedule={schedule}
            weekSchedules={displayedWeeks}
            blackoutPeriods={blackoutPeriods}
            startDate={displayedWeek.startDate}
            onClassClick={onClassClick}
            onClassDrop={onClassMove}
            onPeriodClick={handlePeriodClick}
          />
        )}
      </div>
    </DndProvider>
  )
}

================
File: src/components/ScheduleGenerator.tsx
================
import { useState, useCallback } from 'react'
import { Schedule, ScheduledClass, Class, ScheduleConstraints, SchedulePreferences, BlackoutPeriod } from '../types'
import { ScheduleDisplay } from './ScheduleDisplay'
import { scheduleUtils } from '../utils/schedule'

const DEFAULT_CONSTRAINTS: ScheduleConstraints = {
  maxPeriodsPerDay: 8,
  maxPeriodsPerWeek: 40,
  consecutivePeriods: {
    maximum: 2,
    requireBreak: 1
  }
}

interface ScheduleGeneratorProps {
  classes: Class[]
  constraints?: ScheduleConstraints
  preferences: SchedulePreferences
  startDate: Date
  blackoutPeriods: BlackoutPeriod[]
}

export function ScheduleGenerator({
  classes,
  constraints = DEFAULT_CONSTRAINTS,
  preferences,
  startDate,
  blackoutPeriods
}: ScheduleGeneratorProps) {
  const [generatedSchedule, setGeneratedSchedule] = useState<Schedule | undefined>()
  const [error, setError] = useState<string | null>(null)
  const [isGenerating, setIsGenerating] = useState(false)

  const handleGenerateSchedule = useCallback(async () => {
    try {
      setError(null)
      setIsGenerating(true)
      console.log('Starting schedule generation with:', {
        classes: classes.length,
        constraints,
        preferences,
        startDate,
        blackoutPeriods: blackoutPeriods.length
      })
      
      if (classes.length === 0) {
        setError("No classes available to schedule")
        return
      }

      // Use setTimeout to allow React to update the UI
      setTimeout(async () => {
        try {
          console.log('Calling generateSchedule...')
          const schedule = await scheduleUtils.generateSchedule(
            classes,
            startDate,
            constraints,
            preferences,
            blackoutPeriods
          )
          console.log('Schedule generated successfully:', schedule)

          // Calculate end date as 6 weeks from start
          const endDate = new Date(startDate.getTime() + 6 * 7 * 24 * 60 * 60 * 1000)
          
          const finalSchedule = {
            ...schedule,
            startDate: startDate,
            endDate: endDate
          }
          console.log('Setting generated schedule:', finalSchedule)
          setGeneratedSchedule(finalSchedule)
        } catch (err) {
          console.error('Error during schedule generation:', err)
          console.error('Error details:', {
            name: err instanceof Error ? err.name : 'Unknown',
            message: err instanceof Error ? err.message : String(err),
            stack: err instanceof Error ? err.stack : 'No stack trace'
          })
          setError(err instanceof Error ? `${err.name}: ${err.message}` : 'Failed to generate schedule')
        } finally {
          console.log('Schedule generation completed')
          setIsGenerating(false)
        }
      }, 0)
    } catch (err) {
      console.error('Error initiating schedule generation:', err)
      console.error('Error details:', {
        name: err instanceof Error ? err.name : 'Unknown',
        message: err instanceof Error ? err.message : String(err),
        stack: err instanceof Error ? err.stack : 'No stack trace'
      })
      setError(err instanceof Error ? `${err.name}: ${err.message}` : 'Failed to start schedule generation')
      setIsGenerating(false)
    }
  }, [classes, startDate, constraints, preferences, blackoutPeriods])

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h3 className="text-lg font-medium">Generated Schedule</h3>
        <button
          onClick={handleGenerateSchedule}
          disabled={isGenerating}
          className={`px-4 py-2 bg-primary text-primary-foreground rounded-md transition-colors ${
            isGenerating ? 'opacity-50 cursor-not-allowed' : 'hover:bg-primary/90'
          }`}
        >
          {isGenerating ? 'Generating...' : 'Generate Schedule'}
        </button>
      </div>

      {error && (
        <div className="bg-destructive/10 text-destructive px-4 py-2 rounded-md">
          <pre className="whitespace-pre-wrap">{error}</pre>
        </div>
      )}

      {isGenerating && (
        <div className="text-center py-8">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto mb-4"></div>
          <p className="text-muted-foreground">Generating schedule...</p>
        </div>
      )}

      {!isGenerating && generatedSchedule ? (
        <div className="bg-card rounded-lg p-4">
          <ScheduleDisplay
            schedule={generatedSchedule}
            startDate={startDate}
            blackoutPeriods={blackoutPeriods}
            onBlackoutChange={() => {}} // Read-only display
          />
        </div>
      ) : !isGenerating && !error && (
        <div className="text-center py-8 text-muted-foreground">
          Click "Generate Schedule" to create a new schedule based on your constraints and preferences.
        </div>
      )}
    </div>
  )
}

================
File: src/types/index.ts
================
export interface Class {
  id: string
  classNumber: string
  teacher: string
  gradeLevel: string
  totalConflicts: DayConflicts[]
  partialConflicts: DayConflicts[]
}

export interface DayConflicts {
  dayOfWeek: number // 1-5 for Monday-Friday
  periods: number[]
}

export interface ScheduledClass extends Class {
  date: Date
  period: number
}

export interface Schedule {
  classes: ScheduledClass[]
  startDate: Date
  endDate: Date
  constraints: ScheduleConstraints
}

export interface ScheduleConstraints {
  maxPeriodsPerDay: number
  maxPeriodsPerWeek: number
  consecutivePeriods: {
    maximum: 1 | 2
    requireBreak: 1 | 2
  }
}

export interface BlackoutPeriod {
  dayOfWeek: number // 0-6, where 0 is Sunday
  period: number // 1-8
}

export interface SchedulePreferences {
  preferredGradeOrder: string[]
  gradeGroups: GradeGroup[]
  preferSameGradeInDay: boolean
}

export interface GradeGroup {
  id: string
  name: string
  classes: string[] // Class numbers
}

export type Period = {
  number: number
  time: string
  isBlackout: boolean
}

export type DaySchedule = {
  date: Date
  periods: Period[]
  classes: ScheduledClass[]
}

export type WeekSchedule = {
  weekNumber: number
  startDate: Date
  endDate: Date
  days: DaySchedule[]
}

================
File: src/utils/cn.ts
================
import { type ClassValue, clsx } from 'clsx'
import { twMerge } from 'tailwind-merge'

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: src/utils/export.ts
================
import { Schedule, WeekSchedule, ScheduledClass } from '../types'
import jsPDF from 'jspdf'

interface ExportOptions {
  format: 'csv' | 'pdf'
  includeDetails?: boolean
  weekRange?: { start: Date; end: Date }
}

export const exportUtils = {
  exportSchedule: async (schedule: Schedule, options: ExportOptions) => {
    if (options.format === 'csv') {
      return exportToCsv(schedule, options)
    } else {
      return exportToPdf(schedule, options)
    }
  }
}

function exportToCsv(schedule: Schedule, options: ExportOptions): string {
  const rows: string[] = []
  
  // Add header
  rows.push('Date,Period,Class Number,Teacher,Room,Students')
  
  // Process each week
  schedule.weekSchedules.forEach(week => {
    if (options.weekRange) {
      if (week.startDate < options.weekRange.start || week.endDate > options.weekRange.end) {
        return
      }
    }

    week.days.forEach(day => {
      day.classes.forEach(cls => {
        const row = [
          day.date.toISOString().split('T')[0],
          cls.period.toString(),
          cls.classNumber,
          cls.teacher,
          cls.room,
          cls.students.join(';')
        ]
        rows.push(row.join(','))
      })
    })
  })

  return rows.join('\n')
}

async function exportToPdf(schedule: Schedule, options: ExportOptions): Promise<Uint8Array> {
  const doc = new jsPDF()
  const margin = 10
  let y = margin
  const lineHeight = 7
  const headerHeight = 7
  const pageWidth = doc.internal.pageSize.width
  const pageHeight = doc.internal.pageSize.height

  // Add title with custom styling
  doc.setFontSize(20)
  doc.setFont('helvetica', 'bold')
  doc.text('Class Schedule', pageWidth / 2, y, { align: 'center' })
  y += 12

  // Add date range with custom styling
  if (options.weekRange) {
    doc.setFontSize(12)
    doc.setFont('helvetica', 'normal')
    const dateRange = `${options.weekRange.start.toLocaleDateString()} - ${options.weekRange.end.toLocaleDateString()}`
    doc.text(dateRange, pageWidth / 2, y, { align: 'center' })
    y += 10
  }

  // Table settings
  doc.setFontSize(10)
  doc.setFont('helvetica', 'normal')
  const headers = ['Date', 'Period', 'Class', 'Teacher', 'Room', 'Students']
  const colWidths = [25, 15, 30, 30, 20, 60]
  const tableWidth = colWidths.reduce((sum, width) => sum + width, 0)
  const tableX = (pageWidth - tableWidth) / 2 // Center the table

  // Draw table header
  let x = tableX
  const headerY = y

  // Draw header background with gradient
  doc.setFillColor(220, 220, 220)
  doc.rect(tableX, headerY - 5, tableWidth, headerHeight, 'F')
  
  // Draw header text and vertical lines
  doc.setFont('helvetica', 'bold')
  headers.forEach((header, i) => {
    // Draw header text
    doc.text(header, x + 2, y)
    
    // Draw vertical line with shadow effect
    doc.setDrawColor(180, 180, 180)
    doc.line(x, headerY - 5, x, y + 2)
    doc.setDrawColor(150, 150, 150)
    doc.line(x + 0.2, headerY - 4.8, x + 0.2, y + 2.2)
    
    x += colWidths[i]
  })
  
  // Draw final vertical line
  doc.setDrawColor(180, 180, 180)
  doc.line(x, headerY - 5, x, y + 2)
  doc.setDrawColor(150, 150, 150)
  doc.line(x + 0.2, headerY - 4.8, x + 0.2, y + 2.2)
  
  // Draw horizontal line under header with shadow
  doc.setDrawColor(180, 180, 180)
  doc.line(tableX, y + 2, tableX + tableWidth, y + 2)
  doc.setDrawColor(150, 150, 150)
  doc.line(tableX, y + 2.2, tableX + tableWidth, y + 2.2)
  
  y += headerHeight
  doc.setFont('helvetica', 'normal')

  // Helper function to draw row lines with shadow effect
  const drawRowLines = (startY: number, endY: number) => {
    let xPos = tableX
    // Draw vertical lines with shadow
    colWidths.forEach(width => {
      doc.setDrawColor(180, 180, 180)
      doc.line(xPos, startY, xPos, endY)
      doc.setDrawColor(150, 150, 150)
      doc.line(xPos + 0.2, startY, xPos + 0.2, endY)
      xPos += width
    })
    // Draw final vertical line
    doc.setDrawColor(180, 180, 180)
    doc.line(xPos, startY, xPos, endY)
    doc.setDrawColor(150, 150, 150)
    doc.line(xPos + 0.2, startY, xPos + 0.2, endY)
    
    // Draw horizontal line with shadow
    doc.setDrawColor(180, 180, 180)
    doc.line(tableX, endY, tableX + tableWidth, endY)
    doc.setDrawColor(150, 150, 150)
    doc.line(tableX, endY + 0.2, tableX + tableWidth, endY + 0.2)
  }

  // Process each week
  schedule.weekSchedules.forEach(week => {
    if (options.weekRange) {
      if (week.startDate < options.weekRange.start || week.endDate > options.weekRange.end) {
        return
      }
    }

    week.days.forEach(day => {
      day.classes.forEach(cls => {
        // Check if we need a new page
        if (y > pageHeight - margin) {
          // Draw final row lines on current page
          drawRowLines(y - lineHeight, y)
          
          doc.addPage()
          y = margin
          
          // Redraw header on new page
          x = tableX
          doc.setFillColor(220, 220, 220)
          doc.rect(tableX, y - 5, tableWidth, headerHeight, 'F')
          
          doc.setFont('helvetica', 'bold')
          headers.forEach((header, i) => {
            doc.text(header, x + 2, y)
            doc.setDrawColor(180, 180, 180)
            doc.line(x, y - 5, x, y + 2)
            doc.setDrawColor(150, 150, 150)
            doc.line(x + 0.2, y - 4.8, x + 0.2, y + 2.2)
            x += colWidths[i]
          })
          doc.setDrawColor(180, 180, 180)
          doc.line(x, y - 5, x, y + 2)
          doc.setDrawColor(150, 150, 150)
          doc.line(x + 0.2, y - 4.8, x + 0.2, y + 2.2)
          doc.line(tableX, y + 2, tableX + tableWidth, y + 2)
          
          y += headerHeight
          doc.setFont('helvetica', 'normal')
        }

        const rowStartY = y - lineHeight

        // Add row data
        x = tableX
        const row = [
          day.date.toLocaleDateString(),
          cls.period.toString(),
          cls.classNumber.toString(),
          cls.teacher,
          cls.room,
          cls.students.join(', ')
        ]

        row.forEach((cell, i) => {
          const cellX = x + 2
          
          if (i === 5) { // Students column
            const maxWidth = colWidths[i] - 4
            const lines = doc.splitTextToSize(cell, maxWidth)
            doc.text(lines, cellX, y)
            // Adjust y position based on number of lines
            if (lines.length > 1) {
              y += (lines.length - 1) * 5
            }
          } else {
            doc.text(cell, cellX, y)
          }
          x += colWidths[i]
        })

        // Draw row lines with shadow effect
        drawRowLines(rowStartY, y + 2)

        y += lineHeight
      })
    })
  })

  return doc.output('arraybuffer')
}

// Helper function to download the exported file
export function downloadFile(content: string | Uint8Array, filename: string) {
  const blob = new Blob([content], { 
    type: content instanceof Uint8Array ? 'application/pdf' : 'text/csv' 
  })
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = filename
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
  URL.revokeObjectURL(url)
}

================
File: src/utils/parallelScheduler.ts
================
import { Class, Schedule, ScheduleConstraints, SchedulePreferences, BlackoutPeriod, SimulatedAnnealingConfig } from '../types'
import { SimulatedAnnealingScheduler } from './simulatedAnnealing'
import { Worker } from 'worker_threads'

export class ParallelScheduler {
  private classes: Class[]
  private startDate: Date
  private constraints: ScheduleConstraints
  private preferences: SchedulePreferences
  private blackoutPeriods: BlackoutPeriod[]
  private workerCount: number
  public workers: Worker[] = []

  constructor(
    classes: Class[],
    startDate: Date,
    constraints: ScheduleConstraints,
    preferences: SchedulePreferences,
    blackoutPeriods: BlackoutPeriod[],
    workerCount = 4
  ) {
    this.classes = classes
    this.startDate = startDate
    this.constraints = constraints
    this.preferences = preferences
    this.blackoutPeriods = blackoutPeriods
    this.workerCount = Math.min(workerCount, 8) // Cap at 8 workers
  }

  private createWorkerConfig(i: number): Partial<SimulatedAnnealingConfig> {
    return {
      initialTemperature: 1000 * (1 + i * 0.2), // Different initial temps
      coolingRate: 0.995 - (i * 0.001), // Slightly different cooling rates
      minTemperature: 0.1 * (1 + i * 0.1), // Different min temps
      iterationsPerTemp: 300 + (i * 50), // Different iteration counts
      maxRestarts: 5
    }
  }

  public async generateSchedule(): Promise<Schedule> {
    let bestSchedule: Schedule | null = null
    let bestScore = -Infinity

    // Try multiple times with different parameters
    for (let i = 0; i < this.workerCount; i++) {
      // Create mock worker
      const mockWorker = {
        terminate: () => {},
        on: () => {},
        postMessage: () => {}
      } as unknown as Worker
      this.workers.push(mockWorker)

      // Create scheduler with worker-specific parameters
      const scheduler = new SimulatedAnnealingScheduler(
        this.classes,
        this.startDate,
        this.constraints,
        this.preferences,
        this.blackoutPeriods,
        this.createWorkerConfig(i)
      )

      // Try to generate a schedule
      const schedule = await scheduler.generateSchedule()
      const score = schedule.score.gradeGroupCohesion + 
                   schedule.score.distributionQuality + 
                   (schedule.classes.length / this.classes.length) * 1000 // Heavily weight completeness

      if (score > bestScore) {
        bestScore = score
        bestSchedule = schedule
      }
    }

    // Clean up mock workers
    this.terminateWorkers()
    
    return bestSchedule!
  }

  private terminateWorkers() {
    this.workers.forEach(worker => worker.terminate())
    this.workers = []
  }
}

================
File: src/utils/schedule.ts
================
import { 
  Class,
  Schedule,
  ScheduledClass,
  ScheduleConstraints,
  SchedulePreferences,
  BlackoutPeriod,
  DaySchedule,
  WeekSchedule
} from '../types'
import { SimulatedAnnealingScheduler } from './simulatedAnnealing'

const PERIODS_PER_DAY = 8
const DAYS_PER_WEEK = 5 // Monday to Friday

function isSameDay(date1: Date, date2: Date): boolean {
  return (
    date1.getFullYear() === date2.getFullYear() &&
    date1.getMonth() === date2.getMonth() &&
    date1.getDate() === date2.getDate()
  )
}

function isBlackoutPeriod(period: number, date: Date, blackoutPeriods: BlackoutPeriod[]): boolean {
  return blackoutPeriods.some(
    blackout => 
      blackout.period === period && 
      isSameDay(blackout.date, date)
  )
}

function getWeekNumber(date: Date, startDate: Date): number {
  const diffTime = Math.abs(date.getTime() - startDate.getTime())
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24))
  return Math.floor(diffDays / 7) + 1
}

function getDaySchedule(
  date: Date,
  scheduledClasses: ScheduledClass[],
  blackoutPeriods: BlackoutPeriod[]
): DaySchedule {
  const dayClasses = scheduledClasses.filter(
    cls => isSameDay(cls.date, date)
  )

  const periods = Array.from({ length: PERIODS_PER_DAY }, (_, i) => ({
    number: i + 1,
    time: `Period ${i + 1}`,
    isBlackout: isBlackoutPeriod(i + 1, date, blackoutPeriods)
  }))

  return {
    date,
    periods,
    classes: dayClasses
  }
}

function getWeekSchedule(
  weekStartDate: Date,
  scheduledClasses: ScheduledClass[],
  blackoutPeriods: BlackoutPeriod[],
  startDate: Date
): WeekSchedule {
  const days: DaySchedule[] = []
  
  // Ensure weekStartDate is a Monday
  const monday = new Date(weekStartDate)
  while (monday.getDay() !== 1) { // 1 is Monday
    monday.setDate(monday.getDate() + 1)
  }

  // Set end date to Friday (Monday + 4 days)
  const weekEndDate = new Date(monday)
  weekEndDate.setDate(weekEndDate.getDate() + 4)

  // Generate schedule for Monday through Friday
  for (let i = 0; i < 5; i++) {
    const currentDate = new Date(monday)
    currentDate.setDate(currentDate.getDate() + i)
    
    // Only include days on or after the start date
    if (currentDate >= startDate) {
      days.push(getDaySchedule(currentDate, scheduledClasses, blackoutPeriods))
    }
  }

  return {
    weekNumber: getWeekNumber(monday, startDate),
    startDate: monday,
    endDate: weekEndDate,
    days
  }
}

function countConsecutivePeriods(
  period: number,
  date: Date,
  scheduledClasses: ScheduledClass[]
): number {
  const dayClasses = scheduledClasses.filter(
    cls =>
      isSameDay(cls.date, date)
  )

  let consecutiveCount = 1
  let currentPeriod = period

  // Check periods before
  while (dayClasses.some(cls => cls.period === currentPeriod - 1)) {
    consecutiveCount++
    currentPeriod--
  }

  currentPeriod = period
  // Check periods after
  while (dayClasses.some(cls => cls.period === currentPeriod + 1)) {
    consecutiveCount++
    currentPeriod++
  }

  return consecutiveCount
}

function hasConflict(period: number, dayOfWeek: number, conflicts: { dayOfWeek: number; periods: number[] }[]): boolean {
  const dayConflicts = conflicts.find(d => d.dayOfWeek === dayOfWeek)
  return dayConflicts ? dayConflicts.periods.includes(period) : false
}

async function generateSchedule(
  classes: Class[],
  startDate: Date,
  constraints: ScheduleConstraints,
  preferences: SchedulePreferences,
  blackoutPeriods: BlackoutPeriod[]
): Promise<Schedule> {
  // Create and configure the scheduling engine with simulated annealing
  const engine = new SimulatedAnnealingScheduler(
    classes,
    startDate,
    constraints,
    preferences,
    blackoutPeriods,
    {
      initialTemperature: 3000,
      coolingRate: 0.99,
      minTemperature: 0.1,
      iterationsPerTemp: 400,
      maxRestarts: 10
    }
  )

  // Generate the schedule in a non-blocking way
  return new Promise((resolve, reject) => {
    // Use setTimeout to prevent UI blocking
    setTimeout(() => {
      try {
        console.info('Starting schedule generation with simulated annealing...')
        const schedule = engine.generateSchedule()
        
        // Log scheduling results for analysis
        console.info(`Schedule generation completed:
          - Classes scheduled: ${schedule.classes.length}/${classes.length}
          - Start date: ${schedule.startDate.toISOString()}
          - End date: ${schedule.endDate.toISOString()}
          - Total days: ${Math.ceil((schedule.endDate.getTime() - schedule.startDate.getTime()) / (1000 * 60 * 60 * 24))}
          - Score: ${JSON.stringify(schedule.score)}
        `)

        resolve(schedule)
      } catch (error) {
        console.error('Schedule generation failed:', error)
        reject(error)
      }
    }, 0)
  })
}

export const scheduleUtils = {
  isSameDay,
  getWeekSchedule,
  generateSchedule,
  isBlackoutPeriod,
  getDaySchedule,
  getWeekNumber,
  countConsecutivePeriods,
}

================
File: src/utils/scheduleEngine.ts
================
/**
 * Core scheduling engine that handles class scheduling with constraints.
 * Works in conjunction with SimulatedAnnealing for optimization.
 * 
 * Features:
 * - Constraint validation
 * - Schedule scoring
 * - Grade group management
 * - Blackout period handling
 * 
 * @version 1.0.0
 */

import {
  Class,
  Schedule,
  ScheduledClass,
  ScheduleConstraints,
  SchedulePreferences,
} from '../types';

const MAX_ITERATIONS = 10000 // Prevent infinite loops

/**
 * Interface for tracking schedule scores
 */
interface ScheduleScore {
  totalLength: number
  gradeGroupCohesion: number
  distributionQuality: number
  constraintViolations: number
  gradeProgression: number
  partialConflictPenalty: number
}

/**
 * Main class for generating and optimizing class schedules
 */
export class ScheduleEngine {
  private classes: Class[]
  private startDate: Date
  private constraints: ScheduleConstraints

  constructor(
    classes: Class[],
    startDate: Date,
    constraints: ScheduleConstraints,
    _preferences: SchedulePreferences
  ) {
    this.classes = classes
    this.startDate = startDate
    this.constraints = constraints
  }

  /**
   * Calculates various metrics for a schedule
   * @param classes The scheduled classes to evaluate
   * @returns A ScheduleScore object with various metrics
   */
  protected calculateScore(classes: ScheduledClass[]): ScheduleScore {
    // Calculate total length score
    const totalLength = classes.length / this.classes.length;

    // Calculate grade group cohesion
    let gradeGroupCohesion = 0;
    const gradeGroups = new Map<string, ScheduledClass[]>();
    classes.forEach(cls => {
      if (!gradeGroups.has(cls.gradeGroup)) {
        gradeGroups.set(cls.gradeGroup, []);
      }
      gradeGroups.get(cls.gradeGroup)?.push(cls);
    });

    gradeGroups.forEach(groupClasses => {
      // Calculate average distance between classes in the same group
      let totalDistance = 0;
      let comparisons = 0;

      for (let i = 0; i < groupClasses.length; i++) {
        for (let j = i + 1; j < groupClasses.length; j++) {
          const distance = Math.abs(
            groupClasses[i].date.getTime() - groupClasses[j].date.getTime()
          );
          totalDistance += distance;
          comparisons++;
        }
      }

      if (comparisons > 0) {
        // Normalize the cohesion score
        gradeGroupCohesion += 1 - (totalDistance / comparisons) / (14 * 24 * 60 * 60 * 1000);
      }
    });

    if (gradeGroups.size > 0) {
      gradeGroupCohesion /= gradeGroups.size;
    }

    // Calculate distribution quality
    let distributionQuality = 0;
    const classesByDate = new Map<string, number>();
    classes.forEach(cls => {
      const dateKey = cls.date.toISOString().split('T')[0];
      classesByDate.set(dateKey, (classesByDate.get(dateKey) || 0) + 1);
    });

    const maxClassesPerDay = this.constraints.maxClassesPerDay;
    classesByDate.forEach(count => {
      // Higher score for days that are closer to maxClassesPerDay
      distributionQuality += count / maxClassesPerDay;
    });

    if (classesByDate.size > 0) {
      distributionQuality /= classesByDate.size;
    }

    // Calculate grade progression score
    let gradeProgression = 0;
    const classesByDay = new Map<string, ScheduledClass[]>();
    classes.forEach(cls => {
      const dateKey = cls.date.toISOString().split('T')[0];
      if (!classesByDay.has(dateKey)) {
        classesByDay.set(dateKey, []);
      }
      classesByDay.get(dateKey)?.push(cls);
    });

    classesByDay.forEach(dayClasses => {
      // Sort classes by period
      dayClasses.sort((a, b) => a.period - b.period);

      // Check if grade levels generally increase throughout the day
      for (let i = 0; i < dayClasses.length - 1; i++) {
        const currentGrade = parseInt(dayClasses[i].gradeLevel);
        const nextGrade = parseInt(dayClasses[i + 1].gradeLevel);
        if (currentGrade <= nextGrade) {
          gradeProgression++;
        }
      }

      if (dayClasses.length > 1) {
        gradeProgression /= (dayClasses.length - 1);
      }
    });

    // Calculate constraint violations and partial conflict penalties
    const constraintViolations = this.calculateConstraintViolations(classes);

    return {
      totalLength,
      gradeGroupCohesion,
      distributionQuality,
      constraintViolations,
      gradeProgression,
      partialConflictPenalty: 0
    };
  }

  protected aggregateScore(scores: ScheduleScore): number {
    const weights = {
      totalLength: 1,
      gradeGroupCohesion: 0.5,
      distributionQuality: 0.3,
      constraintViolations: -100,
      gradeProgression: 0.4,
      partialConflictPenalty: 0  // No penalty for partial conflicts
    };

    return Object.entries(weights).reduce((total, [key, weight]) => {
      return total + scores[key as keyof ScheduleScore] * weight;
    }, 0);
  }

  private calculateConstraintViolations(classes: ScheduledClass[]): number {
    let violations = 0;

    // Check for total conflict violations
    classes.forEach(cls => {
      const originalClass = this.classes.find(c => c.id === cls.id);
      if (!originalClass) return;

      const hasTotalConflict = originalClass.totalConflicts.some(
        conflict => 
          conflict.date.getTime() === cls.date.getTime() && 
          conflict.period === cls.period
      );
      if (hasTotalConflict) {
        violations += 1;
      }
    });

    return violations;
  }

  private getDateRange(startDate: Date, numDays: number): Date[] {
    const dates: Date[] = [];
    let currentDate = new Date(startDate);

    for (let i = 0; i < numDays; i++) {
      dates.push(new Date(currentDate));
      currentDate.setDate(currentDate.getDate() + 1);
    }

    return dates;
  }

  private generateInitialSolution(): Schedule {
    const classes: ScheduledClass[] = [];
    const dates = this.getDateRange(this.startDate, 14); // Two weeks of dates
    const periods = Array.from({ length: this.constraints.maxPeriodsPerDay }, (_, i) => i + 1);

    // Track classes per day to ensure even distribution
    const classesPerDay = new Map<string, number>();

    // Try to schedule each class
    this.classes.forEach(cls => {
      let scheduled = false;
      let bestSlot: { date: Date; period: number } | null = null;

      // Shuffle dates and periods for better distribution
      const shuffledDates = [...dates].sort(() => Math.random() - 0.5);
      const shuffledPeriods = [...periods].sort(() => Math.random() - 0.5);

      // Try each date and period until we find a valid slot
      for (const date of shuffledDates) {
        if (scheduled) break;

        const dateKey = date.toISOString().split('T')[0];
        const currentClassesOnDay = classesPerDay.get(dateKey) || 0;

        // Skip if we've reached max classes for this day
        if (currentClassesOnDay >= this.constraints.maxClassesPerDay) {
          continue;
        }

        for (const period of shuffledPeriods) {
          // Check if this slot has any total conflicts
          const hasTotalConflict = cls.totalConflicts.some(
            conflict => 
              conflict.date.getTime() === date.getTime() && 
              conflict.period === period
          );

          if (!hasTotalConflict) {
            // Always update best slot
            if (!bestSlot) {
              bestSlot = { date, period };
            }

            // Always schedule with high probability
            if (Math.random() < 0.99) {
              classes.push({
                id: cls.id,
                name: cls.name,
                gradeLevel: cls.gradeLevel,
                gradeGroup: cls.gradeGroup,
                teacher: cls.teacher,
                date,
                period,
                totalConflicts: cls.totalConflicts,
                partialConflicts: cls.partialConflicts
              });
              
              // Update classes per day count
              classesPerDay.set(dateKey, currentClassesOnDay + 1);
              scheduled = true;
              break;
            }
          }
        }
      }

      // If we haven't scheduled yet, use the best available slot
      if (!scheduled && bestSlot) {
        const dateKey = bestSlot.date.toISOString().split('T')[0];
        const currentClassesOnDay = classesPerDay.get(dateKey) || 0;
        
        classes.push({
          id: cls.id,
          name: cls.name,
          gradeLevel: cls.gradeLevel,
          gradeGroup: cls.gradeGroup,
          teacher: cls.teacher,
          date: bestSlot.date,
          period: bestSlot.period,
          totalConflicts: cls.totalConflicts,
          partialConflicts: cls.partialConflicts
        });
        
        // Update classes per day count
        classesPerDay.set(dateKey, currentClassesOnDay + 1);
      }
    });

    const score = this.calculateScore(classes);

    return {
      classes,
      score
    };
  }

  private mutateSchedule(schedule: Schedule): Schedule {
    const newClasses = [...schedule.classes];
    const dates = this.getDateRange(this.startDate, 14);
    const periods = Array.from({ length: this.constraints.maxPeriodsPerDay }, (_, i) => i + 1);

    // Track classes per day
    const classesPerDay = new Map<string, number>();
    newClasses.forEach(cls => {
      const dateKey = cls.date.toISOString().split('T')[0];
      classesPerDay.set(dateKey, (classesPerDay.get(dateKey) || 0) + 1);
    });

    // Randomly select a class to move
    const indexToMove = Math.floor(Math.random() * newClasses.length);
    const classToMove = newClasses[indexToMove];
    const originalClass = this.classes.find(c => c.id === classToMove.id);

    if (!originalClass) return schedule;

    // Remove the class from its current day count
    const oldDateKey = classToMove.date.toISOString().split('T')[0];
    classesPerDay.set(oldDateKey, (classesPerDay.get(oldDateKey) || 1) - 1);

    // Try to find a new valid slot
    let moved = false;
    let bestSlot: { date: Date; period: number } | null = null;

    const shuffledDates = dates.sort(() => Math.random() - 0.5);
    const shuffledPeriods = periods.sort(() => Math.random() - 0.5);

    for (const date of shuffledDates) {
      if (moved) break;

      const dateKey = date.toISOString().split('T')[0];
      const currentClassesOnDay = classesPerDay.get(dateKey) || 0;

      // Skip if we've reached max classes for this day
      if (currentClassesOnDay >= this.constraints.maxClassesPerDay) {
        continue;
      }

      for (const period of shuffledPeriods) {
        // Check if this slot has any total conflicts
        const hasTotalConflict = originalClass.totalConflicts.some(
          conflict => 
            conflict.date.getTime() === date.getTime() && 
            conflict.period === period
        );

        if (!hasTotalConflict) {
          // Update best slot
          if (!bestSlot) {
            bestSlot = { date, period };
          }

          // Always schedule with high probability
          if (Math.random() < 0.99) {
            moved = true;
            break;
          }
        }
      }
    }

    // Use the best slot we found
    if (bestSlot) {
      const dateKey = bestSlot.date.toISOString().split('T')[0];
      const currentClassesOnDay = classesPerDay.get(dateKey) || 0;
      
      newClasses[indexToMove] = {
        ...classToMove,
        date: bestSlot.date,
        period: bestSlot.period
      };
      
      // Update classes per day count for the new day
      classesPerDay.set(dateKey, currentClassesOnDay + 1);
    }

    const score = this.calculateScore(newClasses);

    return {
      classes: newClasses,
      score
    };
  }

  public generateSchedule(): Schedule {
    let iterations = 0
    let bestScore = -Infinity
    let lastImprovement = 0
    const maxIterationsWithoutImprovement = 1000

    // Generate initial solution
    let currentSchedule = this.generateInitialSolution()
    let bestSchedule = currentSchedule

    // Simulated annealing parameters
    const initialTemperature = 1.0
    const coolingRate = 0.995

    while (iterations < MAX_ITERATIONS && (iterations - lastImprovement) < maxIterationsWithoutImprovement) {
      const temperature = initialTemperature * Math.pow(coolingRate, iterations)

      // Generate a neighbor solution
      const newSchedule = this.mutateSchedule(currentSchedule)
      const currentScore = this.aggregateScore(currentSchedule.score)
      const newScore = this.aggregateScore(newSchedule.score)

      // Decide if we should accept the new solution
      if (newScore > currentScore || Math.random() < Math.exp((newScore - currentScore) / temperature)) {
        currentSchedule = newSchedule

        // Update best solution if this is better
        if (newScore > bestScore) {
          bestScore = newScore
          bestSchedule = newSchedule
          lastImprovement = iterations
        }
      }

      iterations++
    }

    return bestSchedule
  }
}

================
File: src/utils/schedulerWorker.js
================
const { parentPort, workerData } = require('worker_threads')
const { SimulatedAnnealingScheduler } = require('./simulatedAnnealing')

// Worker parameters based on worker ID
const getWorkerParams = (workerId) => ({
  initialTemp: 100 * (1 + workerId * 0.5),
  coolingRate: 0.95 - (workerId * 0.01),
  minTemp: 0.1,
  iterationsPerTemp: 100 + (workerId * 25)
})

// Listen for messages from main thread
parentPort.on('message', (data) => {
  const {
    classes,
    startDate,
    constraints,
    preferences,
    blackoutPeriods
  } = data

  // Create scheduler with worker-specific parameters
  const scheduler = new SimulatedAnnealingScheduler(
    classes,
    new Date(startDate),
    constraints,
    preferences,
    blackoutPeriods,
    getWorkerParams(workerData.id)
  )

  // Generate schedule
  const schedule = scheduler.generateSchedule()

  // Send result back to main thread
  parentPort.postMessage({
    type: 'result',
    schedule,
    workerId: workerData.id
  })
})

================
File: src/utils/schedulerWorker.ts
================
import { SimulatedAnnealingScheduler } from './simulatedAnnealing'
import { Class, Schedule, ScheduleConstraints, SchedulePreferences, BlackoutPeriod } from '../types'

interface WorkerData {
  classes: Class[]
  startDate: Date
  constraints: ScheduleConstraints
  preferences: SchedulePreferences
  blackoutPeriods: BlackoutPeriod[]
  params: {
    initialTemp: number
    coolingRate: number
    minTemp: number
    iterationsPerTemp: number
  }
}

// Web Worker entry point
self.onmessage = (e: MessageEvent<WorkerData>) => {
  const { 
    classes,
    startDate,
    constraints,
    preferences,
    blackoutPeriods,
    params
  } = e.data

  // Create scheduler with worker-specific parameters
  const scheduler = new SimulatedAnnealingScheduler(
    classes,
    new Date(startDate), // Convert date from serialized form
    constraints,
    preferences,
    blackoutPeriods,
    params
  )

  // Generate schedule
  const schedule = scheduler.generateSchedule()

  // Send result back to main thread
  self.postMessage({
    type: 'result',
    schedule,
    workerId: params.initialTemp // Use temp as unique ID
  })
}

================
File: src/utils/simulatedAnnealing.ts
================
import { Class, Schedule, ScheduleConstraints, SchedulePreferences, BlackoutPeriod, ScheduledClass } from '../types'
import { ScheduleEngine } from './scheduleEngine'

/**
 * SimulatedAnnealing class implements an advanced optimization strategy for class scheduling.
 * 
 * The algorithm uses a multi-objective optimization approach with the following weights:
 * - Completeness: 40% (schedule utilization)
 * - Cohesion: 30% (grade group scheduling)
 * - Distribution: 30% (class spread)
 * 
 * Performance characteristics:
 * - Small schedules (3-15 classes): 92-98% optimization
 * - Medium schedules (20-22 classes): 85-97% optimization
 * - Large schedules (30+ classes): 73-74% optimization
 * 
 * @version 1.0.0
 */
export interface SimulatedAnnealingConfig {
  initialTemperature: number;
  coolingRate: number;
  minTemperature: number;
  iterationsPerTemp: number;
  maxRestarts: number;
  maxIterations: number;
}

/**
 * SimulatedAnnealing class implements an advanced optimization strategy for class scheduling.
 * 
 * The algorithm uses a multi-objective optimization approach with the following weights:
 * - Completeness: 40% (schedule utilization)
 * - Cohesion: 30% (grade group scheduling)
 * - Distribution: 30% (class spread)
 * 
 * Performance characteristics:
 * - Small schedules (3-15 classes): 92-98% optimization
 * - Medium schedules (20-22 classes): 85-97% optimization
 * - Large schedules (30+ classes): 73-74% optimization
 * 
 * @version 1.0.0
 */
export class SimulatedAnnealing {
  private scheduleEngine: ScheduleEngine;
  private config: SimulatedAnnealingConfig;

  constructor(
    scheduleEngine: ScheduleEngine,
    config: Partial<SimulatedAnnealingConfig> = {}
  ) {
    this.scheduleEngine = scheduleEngine;
    this.config = {
      initialTemperature: 1000,
      coolingRate: 0.95,
      maxIterations: 10000,
      minTemperature: 0.01,
      ...config
    };
  }

  public async optimize(classes: Class[]): Promise<Schedule> {
    let currentSolution = this.generateInitialSolution(classes);
    let bestSolution = currentSolution;
    let temperature = this.config.initialTemperature;
    let iteration = 0;

    while (temperature > this.config.minTemperature && iteration < this.config.maxIterations) {
      const newSolution = this.mutateSchedule(currentSolution);
      const currentScore = this.scheduleEngine.calculateScore(currentSolution);
      const newScore = this.scheduleEngine.calculateScore(newSolution);

      if (this.acceptSchedule(currentScore, newScore, temperature)) {
        currentSolution = newSolution;
        if (newScore > this.scheduleEngine.calculateScore(bestSolution)) {
          bestSolution = newSolution;
        }
      }

      temperature *= this.config.coolingRate;
      iteration++;
    }

    return bestSolution;
  }

  private generateInitialSolution(classes: Class[]): Schedule {
    // Create an empty schedule
    const schedule = new Schedule([]);
    const availablePeriods = Array.from({ length: 8 }, (_, i) => i + 1);

    // Try to schedule each class
    classes.forEach(cls => {
      const date = new Date(); // Start with today
      let scheduled = false;

      // Try up to 5 different days
      for (let dayOffset = 0; dayOffset < 5 && !scheduled; dayOffset++) {
        const tryDate = new Date(date);
        tryDate.setDate(tryDate.getDate() + dayOffset);

        // Try each available period
        for (const period of availablePeriods) {
          if (!this.scheduleEngine.hasConflict(period, tryDate, cls, schedule.classes)) {
            schedule.classes.push({
              class: cls,
              date: tryDate,
              period
            });
            scheduled = true;
            break;
          }
        }
      }
    });

    schedule.score = this.scheduleEngine.calculateScore(schedule);
    return schedule;
  }

  private mutateSchedule(schedule: Schedule): Schedule {
    const mutated = schedule.clone()
    const scheduledClasses = mutated.classes

    // Select a random class to move
    const randomIndex = Math.floor(Math.random() * scheduledClasses.length)
    const classToMove = scheduledClasses[randomIndex]

    // Get available periods that don't have total conflicts
    const availablePeriods = this.scheduleEngine.getAvailablePeriods(
      classToMove.date,
      classToMove.class,
      scheduledClasses.filter((_, i) => i !== randomIndex)
    )

    if (availablePeriods.length > 0) {
      // Prefer periods with fewer partial conflicts
      const periodsWithScores = availablePeriods.map(period => {
        const conflicts = this.scheduleEngine.checkClassConflicts(
          classToMove.date,
          period,
          classToMove.class
        )
        return {
          period,
          conflicts: conflicts.partialConflictCount
        }
      })

      // Sort by number of conflicts (ascending)
      periodsWithScores.sort((a, b) => a.conflicts - b.conflicts)

      // Select from top 3 periods (or all if less than 3) to maintain some randomness
      const topPeriods = periodsWithScores.slice(0, Math.min(3, periodsWithScores.length))
      const selectedPeriod = topPeriods[Math.floor(Math.random() * topPeriods.length)].period

      // Update the class period
      scheduledClasses[randomIndex] = {
        ...classToMove,
        period: selectedPeriod
      }
    }

    return mutated
  }

  private acceptSchedule(currentScore: number, newScore: number, temperature: number): boolean {
    if (newScore > currentScore) {
      return true
    }

    // Calculate acceptance probability based on score difference and temperature
    const delta = newScore - currentScore
    const acceptanceProbability = Math.exp(delta / temperature)

    return Math.random() < acceptanceProbability
  }
}

export class SimulatedAnnealingScheduler extends ScheduleEngine {
  private simulatedAnnealing: SimulatedAnnealing;

  constructor(
    classes: Class[],
    startDate: Date,
    constraints: ScheduleConstraints,
    preferences: SchedulePreferences,
    blackoutPeriods: BlackoutPeriod[],
    config?: Partial<SimulatedAnnealingConfig>
  ) {
    super(classes, startDate, constraints, preferences, blackoutPeriods);
    this.simulatedAnnealing = new SimulatedAnnealing(this, config);
  }

  public generateSchedule(): Schedule {
    // Create an empty schedule as starting point
    const initialSchedule = new Schedule(
      this.startDate,
      this.classes,
      this.constraints,
      this.preferences,
      this.blackoutPeriods,
      []  // Start with no scheduled classes
    );

    console.log('Starting simulated annealing with:', {
      totalClasses: this.classes.length,
      constraints: this.constraints,
      preferences: this.preferences
    });

    try {
      // Let simulated annealing build up the schedule
      const optimizedSchedule = this.simulatedAnnealing.optimize(this.classes);
      
      if (optimizedSchedule.classes.length === 0) {
        throw new Error('No classes could be scheduled');
      }
      
      return optimizedSchedule;
    } catch (error) {
      console.error('Failed to generate schedule:', error);
      throw new Error('Failed to generate a valid schedule. Please try adjusting the constraints.');
    }
  }
}

================
File: src/utils/storage.ts
================
import { Class, Schedule, SchedulePreferences } from '../types'

const STORAGE_KEYS = {
  CLASSES: 'cooking-scheduler-classes',
  SCHEDULE: 'cooking-scheduler-schedule',
  PREFERENCES: 'cooking-scheduler-preferences'
}

export const storage = {
  initializeSampleData(): void {
    const sampleClasses = [
      {
        id: '1',
        name: 'Basic Cooking',
        teacher: 'Chef John',
        gradeLevel: '3rd',
        classNumber: 1,
        maxStudents: 15
      },
      {
        id: '2',
        name: 'Advanced Cooking',
        teacher: 'Chef Maria',
        gradeLevel: '5th',
        classNumber: 2,
        maxStudents: 12
      },
      {
        id: '3',
        name: 'Baking Fundamentals',
        teacher: 'Chef Sarah',
        gradeLevel: '4th',
        classNumber: 3,
        maxStudents: 15
      },
      {
        id: '4',
        name: 'Kitchen Safety',
        teacher: 'Chef Mike',
        gradeLevel: '2nd',
        classNumber: 4,
        maxStudents: 10
      },
      {
        id: '5',
        name: 'Mixed Grade Cooking',
        teacher: 'Chef Lisa',
        gradeLevel: 'mixed',
        classNumber: 5,
        maxStudents: 15,
        allowedGrades: ['3rd', '4th', '5th']
      }
    ];

    this.saveClasses(sampleClasses);
  },

  getClasses(): Class[] {
    try {
      const stored = localStorage.getItem(STORAGE_KEYS.CLASSES)
      return stored ? JSON.parse(stored) : []
    } catch (error) {
      console.error('Error loading classes:', error)
      return []
    }
  },

  saveClasses(classes: Class[]): void {
    try {
      localStorage.setItem(STORAGE_KEYS.CLASSES, JSON.stringify(classes))
    } catch (error) {
      console.error('Error saving classes:', error)
    }
  },

  getSchedule(): Schedule | undefined {
    try {
      const stored = localStorage.getItem(STORAGE_KEYS.SCHEDULE)
      if (!stored) return undefined

      const schedule = JSON.parse(stored)
      // Convert date strings back to Date objects
      schedule.startDate = new Date(schedule.startDate)
      schedule.endDate = new Date(schedule.endDate)
      schedule.classes.forEach((cls: any) => {
        cls.date = new Date(cls.date)
      })
      schedule.constraints.blackoutDates = schedule.constraints.blackoutDates.map(
        (date: string) => new Date(date)
      )
      return schedule
    } catch (error) {
      console.error('Error loading schedule:', error)
      return undefined
    }
  },

  saveSchedule(schedule: Schedule | undefined): void {
    try {
      if (schedule === undefined) {
        localStorage.removeItem(STORAGE_KEYS.SCHEDULE)
      } else {
        localStorage.setItem(STORAGE_KEYS.SCHEDULE, JSON.stringify(schedule))
      }
    } catch (error) {
      console.error('Error saving schedule:', error)
    }
  },

  getPreferences(): SchedulePreferences | null {
    try {
      const stored = localStorage.getItem(STORAGE_KEYS.PREFERENCES)
      return stored ? JSON.parse(stored) : null
    } catch (error) {
      console.error('Error loading preferences:', error)
      return null
    }
  },

  savePreferences(preferences: SchedulePreferences): void {
    try {
      localStorage.setItem(STORAGE_KEYS.PREFERENCES, JSON.stringify(preferences))
    } catch (error) {
      console.error('Error saving preferences:', error)
    }
  },

  clearAll(): void {
    try {
      localStorage.removeItem(STORAGE_KEYS.CLASSES)
      localStorage.removeItem(STORAGE_KEYS.SCHEDULE)
      localStorage.removeItem(STORAGE_KEYS.PREFERENCES)
    } catch (error) {
      console.error('Error clearing storage:', error)
    }
  }
}

================
File: src/App.tsx
================
import { useEffect, useState } from 'react'
import { ClassForm } from './components/ClassForm'
import { ScheduleConstraintsForm } from './components/ScheduleConstraints'
import { ScheduleDisplay } from './components/ScheduleDisplay'
import { ScheduleGenerator } from './components/ScheduleGenerator'
import {
  Class,
  Schedule,
  ScheduleConstraints,
  SchedulePreferences,
  ScheduledClass,
  BlackoutPeriod
} from './types'
import { storage } from './utils/storage'
import { scheduleUtils } from './utils/schedule'

function App() {
  const [classes, setClasses] = useState<Class[]>(() => {
    const savedClasses = storage.getClasses();
    if (savedClasses.length === 0) {
      storage.initializeSampleData();
      return storage.getClasses();
    }
    return savedClasses;
  })
  const [schedule, setSchedule] = useState<Schedule | undefined>(undefined)
  const [startDate, setStartDate] = useState<Date>(() => new Date())
  const [blackoutPeriods, setBlackoutPeriods] = useState<BlackoutPeriod[]>([])
  const [constraints, setConstraints] = useState<ScheduleConstraints>(() => ({
    maxPeriodsPerDay: 8,
    maxPeriodsPerWeek: 40,
    consecutivePeriods: {
      maximum: 2,
      requireBreak: 1
    }
  }))
  const [preferences, setPreferences] = useState<SchedulePreferences>(() => {
    const savedPreferences = storage.getPreferences();
    return savedPreferences || {
      gradeGroups: [],
      preferSameGradeInDay: true,
      gradeProgression: 'none'
    };
  })
  const [showDeleteConfirm, setShowDeleteConfirm] = useState<string | null>(null)
  const [selectedClasses, setSelectedClasses] = useState<Set<string>>(new Set())
  const [editingClass, setEditingClass] = useState<Class | null>(null)
  const [activeTab, setActiveTab] = useState<'classes' | 'settings' | 'schedule'>('classes')

  // Save classes whenever they change
  useEffect(() => {
    storage.saveClasses(classes);
  }, [classes]);

  // Save schedule whenever it changes
  useEffect(() => {
    if (schedule) {
      storage.saveSchedule(schedule);
    }
  }, [schedule]);

  // Save preferences whenever they change
  useEffect(() => {
    storage.savePreferences(preferences);
  }, [preferences]);

  const handleSelectClass = (classId: string) => {
    setSelectedClasses(prev => {
      const newSet = new Set(prev);
      if (newSet.has(classId)) {
        newSet.delete(classId);
      } else {
        newSet.add(classId);
      }
      return newSet;
    });
  };

  const handleSelectAll = () => {
    if (selectedClasses.size === classes.length) {
      setSelectedClasses(new Set());
    } else {
      setSelectedClasses(new Set(classes.map(c => c.id)));
    }
  };

  const handleDeleteSelected = () => {
    if (selectedClasses.size === 0) return;
    
    const confirmMessage = selectedClasses.size === 1
      ? 'Are you sure you want to delete this class?'
      : `Are you sure you want to delete these ${selectedClasses.size} classes?`;
    
    if (window.confirm(confirmMessage)) {
      setClasses(prevClasses => 
        prevClasses.filter(cls => !selectedClasses.has(cls.id))
      );
      setSelectedClasses(new Set());
    }
  };

  const mixedGradeClasses = classes
    .filter(cls => cls.gradeLevel === 'mixed')
    .map(cls => cls.classNumber)

  const handleAddClass = (classData: Class) => {
    setClasses(prevClasses => [...prevClasses, classData])
  }

  const handleDeleteClass = (classId: string) => {
    setClasses(prevClasses => prevClasses.filter(cls => cls.id !== classId))
    setShowDeleteConfirm(null)
  }

  const handleUpdateConstraints = (data: {
    constraints: ScheduleConstraints
    preferences: SchedulePreferences
    startDate: Date
  }) => {
    setStartDate(data.startDate)
    setConstraints(data.constraints)
    setPreferences(data.preferences)
    storage.savePreferences(data.preferences)
  }

  const handleBlackoutChange = (newBlackoutPeriods: BlackoutPeriod[]) => {
    setBlackoutPeriods(newBlackoutPeriods)
    setSchedule(undefined)
  }

  const handleClassClick = (scheduledClass: ScheduledClass) => {
    console.log('Clicked class:', scheduledClass)
  }

  return (
    <div className="min-h-screen bg-background p-8">
      <div className="max-w-7xl mx-auto space-y-6">
        <h1 className="text-2xl font-bold text-foreground">Cooking Class Scheduler</h1>

        {/* Tab Navigation */}
        <div className="border-b border-border">
          <nav className="flex space-x-4" aria-label="Tabs">
            <button
              onClick={() => setActiveTab('classes')}
              className={`px-3 py-2 text-sm font-medium rounded-t-lg ${
                activeTab === 'classes'
                  ? 'bg-card text-primary border-b-2 border-primary'
                  : 'text-muted-foreground hover:text-foreground'
              }`}
            >
              Classes ({classes.length})
            </button>
            <button
              onClick={() => setActiveTab('settings')}
              className={`px-3 py-2 text-sm font-medium rounded-t-lg ${
                activeTab === 'settings'
                  ? 'bg-card text-primary border-b-2 border-primary'
                  : 'text-muted-foreground hover:text-foreground'
              }`}
            >
              Schedule Settings
            </button>
            <button
              onClick={() => setActiveTab('schedule')}
              className={`px-3 py-2 text-sm font-medium rounded-t-lg ${
                activeTab === 'schedule'
                  ? 'bg-card text-primary border-b-2 border-primary'
                  : 'text-muted-foreground hover:text-foreground'
              }`}
            >
              Schedule Preview
            </button>
          </nav>
        </div>

        {/* Classes Tab */}
        {activeTab === 'classes' && (
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            {/* Class List */}
            <div className="bg-card rounded-lg shadow-sm p-6">
              <div className="flex justify-between items-center mb-4">
                <h2 className="text-lg font-semibold">Added Classes</h2>
                <div className="space-x-2">
                  {selectedClasses.size > 0 && (
                    <button
                      onClick={handleDeleteSelected}
                      className="px-3 py-1.5 text-sm bg-destructive text-destructive-foreground rounded-md hover:bg-destructive/90"
                    >
                      Delete Selected ({selectedClasses.size})
                    </button>
                  )}
                  {classes.length > 0 && (
                    <button
                      onClick={handleSelectAll}
                      className="px-3 py-1.5 text-sm bg-secondary text-secondary-foreground rounded-md hover:bg-secondary/80"
                    >
                      {selectedClasses.size === classes.length ? 'Deselect All' : 'Select All'}
                    </button>
                  )}
                </div>
              </div>
              <div className="overflow-y-auto max-h-[600px] space-y-2">
                {classes.map(cls => (
                  <div
                    key={cls.id}
                    className={`flex items-center p-4 bg-muted rounded-lg hover:bg-muted/90 ${
                      editingClass?.id === cls.id ? 'ring-2 ring-primary' : ''
                    }`}
                  >
                    <input
                      type="checkbox"
                      checked={selectedClasses.has(cls.id)}
                      onChange={() => handleSelectClass(cls.id)}
                      className="mr-4 h-4 w-4 rounded border-gray-300 text-primary focus:ring-primary"
                      onClick={e => e.stopPropagation()}
                    />
                    <div 
                      className="flex-grow cursor-pointer"
                      onClick={() => setEditingClass(cls)}
                    >
                      <div className="font-medium">Class {cls.classNumber}</div>
                      <div className="text-sm text-muted-foreground">
                        {cls.teacher} • Grade {cls.gradeLevel}
                      </div>
                    </div>
                  </div>
                ))}
                {classes.length === 0 && (
                  <p className="text-center text-muted-foreground py-4">
                    No classes added yet. Use the form to add classes.
                  </p>
                )}
              </div>
            </div>

            {/* Add/Edit Form */}
            <div className="bg-card rounded-lg shadow-sm p-6">
              <h2 className="text-lg font-semibold mb-4">
                {editingClass ? 'Edit Class' : 'Add New Class'}
              </h2>
              <ClassForm
                onSubmit={(classData) => {
                  if (editingClass) {
                    setClasses(prev =>
                      prev.map(cls =>
                        cls.id === editingClass.id
                          ? { ...classData, id: cls.id }
                          : cls
                      )
                    )
                    setEditingClass(null)
                  } else {
                    setClasses(prev => [...prev, classData])
                  }
                }}
                onCancel={editingClass ? () => setEditingClass(null) : undefined}
                initialClass={editingClass}
              />
            </div>
          </div>
        )}

        {/* Settings Tab */}
        {activeTab === 'settings' && (
          <div className="bg-card rounded-lg shadow-sm p-6">
            <h2 className="text-lg font-semibold mb-4">Schedule Settings</h2>
            <ScheduleConstraintsForm
              initialConstraints={constraints}
              initialPreferences={preferences}
              initialStartDate={startDate}
              classes={classes}
              onSubmit={handleUpdateConstraints}
            />
          </div>
        )}

        {/* Schedule Preview Tab */}
        {activeTab === 'schedule' && (
          <div className="space-y-6">
            {/* Blackout Period Selection */}
            <div className="bg-card rounded-lg shadow-sm p-6">
              <h2 className="text-lg font-semibold mb-4">Blackout Periods</h2>
              <p className="text-sm text-muted-foreground mb-4">
                Click on periods to mark them as unavailable for scheduling.
              </p>
              <ScheduleDisplay
                startDate={startDate}
                blackoutPeriods={blackoutPeriods}
                onBlackoutChange={setBlackoutPeriods}
              />
            </div>

            {/* Schedule Generation */}
            <div className="bg-card rounded-lg shadow-sm p-6">
              <ScheduleGenerator
                classes={classes}
                constraints={constraints}
                preferences={preferences}
                startDate={startDate}
                blackoutPeriods={blackoutPeriods}
              />
            </div>
          </div>
        )}

        {/* Delete Confirmation Modal */}
        {showDeleteConfirm && (
          <div className="fixed inset-0 bg-black/50 flex items-center justify-center">
            <div className="bg-card p-6 rounded-lg max-w-sm w-full mx-4">
              <h3 className="text-lg font-semibold mb-2">Delete Class</h3>
              <p className="text-muted-foreground mb-4">
                Are you sure you want to delete this class? This action cannot be undone.
              </p>
              <div className="flex justify-end gap-2">
                <button
                  onClick={() => setShowDeleteConfirm(null)}
                  className="px-4 py-2 text-sm bg-secondary text-secondary-foreground rounded-md hover:bg-secondary/90"
                >
                  Cancel
                </button>
                <button
                  onClick={() => {
                    setClasses(prev => prev.filter(cls => cls.id !== showDeleteConfirm))
                    setShowDeleteConfirm(null)
                  }}
                  className="px-4 py-2 text-sm bg-destructive text-destructive-foreground rounded-md hover:bg-destructive/90"
                >
                  Delete
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  )
}

export default App

================
File: src/index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: 0 0% 100%;
  --foreground: 222.2 84% 4.9%;
  --card: 0 0% 100%;
  --card-foreground: 222.2 84% 4.9%;
  --popover: 0 0% 100%;
  --popover-foreground: 222.2 84% 4.9%;
  --primary: 221.2 83.2% 53.3%;
  --primary-foreground: 210 40% 98%;
  --secondary: 210 40% 96.1%;
  --secondary-foreground: 222.2 47.4% 11.2%;
  --muted: 210 40% 96.1%;
  --muted-foreground: 215.4 16.3% 46.9%;
  --accent: 210 40% 96.1%;
  --accent-foreground: 222.2 47.4% 11.2%;
  --destructive: 0 84.2% 60.2%;
  --destructive-foreground: 210 40% 98%;
  --border: 214.3 31.8% 91.4%;
  --input: 214.3 31.8% 91.4%;
  --ring: 221.2 83.2% 53.3%;
  --radius: 0.5rem;
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground antialiased min-h-screen;
  }
}

@layer components {
  .btn {
    @apply inline-flex justify-center rounded-md px-4 py-2 text-sm font-medium shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2;
  }

  .btn-primary {
    @apply bg-primary text-primary-foreground hover:bg-primary/90 focus:ring-primary;
  }

  .btn-secondary {
    @apply bg-secondary text-secondary-foreground hover:bg-secondary/80 focus:ring-secondary;
  }

  .btn-destructive {
    @apply bg-destructive text-destructive-foreground hover:bg-destructive/90 focus:ring-destructive;
  }

  .form-input {
    @apply block w-full rounded-md border-gray-300 shadow-sm focus:border-primary focus:ring-primary sm:text-sm;
  }

  .form-checkbox {
    @apply rounded border-gray-300 text-primary focus:ring-primary;
  }
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.animate-fade-in {
  animation: fadeIn 0.3s ease-out forwards;
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateX(-10px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.animate-slide-in {
  animation: slideIn 0.3s ease-out forwards;
}

================
File: src/main.tsx
================
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)

================
File: src/types.ts
================
// Types for class scheduling system

export type GradeGroup = 'elementary' | 'middle' | 'high'
export type GradeProgression = 'none' | 'low-to-high' | 'high-to-low'

export interface Conflict {
  date: Date
  period: number
}

export interface Class {
  id: string
  name: string
  gradeLevel: string
  gradeGroup: GradeGroup
  teacher: string
  totalConflicts: Conflict[]
  partialConflicts: Conflict[]
}

export interface ScheduledClass extends Class {
  date: Date
  period: number
}

export interface Schedule {
  classes: ScheduledClass[]
  score: {
    totalLength: number
    gradeGroupCohesion: number
    distributionQuality: number
    constraintViolations: number
    gradeProgression: number
    partialConflictPenalty: number
  }
}

export interface ScheduleConstraints {
  maxPeriodsPerDay: number
  maxClassesPerDay: number
  maxConsecutivePeriods: number
  requiredBreakLength: number
}

export interface SchedulePreferences {
  gradeProgression: GradeProgression
  preferredStartTime?: Date
  preferredEndTime?: Date
  preferredDaysOfWeek?: number[]
  teacherPreferences?: {
    [teacherId: string]: {
      preferredPeriods?: number[]
      preferredDays?: number[]
    }
  }
}

================
File: src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: tests/conflict_handling.test.ts
================
import { ScheduleEngine } from '../src/utils/scheduleEngine';
import { SimulatedAnnealing } from '../src/utils/simulatedAnnealing';
import { Class, Schedule, ScheduleScore } from '../src/types';

describe('Conflict Handling Tests', () => {
  // Test utilities
  const createTestClass = (id: string, totalConflicts = [], partialConflicts = []): Class => ({
    id,
    name: `Test Class ${id}`,
    totalConflicts,
    partialConflicts,
    gradeGroup: 'test-group',
    teacher: 'test-teacher'
  });

  const createDate = (dayOffset: number = 0) => {
    const date = new Date();
    date.setDate(date.getDate() + dayOffset);
    return date;
  };

  describe('Schedule Engine Conflict Handling', () => {
    let engine: ScheduleEngine;

    beforeEach(() => {
      engine = new ScheduleEngine({
        maxPeriodsPerDay: 8,
        maxPeriodsPerWeek: 30,
        blackoutPeriods: []
      });
    });

    test('should correctly identify and handle total conflicts', () => {
      const date = createDate();
      const conflictingClass = createTestClass('1', [
        { date, period: 1 }
      ]);

      const result = engine['checkClassConflicts'](date, 1, conflictingClass);
      expect(result.hasConflict).toBe(true);
      expect(result.partialConflictCount).toBe(0);
    });

    test('should count partial conflicts without blocking scheduling', () => {
      const date = createDate();
      const classWithPartialConflicts = createTestClass('1', [], [
        { date, period: 1 },
        { date, period: 1 }
      ]);

      const result = engine['checkClassConflicts'](date, 1, classWithPartialConflicts);
      expect(result.hasConflict).toBe(false);
      expect(result.partialConflictCount).toBe(2);
    });

    test('should apply appropriate penalties for partial conflicts in scoring', () => {
      const date = createDate();
      const classWithConflicts = createTestClass('1', [], [
        { date, period: 1 },
        { date, period: 1 }
      ]);

      const schedule = new Schedule([{
        class: classWithConflicts,
        date,
        period: 1
      }]);

      const score = engine.calculateScore(schedule);
      expect(score.partialConflictPenalty).toBeGreaterThan(0);
      expect(score.partialConflictPenalty).toBeLessThanOrEqual(1);
    });
  });

  describe('Simulated Annealing with Conflict Handling', () => {
    let annealing: SimulatedAnnealing;
    let engine: ScheduleEngine;

    beforeEach(() => {
      engine = new ScheduleEngine({
        maxPeriodsPerDay: 8,
        maxPeriodsPerWeek: 30,
        blackoutPeriods: []
      });
      annealing = new SimulatedAnnealing(engine);
    });

    test('should prefer periods with fewer conflicts during mutation', async () => {
      const date = createDate();
      const classWithConflicts = createTestClass('1', [], [
        { date, period: 1 },
        { date, period: 2 },
        { date, period: 3 }
      ]);

      const initialSchedule = new Schedule([{
        class: classWithConflicts,
        date,
        period: 1
      }]);

      // Run multiple iterations to account for randomness
      let betterPeriodCount = 0;
      const iterations = 100;

      for (let i = 0; i < iterations; i++) {
        const mutated = annealing['mutateSchedule'](initialSchedule);
        const period = mutated.classes[0].period;
        if (period > 3) betterPeriodCount++;
      }

      // Should prefer conflict-free periods more than 60% of the time
      expect(betterPeriodCount / iterations).toBeGreaterThan(0.6);
    });

    test('should generate schedules with minimal conflicts', async () => {
      const classes = [
        createTestClass('1', [], [{ date: createDate(), period: 1 }]),
        createTestClass('2', [], [{ date: createDate(), period: 2 }]),
        createTestClass('3', [], [{ date: createDate(), period: 3 }])
      ];

      const result = await annealing.optimize(classes);
      const score = engine.calculateScore(result);

      // Expect relatively low conflict penalty due to conflict avoidance
      expect(score.partialConflictPenalty).toBeLessThan(0.3);
    });

    test('should maintain schedule quality with new scoring weights', async () => {
      const classes = Array.from({ length: 10 }, (_, i) => 
        createTestClass(String(i), [], [
          { date: createDate(), period: i % 4 }
        ])
      );

      const result = await annealing.optimize(classes);
      const score = engine.calculateScore(result);

      // Verify balanced scoring
      expect(score.totalLength).toBeGreaterThan(0.7); // Good completion rate
      expect(score.gradeGroupCohesion).toBeGreaterThan(0.5); // Reasonable cohesion
      expect(score.distributionQuality).toBeGreaterThan(0.5); // Good distribution
      expect(score.partialConflictPenalty).toBeLessThan(0.3); // Low conflicts
    });
  });
});

================
File: tests/performance.test.ts
================
import { ScheduleEngine } from '../src/utils/scheduleEngine';
import { SimulatedAnnealing } from '../src/utils/simulatedAnnealing';
import { Class, Schedule } from '../src/types';

describe('Performance Tests', () => {
  const createTestClass = (id: string, totalConflicts = [], partialConflicts = []): Class => ({
    id,
    name: `Test Class ${id}`,
    totalConflicts,
    partialConflicts,
    gradeGroup: `group-${Math.floor(parseInt(id) / 3)}`,
    teacher: `teacher-${Math.floor(parseInt(id) / 4)}`
  });

  const createDate = (dayOffset: number = 0) => {
    const date = new Date();
    date.setDate(date.getDate() + dayOffset);
    return date;
  };

  const generateTestClasses = (count: number, conflictDensity: number = 0.2) => {
    return Array.from({ length: count }, (_, i) => {
      const partialConflicts = [];
      // Add partial conflicts based on density
      const conflictCount = Math.floor(count * conflictDensity);
      for (let j = 0; j < conflictCount; j++) {
        partialConflicts.push({
          date: createDate(Math.floor(j / 8)),
          period: (j % 8) + 1
        });
      }
      return createTestClass(String(i), [], partialConflicts);
    });
  };

  describe('Schedule Optimization Performance', () => {
    let engine: ScheduleEngine;
    let annealing: SimulatedAnnealing;

    beforeEach(() => {
      engine = new ScheduleEngine({
        maxPeriodsPerDay: 8,
        maxPeriodsPerWeek: 30,
        blackoutPeriods: []
      });
      annealing = new SimulatedAnnealing(engine);
    });

    const runPerformanceTest = async (
      classCount: number,
      conflictDensity: number
    ) => {
      const classes = generateTestClasses(classCount, conflictDensity);
      
      const startTime = process.hrtime();
      const result = await annealing.optimize(classes);
      const [seconds, nanoseconds] = process.hrtime(startTime);
      const duration = seconds + nanoseconds / 1e9;

      const score = engine.calculateScore(result);
      
      return {
        duration,
        score,
        scheduledCount: result.classes.length,
        expectedCount: classes.length
      };
    };

    test('small schedule (20 classes) performance', async () => {
      const result = await runPerformanceTest(20, 0.2);
      
      expect(result.duration).toBeLessThan(5); // Should complete within 5 seconds
      expect(result.score.totalLength).toBeGreaterThan(0.9); // >90% completion
      expect(result.score.partialConflictPenalty).toBeLessThan(0.2);
    });

    test('medium schedule (50 classes) performance', async () => {
      const result = await runPerformanceTest(50, 0.2);
      
      expect(result.duration).toBeLessThan(10); // Should complete within 10 seconds
      expect(result.score.totalLength).toBeGreaterThan(0.85); // >85% completion
      expect(result.score.partialConflictPenalty).toBeLessThan(0.3);
    });

    test('large schedule (100 classes) performance', async () => {
      const result = await runPerformanceTest(100, 0.2);
      
      expect(result.duration).toBeLessThan(20); // Should complete within 20 seconds
      expect(result.score.totalLength).toBeGreaterThan(0.8); // >80% completion
      expect(result.score.partialConflictPenalty).toBeLessThan(0.4);
    });

    test('high conflict density impact', async () => {
      const lowConflict = await runPerformanceTest(50, 0.1);
      const highConflict = await runPerformanceTest(50, 0.4);

      // High conflict density should still maintain reasonable completion
      expect(highConflict.score.totalLength).toBeGreaterThan(0.7);
      // But should have higher penalty than low conflict
      expect(highConflict.score.partialConflictPenalty)
        .toBeGreaterThan(lowConflict.score.partialConflictPenalty);
    });

    test('schedule quality metrics', async () => {
      const result = await runPerformanceTest(50, 0.2);
      const { score } = result;

      // Verify our scoring weights are working as intended
      expect(score.totalLength * 0.45 +
             score.gradeGroupCohesion * 0.25 +
             score.distributionQuality * 0.15 -
             score.partialConflictPenalty * 0.15)
        .toBeGreaterThan(0.7); // Overall score should be good

      // Individual metrics should be balanced
      expect(score.gradeGroupCohesion).toBeGreaterThan(0.5);
      expect(score.distributionQuality).toBeGreaterThan(0.5);
    });
  });
});

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: AI_RULES_AND_GUIDELINES.md
================
# AI Rules and Guidelines for ClassRotation Development

This document outlines the rules, best practices, and guidelines that AI must follow when assisting with the development of the ClassRotation project.

## 1. Algorithm Development and Optimization

- Always consider the impact on total rotation length when making algorithm changes
- Document scheduling decisions and trade-offs made by the algorithm
- Track algorithm performance metrics and optimization attempts
- Maintain multiple solution approaches for comparison
- Document any assumptions made about scheduling preferences
- Test with various constraint combinations to ensure robustness

## 2. Constraint Management

- Clearly separate hard constraints from soft constraints
- Document the priority order of constraints
- Track the impact of each constraint on schedule quality
- Provide clear explanations for constraint violations
- Maintain flexibility for future constraint additions
- Test edge cases for each constraint type

## 3. Grade Group Management

- Document all grade grouping decisions and changes
- Track group scheduling preferences and their impact
- Maintain flexibility for group configuration changes
- Test group scheduling with various class combinations
- Document group conflict resolution strategies

## 4. User Interface Guidelines

- Prioritize clarity in schedule visualization
- Provide clear feedback for scheduling decisions
- Make constraint violations visually obvious
- Enable intuitive manual schedule adjustments
- Support clear visualization of grade groups
- Maintain consistent interaction patterns for scheduling operations

## 5. Project Documentation
- Follow the documentation structure in directory_index.md
- Keep documentation up to date with all changes
- Update changelog.md for all significant changes
- Track tasks and progress in tasks.md
- Document performance metrics and improvements
- Follow established documentation guidelines

## 6. Task Breakdown and Execution

- Break down all user instructions into clear, numbered steps
- Include both actions and reasoning for each step
- Flag potential issues before they arise
- Verify the completion of each step before proceeding to the next
- If errors occur, document them, return to previous steps, and retry as needed

## 7. Code Structure and Organization

- Keep files small and modular
- Split large components into smaller, manageable parts
- Move constants, configurations, and long strings to separate files
- Use descriptive names for files, functions, and variables
- Document all file dependencies and maintain a clean project structure

## 8. Error Handling and Reporting

- Implement detailed and actionable error reporting
- Log errors with context and timestamps
- Provide users with clear steps for error recovery
- Track error history to identify patterns
- Implement escalation procedures for unresolved issues
- Ensure all systems have robust error handling mechanisms

## 9. Dependencies and Libraries

- Always use the most stable versions of dependencies to ensure compatibility
- Regularly update libraries, avoiding changes that might disrupt functionality

## 10. Code Documentation

- Write clear, concise comments for all sections of code
- Use only one set of triple quotes for docstrings to prevent syntax errors
- Document the purpose and expected behavior of functions and modules

## 11. Change Management

- Review all changes to assess their impact on other parts of the project
- Test changes thoroughly to ensure consistency and prevent conflicts
- Document all changes, their outcomes, and any corrective actions in the changelog

## 12. Problem-Solving Approach

- Exhaust all options before determining an action is impossible
- When evaluating feasibility, check alternatives in all directions: up/down and left/right
- Only conclude an action cannot be performed after all possibilities have been tested

## 13. Testing and Quality Assurance

- Test scheduling algorithm with various class combinations
- Validate constraint enforcement
- Test grade group scheduling scenarios
- Verify manual scheduling operations
- Document test scenarios and results
- Maintain test cases for known edge cases

## 14. Performance Optimization

- Optimize scheduling algorithm efficiency
- Implement caching for computed schedules
- Minimize unnecessary re-computations
- Profile algorithm performance regularly
- Track and optimize memory usage during schedule generation
- Benchmark different scheduling approaches

## 15. Security Best Practices

- Validate all user inputs for scheduling constraints
- Ensure schedule data integrity
- Implement proper error boundaries to prevent UI crashes
- Maintain data consistency during manual schedule adjustments

## 16. Documentation

- Maintain clear documentation of the scheduling algorithm
- Document all constraints and their interactions
- Provide clear guides for manual scheduling operations
- Keep grade group configuration documentation current
- Document known scheduling limitations and workarounds

Remember, these rules and guidelines must be followed without exception. Always refer back to this document when making decisions or providing assistance during the development process.

================
File: eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

================
File: index.html
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cooking Class Scheduler</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: jest.config.ts
================
import type { Config } from '@jest/types';

const config: Config.InitialOptions = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src'],
  testMatch: [
    '**/__tests__/**/*.test.ts?(x)',
    '**/?(*.)+(spec|test).ts?(x)'
  ],
  testPathIgnorePatterns: [
    '/node_modules/',
    '/__tests__/utils/'
  ],
  transform: {
    '^.+\\.tsx?$': 'ts-jest',
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov'],
  coveragePathIgnorePatterns: ['/node_modules/', '/__tests__/'],
  verbose: true,
};

export default config;

================
File: package.json
================
{
  "name": "class-scheduler",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:parallel": "jest --maxWorkers=50%",
    "test:fast": "jest --bail --no-cache",
    "test:single": "jest -t",
    "test:debug": "node --inspect-brk node_modules/.bin/jest --runInBand",
    "test:coverage": "jest --coverage"
  },
  "dependencies": {
    "@radix-ui/react-dropdown-menu": "^2.1.2",
    "@radix-ui/react-tooltip": "^1.1.4",
    "@types/jspdf": "^2.0.0",
    "clsx": "^2.1.1",
    "jspdf": "^2.5.2",
    "react": "^18.3.1",
    "react-dnd": "^16.0.1",
    "react-dnd-html5-backend": "^16.0.1",
    "react-dom": "^18.3.1",
    "tailwind-merge": "^2.5.4"
  },
  "devDependencies": {
    "@eslint/js": "^9.13.0",
    "@tailwindcss/forms": "^0.5.9",
    "@types/jest": "^29.5.14",
    "@types/react": "^18.3.12",
    "@types/react-dom": "^18.3.1",
    "@vitejs/plugin-react": "^4.3.3",
    "autoprefixer": "^10.4.20",
    "date-fns": "^4.1.0",
    "eslint": "^9.13.0",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.14",
    "globals": "^15.11.0",
    "jest": "^29.7.0",
    "postcss": "^8.4.49",
    "tailwindcss": "^3.4.15",
    "ts-jest": "^29.2.5",
    "ts-node": "^10.9.2",
    "typescript": "~5.6.2",
    "typescript-eslint": "^8.11.0",
    "vite": "^5.4.11"
  }
}

================
File: postcss.config.js
================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: project_summary.md
================
# ClassRotation Scheduling System Development

## Project Overview
A sophisticated class scheduling system using parallel processing and simulated annealing to generate optimal schedules while handling complex constraints and preferences.

## Project Structure

### Core Documentation
- `README.md`: Project overview and quick start
- `docs/`: Technical documentation
  * system_overview.md
  * architecture_overview.md
  * technical_implementation.md
  * performance_guide.md
  * testing_guide.md
  * ai_onboarding.md
  * directory_index.md

### Project Status
- `changelog.md`: Version history
- `tasks.md`: Task tracking
- `project_summary.md`: This file

### Source Code
- `/src/`: Core implementation
  * types/: Type definitions
  * engine/: Scheduling logic
  * constraints/: Constraint system
  * workers/: Parallel processing

### Tests
- `__tests__/`: Test suite
  * unit/: Unit tests
  * integration/: Integration tests
  * performance/: Performance tests
  * fixtures/: Test data

### Development System

### Memlog System
The project uses a comprehensive logging and tracking system consisting of:
1. **tasks.log**: 
   - Tracks active, completed, blocked, and future tasks
   - Updated before each development session
   - Includes task priority and dependencies
   - Documents progress and blockers

2. **changelog.md**: 
   - Documents all project changes and updates
   - Categorizes changes (Added, Changed, Fixed, Removed)
   - Maintains version history
   - Links changes to task completions

3. **algorithm_performance.md**:
   - Tracks algorithm improvements and their impact
   - Documents performance metrics and bottlenecks
   - Records test scenarios and results
   - Provides comparative analysis of approaches

### Documentation System

### Documentation Structure
The project uses a comprehensive documentation system tracked by `docs/directory_index.md`, which includes:
- Core documentation (`README.md`, `algorithm_rationale.md`)
- Memory logging system (`/memlog/`)
- Technical documentation (`/docs/`)
- Test documentation (`/tests/`)

### Documentation Guidelines
- All documentation updates follow dependency chains defined in directory_index.md
- Files are updated together based on type of change (code, algorithm, architecture)
- Regular maintenance ensures documentation stays current and accurate

## Project Summary: Class Scheduling System

### Current Performance
- 50 classes: 56% success rate
- Test suite duration: ~350 seconds
- Memory usage: ~200MB peak

### Target Performance
- 50 classes: 95% success rate
- Test suite duration: < 100 seconds
- Memory usage: < 150MB peak

### Technical Stack
- Language: TypeScript (strict mode)
- Frontend: React
- Testing: Jest + React Testing Library
- Parallel Processing: Worker Threads

### Core Components
1. **Schedule Engine**:
   - Base scheduling logic
   - Constraint validation
   - Score calculation

2. **Simulated Annealing**:
   - Temperature management
   - Mutation strategies
   - Solution exploration

3. **Parallel Processing**:
   - Worker coordination
   - SharedArrayBuffer implementation
   - Solution aggregation

4. **Constraint System**:
   - Hard constraints
   - Soft constraints
   - Grade group optimization

## Current Challenges

### 1. Performance Optimization
- Constraint validation efficiency
- Memory usage optimization
- Worker communication overhead
- Test suite execution time

### 2. Algorithm Enhancement
- Scheduling success rate
- Grade group cohesion
- Solution quality
- Convergence speed

### 3. Technical Debt
- Incremental validation needed
- SharedArrayBuffer implementation pending
- Test data generation improvements required
- Performance profiling infrastructure needed

## Development Priorities

### Short Term
1. Implement incremental constraint validation
2. Add SharedArrayBuffer for worker communication
3. Develop procedural test data generation
4. Optimize memory usage
5. Improve test suite performance

### Medium Term
1. Enhance grade group optimization
2. Implement advanced parallel processing
3. Add performance profiling tools
4. Improve solution quality metrics
5. Enhance manual adjustment UI

### Long Term
1. Machine learning parameter optimization
2. Real-time constraint feedback
3. Advanced visualization tools
4. Adaptive constraint relaxation
5. Cloud-based parallel processing

## Project Goals

### 1. Performance
- Achieve 95% scheduling success rate
- Reduce test suite duration by 70%
- Decrease memory usage by 25%
- Enable real-time UI interactions

### 2. Quality
- Comprehensive test coverage
- Robust constraint validation
- Reliable parallel processing
- Intuitive user interface

### 3. Maintainability
- Clear documentation
- Type-safe codebase
- Modular architecture
- Efficient testing

## Next Steps
1. Complete performance optimization tasks
2. Implement parallel processing improvements
3. Enhance test infrastructure
4. Continue documentation refinement
5. Add advanced features

## Current Architecture

#### Core Components
1. **ScheduleEngine** (`scheduleEngine.ts`):
   - Advanced scheduling algorithm
   - Multiple candidate solution tracking (max 100 solutions)
   - Sophisticated scoring system
   - Comprehensive constraint handling
   - Protected class access for derived schedulers

2. **SimulatedAnnealingScheduler** (`simulatedAnnealing.ts`):
   - Extends ScheduleEngine
   - Temperature-based optimization
   - Neighbor generation with mutation strategies
   - Prioritizes unscheduled class placement
   - Weighted completeness scoring

3. **ParallelScheduler** (`parallelScheduler.ts`):
   - Multi-worker coordination
   - Parameter distribution
   - Result aggregation
   - Mock worker implementation (true workers planned)

## Current Status

#### Achievements
- ✅ Base scheduling engine implemented
- ✅ Simulated annealing optimization added
- ✅ Basic parallel processing framework
- ✅ Comprehensive test suite (~90% coverage)
- ✅ Sophisticated scoring system

#### Active Challenges
1. Incomplete Class Scheduling:
   - Currently scheduling 28/50 classes (56%)
   - Investigating scoring thresholds
   - Exploring parameter optimization

2. Parallel Processing:
   - Mock worker implementation
   - Need true Worker Thread implementation
   - Solution quality not yet improving with workers

3. Performance:
   - Test suite execution: ~350s
   - Need optimization for large datasets
   - Parallel processing expected to help

## Next Development Phase

#### Immediate Priorities
1. Fix incomplete class scheduling:
   - Adjust scoring thresholds
   - Implement restart mechanism
   - Optimize simulated annealing parameters

2. Implement true parallel processing:
   - Worker Thread implementation
   - Worker coordination mechanism
   - Parameter optimization

3. Performance optimization:
   - Profile current implementation
   - Identify bottlenecks
   - Implement optimizations

#### Future Enhancements
- Machine learning for parameter optimization
- Visualization tools
- Advanced mutation strategies
- Progress tracking
- Enhanced error handling

### Technical Stack
- TypeScript/Node.js
- Jest for testing
- Worker Threads API (planned)
- React + Vite for frontend

### Development Principles
- Modular design
- Test-driven development
- Performance-conscious implementation
- Comprehensive error handling
- Clear documentation

### Current Metrics
- Test Coverage: ~90%
- Scheduling Success: 56%
- Solution Quality Score: 2.0 (baseline)
- Test Suite Duration: ~350s

================
File: README.md
================
# Class Scheduler

An advanced class scheduling system using parallel processing and simulated annealing to generate optimal class schedules.

## Features

- Sophisticated scheduling algorithm with simulated annealing
- Parallel processing for improved solution quality
- Comprehensive constraint handling
  - Time slot conflicts
  - Room availability
  - Teacher availability
  - Grade level progression
  - Consecutive period limits
- Configurable scheduling preferences
- Grade group cohesion optimization
- Adaptive scheduling parameters
- Score-based optimization (completeness, cohesion, distribution)

## Project Status

Core algorithm implementation complete. Moving to application development phase:

### Completed
- Base scheduling engine with constraint validation
- Simulated annealing implementation with 70-97% optimization scores
- Parallel processing framework
- Comprehensive test suite
- Score-based optimization system

### In Progress
- User interface development
- Schedule visualization
- Data persistence layer

### Planned
- Manual schedule adjustments
- Export and sharing capabilities
- Schedule templates
- User preferences system

## Architecture

The system consists of three main components:

1. **ScheduleEngine**: Core scheduling logic with constraint handling
2. **SimulatedAnnealingScheduler**: Advanced optimization using simulated annealing
   - Adaptive temperature control
   - Multi-objective optimization
   - Configurable weights for different objectives
3. **ParallelScheduler**: Parallel processing for improved solutions

### Key Files

- `/src/utils/scheduleEngine.ts`: Base scheduling implementation
- `/src/utils/simulatedAnnealing.ts`: Simulated annealing optimizer
- `/src/utils/parallelScheduler.ts`: Parallel processing coordinator
- `/src/__tests__/`: Comprehensive test suite

## Development

### Prerequisites

- Node.js
- TypeScript
- Jest for testing

### Setup

1. Clone the repository
2. Install dependencies:
   ```bash
   npm install
   ```
3. Run tests:
   ```bash
   npm test
   ```

### Algorithm Performance

The scheduling algorithm achieves the following optimization scores:
- Small schedules (3-15 classes): 92-98% optimization
- Medium schedules (20-22 classes): 85-97% optimization
- Large schedules (30+ classes): 73-74% optimization

Optimization considers:
- Schedule completeness (40%)
- Grade group cohesion (30%)
- Class distribution (30%)

## Testing

Run the test suite:

```bash
npm test
```

Test coverage includes:
- Unit tests for core components
- Integration tests for scheduling workflows
- Performance benchmarks
- Constraint validation

## Contributing

Currently in active development. Contributions welcome for:

- User interface components
- Additional scheduling features
- Performance optimization
- Documentation
- User experience improvements

## License

[Add appropriate license]

## Acknowledgments

- Built with React + TypeScript + Vite
- Uses Jest for testing
- Implements simulated annealing algorithm

================
File: storage-inspector.html
================
<!DOCTYPE html>
<html>
<head>
    <title>Storage Inspector</title>
</head>
<body>
    <pre id='output'></pre>
    <script>
        const output = document.getElementById('output');
        const items = {};
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            items[key] = localStorage.getItem(key);
        }
        output.textContent = JSON.stringify(items, null, 2);
    </script>
</body>
</html>

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
    },
  },
  plugins: [require("@tailwindcss/forms")],
}

================
File: tsconfig.app.json
================
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "composite": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "types": ["vite/client"]
  },
  "include": ["src/**/*.ts", "src/**/*.tsx", "src/**/*.d.ts"],
  "exclude": ["src/**/*.spec.ts", "src/**/*.test.ts"]
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "allowJs": true,
    "esModuleInterop": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

================
File: tsconfig.node.json
================
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "strict": true
  },
  "include": ["vite.config.ts"]
}

================
File: tsconfig.node.tsbuildinfo
================
{"fileNames":["./node_modules/typescript/lib/lib.d.ts","./node_modules/typescript/lib/lib.es5.d.ts","./node_modules/typescript/lib/lib.es2015.d.ts","./node_modules/typescript/lib/lib.es2016.d.ts","./node_modules/typescript/lib/lib.es2017.d.ts","./node_modules/typescript/lib/lib.es2018.d.ts","./node_modules/typescript/lib/lib.es2019.d.ts","./node_modules/typescript/lib/lib.es2020.d.ts","./node_modules/typescript/lib/lib.dom.d.ts","./node_modules/typescript/lib/lib.webworker.importscripts.d.ts","./node_modules/typescript/lib/lib.scripthost.d.ts","./node_modules/typescript/lib/lib.es2015.core.d.ts","./node_modules/typescript/lib/lib.es2015.collection.d.ts","./node_modules/typescript/lib/lib.es2015.generator.d.ts","./node_modules/typescript/lib/lib.es2015.iterable.d.ts","./node_modules/typescript/lib/lib.es2015.promise.d.ts","./node_modules/typescript/lib/lib.es2015.proxy.d.ts","./node_modules/typescript/lib/lib.es2015.reflect.d.ts","./node_modules/typescript/lib/lib.es2015.symbol.d.ts","./node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts","./node_modules/typescript/lib/lib.es2016.array.include.d.ts","./node_modules/typescript/lib/lib.es2016.intl.d.ts","./node_modules/typescript/lib/lib.es2017.date.d.ts","./node_modules/typescript/lib/lib.es2017.object.d.ts","./node_modules/typescript/lib/lib.es2017.sharedmemory.d.ts","./node_modules/typescript/lib/lib.es2017.string.d.ts","./node_modules/typescript/lib/lib.es2017.intl.d.ts","./node_modules/typescript/lib/lib.es2017.typedarrays.d.ts","./node_modules/typescript/lib/lib.es2018.asyncgenerator.d.ts","./node_modules/typescript/lib/lib.es2018.asynciterable.d.ts","./node_modules/typescript/lib/lib.es2018.intl.d.ts","./node_modules/typescript/lib/lib.es2018.promise.d.ts","./node_modules/typescript/lib/lib.es2018.regexp.d.ts","./node_modules/typescript/lib/lib.es2019.array.d.ts","./node_modules/typescript/lib/lib.es2019.object.d.ts","./node_modules/typescript/lib/lib.es2019.string.d.ts","./node_modules/typescript/lib/lib.es2019.symbol.d.ts","./node_modules/typescript/lib/lib.es2019.intl.d.ts","./node_modules/typescript/lib/lib.es2020.bigint.d.ts","./node_modules/typescript/lib/lib.es2020.date.d.ts","./node_modules/typescript/lib/lib.es2020.promise.d.ts","./node_modules/typescript/lib/lib.es2020.sharedmemory.d.ts","./node_modules/typescript/lib/lib.es2020.string.d.ts","./node_modules/typescript/lib/lib.es2020.symbol.wellknown.d.ts","./node_modules/typescript/lib/lib.es2020.intl.d.ts","./node_modules/typescript/lib/lib.es2020.number.d.ts","./node_modules/typescript/lib/lib.decorators.d.ts","./node_modules/typescript/lib/lib.decorators.legacy.d.ts","./node_modules/@types/node/compatibility/disposable.d.ts","./node_modules/@types/node/compatibility/indexable.d.ts","./node_modules/@types/node/compatibility/iterators.d.ts","./node_modules/@types/node/compatibility/index.d.ts","./node_modules/@types/node/ts5.6/globals.typedarray.d.ts","./node_modules/@types/node/ts5.6/buffer.buffer.d.ts","./node_modules/undici-types/header.d.ts","./node_modules/undici-types/readable.d.ts","./node_modules/undici-types/file.d.ts","./node_modules/undici-types/fetch.d.ts","./node_modules/undici-types/formdata.d.ts","./node_modules/undici-types/connector.d.ts","./node_modules/undici-types/client.d.ts","./node_modules/undici-types/errors.d.ts","./node_modules/undici-types/dispatcher.d.ts","./node_modules/undici-types/global-dispatcher.d.ts","./node_modules/undici-types/global-origin.d.ts","./node_modules/undici-types/pool-stats.d.ts","./node_modules/undici-types/pool.d.ts","./node_modules/undici-types/handlers.d.ts","./node_modules/undici-types/balanced-pool.d.ts","./node_modules/undici-types/agent.d.ts","./node_modules/undici-types/mock-interceptor.d.ts","./node_modules/undici-types/mock-agent.d.ts","./node_modules/undici-types/mock-client.d.ts","./node_modules/undici-types/mock-pool.d.ts","./node_modules/undici-types/mock-errors.d.ts","./node_modules/undici-types/proxy-agent.d.ts","./node_modules/undici-types/env-http-proxy-agent.d.ts","./node_modules/undici-types/retry-handler.d.ts","./node_modules/undici-types/retry-agent.d.ts","./node_modules/undici-types/api.d.ts","./node_modules/undici-types/interceptors.d.ts","./node_modules/undici-types/util.d.ts","./node_modules/undici-types/cookies.d.ts","./node_modules/undici-types/patch.d.ts","./node_modules/undici-types/websocket.d.ts","./node_modules/undici-types/eventsource.d.ts","./node_modules/undici-types/filereader.d.ts","./node_modules/undici-types/diagnostics-channel.d.ts","./node_modules/undici-types/content-type.d.ts","./node_modules/undici-types/cache.d.ts","./node_modules/undici-types/index.d.ts","./node_modules/@types/node/globals.d.ts","./node_modules/@types/node/assert.d.ts","./node_modules/@types/node/assert/strict.d.ts","./node_modules/@types/node/async_hooks.d.ts","./node_modules/@types/node/buffer.d.ts","./node_modules/@types/node/child_process.d.ts","./node_modules/@types/node/cluster.d.ts","./node_modules/@types/node/console.d.ts","./node_modules/@types/node/constants.d.ts","./node_modules/@types/node/crypto.d.ts","./node_modules/@types/node/dgram.d.ts","./node_modules/@types/node/diagnostics_channel.d.ts","./node_modules/@types/node/dns.d.ts","./node_modules/@types/node/dns/promises.d.ts","./node_modules/@types/node/domain.d.ts","./node_modules/@types/node/dom-events.d.ts","./node_modules/@types/node/events.d.ts","./node_modules/@types/node/fs.d.ts","./node_modules/@types/node/fs/promises.d.ts","./node_modules/@types/node/http.d.ts","./node_modules/@types/node/http2.d.ts","./node_modules/@types/node/https.d.ts","./node_modules/@types/node/inspector.d.ts","./node_modules/@types/node/module.d.ts","./node_modules/@types/node/net.d.ts","./node_modules/@types/node/os.d.ts","./node_modules/@types/node/path.d.ts","./node_modules/@types/node/perf_hooks.d.ts","./node_modules/@types/node/process.d.ts","./node_modules/@types/node/punycode.d.ts","./node_modules/@types/node/querystring.d.ts","./node_modules/@types/node/readline.d.ts","./node_modules/@types/node/readline/promises.d.ts","./node_modules/@types/node/repl.d.ts","./node_modules/@types/node/sea.d.ts","./node_modules/@types/node/sqlite.d.ts","./node_modules/@types/node/stream.d.ts","./node_modules/@types/node/stream/promises.d.ts","./node_modules/@types/node/stream/consumers.d.ts","./node_modules/@types/node/stream/web.d.ts","./node_modules/@types/node/string_decoder.d.ts","./node_modules/@types/node/test.d.ts","./node_modules/@types/node/timers.d.ts","./node_modules/@types/node/timers/promises.d.ts","./node_modules/@types/node/tls.d.ts","./node_modules/@types/node/trace_events.d.ts","./node_modules/@types/node/tty.d.ts","./node_modules/@types/node/url.d.ts","./node_modules/@types/node/util.d.ts","./node_modules/@types/node/v8.d.ts","./node_modules/@types/node/vm.d.ts","./node_modules/@types/node/wasi.d.ts","./node_modules/@types/node/worker_threads.d.ts","./node_modules/@types/node/zlib.d.ts","./node_modules/@types/node/ts5.6/index.d.ts","./node_modules/@types/estree/index.d.ts","./node_modules/rollup/dist/rollup.d.ts","./node_modules/rollup/dist/parseast.d.ts","./node_modules/vite/types/hmrpayload.d.ts","./node_modules/vite/types/customevent.d.ts","./node_modules/vite/types/hot.d.ts","./node_modules/vite/dist/node/types.d-agj9qkwt.d.ts","./node_modules/esbuild/lib/main.d.ts","./node_modules/source-map-js/source-map.d.ts","./node_modules/postcss/lib/previous-map.d.ts","./node_modules/postcss/lib/input.d.ts","./node_modules/postcss/lib/css-syntax-error.d.ts","./node_modules/postcss/lib/declaration.d.ts","./node_modules/postcss/lib/root.d.ts","./node_modules/postcss/lib/warning.d.ts","./node_modules/postcss/lib/lazy-result.d.ts","./node_modules/postcss/lib/no-work-result.d.ts","./node_modules/postcss/lib/processor.d.ts","./node_modules/postcss/lib/result.d.ts","./node_modules/postcss/lib/document.d.ts","./node_modules/postcss/lib/rule.d.ts","./node_modules/postcss/lib/node.d.ts","./node_modules/postcss/lib/comment.d.ts","./node_modules/postcss/lib/container.d.ts","./node_modules/postcss/lib/at-rule.d.ts","./node_modules/postcss/lib/list.d.ts","./node_modules/postcss/lib/postcss.d.ts","./node_modules/postcss/lib/postcss.d.mts","./node_modules/vite/dist/node/runtime.d.ts","./node_modules/vite/types/importglob.d.ts","./node_modules/vite/types/metadata.d.ts","./node_modules/vite/dist/node/index.d.ts","./node_modules/@babel/types/lib/index.d.ts","./node_modules/@types/babel__generator/index.d.ts","./node_modules/@babel/parser/typings/babel-parser.d.ts","./node_modules/@types/babel__template/index.d.ts","./node_modules/@types/babel__traverse/index.d.ts","./node_modules/@types/babel__core/index.d.ts","./node_modules/@vitejs/plugin-react/dist/index.d.mts","./vite.config.ts","./node_modules/@types/graceful-fs/index.d.ts","./node_modules/@types/istanbul-lib-coverage/index.d.ts","./node_modules/@types/istanbul-lib-report/index.d.ts","./node_modules/@types/istanbul-reports/index.d.ts","./node_modules/@jest/expect-utils/build/index.d.ts","./node_modules/chalk/index.d.ts","./node_modules/@sinclair/typebox/typebox.d.ts","./node_modules/@jest/schemas/build/index.d.ts","./node_modules/pretty-format/build/index.d.ts","./node_modules/jest-diff/build/index.d.ts","./node_modules/jest-matcher-utils/build/index.d.ts","./node_modules/expect/build/index.d.ts","./node_modules/@types/jest/index.d.ts","./node_modules/@types/json-schema/index.d.ts","./node_modules/@types/prop-types/index.d.ts","./node_modules/@types/raf/index.d.ts","./node_modules/@types/react/global.d.ts","./node_modules/csstype/index.d.ts","./node_modules/@types/react/index.d.ts","./node_modules/@types/react-dom/index.d.ts","./node_modules/@types/stack-utils/index.d.ts","./node_modules/@types/yargs-parser/index.d.ts","./node_modules/@types/yargs/index.d.ts"],"fileIdsList":[[54,96,179],[54,96],[54,96,193],[54,96,179,180,181,182,183],[54,96,179,181],[54,96,109,146],[54,96,188],[54,96,189],[54,96,195,198],[54,93,96],[54,95,96],[54,96,101,131],[54,96,97,102,108,109,116,128,139],[54,96,97,98,108,116],[49,50,51,54,96],[54,96,99,140],[54,96,100,101,109,117],[54,96,101,128,136],[54,96,102,104,108,116],[54,95,96,103],[54,96,104,105],[54,96,108],[54,96,106,108],[54,95,96,108],[54,96,108,109,110,128,139],[54,96,108,109,110,123,128,131],[54,91,96,144],[54,91,96,104,108,111,116,128,139],[54,96,108,109,111,112,116,128,136,139],[54,96,111,113,128,136,139],[54,96,108,114],[54,96,115,139,144],[54,96,104,108,116,128],[54,96,117],[54,96,118],[54,95,96,119],[54,93,94,95,96,97,98,99,100,101,102,103,104,105,106,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145],[54,96,121],[54,96,122],[54,96,108,123,124],[54,96,123,125,140,142],[54,96,108,128,129,130,131],[54,96,128,130],[54,96,128,129],[54,96,131],[54,96,132],[54,93,96,128],[54,96,108,134,135],[54,96,134,135],[54,96,101,116,128,136],[54,96,137],[96],[52,53,54,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145],[54,96,116,138],[54,96,111,122,139],[54,96,101,140],[54,96,128,141],[54,96,115,142],[54,96,143],[54,96,101,108,110,119,128,139,142,144],[54,96,128,145],[54,96,205],[54,96,201,203,204],[54,96,208],[54,96,178,184],[54,96,191,197],[54,96,195],[54,96,192,196],[54,96,170],[54,96,168,170],[54,96,159,167,168,169,171],[54,96,157],[54,96,160,165,170,173],[54,96,156,173],[54,96,160,161,164,165,166,173],[54,96,160,161,162,164,165,173],[54,96,157,158,159,160,161,165,166,167,169,170,171,173],[54,96,173],[54,96,155,157,158,159,160,161,162,164,165,166,167,168,169,170,171,172],[54,96,155,173],[54,96,160,162,163,165,166,173],[54,96,164,173],[54,96,165,166,170,173],[54,96,158,168],[54,96,194],[54,96,148,177],[54,96,147,148],[54,63,67,96,139],[54,63,96,128,139],[54,58,96],[54,60,63,96,136,139],[54,96,116,136],[54,96,146],[54,58,96,146],[54,60,63,96,116,139],[54,55,56,59,62,96,108,128,139],[54,63,70,96],[54,55,61,96],[54,63,84,85,96],[54,59,63,96,131,139,146],[54,84,96,146],[54,57,58,96,146],[54,63,96],[54,57,58,59,60,61,62,63,64,65,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,85,86,87,88,89,90,96],[54,63,78,96],[54,63,70,71,96],[54,61,63,71,72,96],[54,62,96],[54,55,58,63,96],[54,63,67,71,72,96],[54,67,96],[54,61,63,66,96,139],[54,55,60,63,70,96],[54,96,128],[54,58,63,84,96,144,146],[54,96,108,109,111,112,113,116,128,136,139,145,146,148,149,150,151,152,153,154,174,175,176,177],[54,96,150,151,152,153],[54,96,150,151,152],[54,96,150],[54,96,151],[54,96,148],[54,96,178,185]],"fileInfos":[{"version":"a7297ff837fcdf174a9524925966429eb8e5feecc2cc55cc06574e6b092c1eaa","impliedFormat":1},{"version":"44e584d4f6444f58791784f1d530875970993129442a847597db702a073ca68c","affectsGlobalScope":true,"impliedFormat":1},{"version":"45b7ab580deca34ae9729e97c13cfd999df04416a79116c3bfb483804f85ded4","impliedFormat":1},{"version":"3facaf05f0c5fc569c5649dd359892c98a85557e3e0c847964caeb67076f4d75","impliedFormat":1},{"version":"9a68c0c07ae2fa71b44384a839b7b8d81662a236d4b9ac30916718f7510b1b2d","impliedFormat":1},{"version":"5e1c4c362065a6b95ff952c0eab010f04dcd2c3494e813b493ecfd4fcb9fc0d8","impliedFormat":1},{"version":"68d73b4a11549f9c0b7d352d10e91e5dca8faa3322bfb77b661839c42b1ddec7","impliedFormat":1},{"version":"5efce4fc3c29ea84e8928f97adec086e3dc876365e0982cc8479a07954a3efd4","impliedFormat":1},{"version":"9e8ca8ed051c2697578c023d9c29d6df689a083561feba5c14aedee895853999","affectsGlobalScope":true,"impliedFormat":1},{"version":"80e18897e5884b6723488d4f5652167e7bb5024f946743134ecc4aa4ee731f89","affectsGlobalScope":true,"impliedFormat":1},{"version":"cd034f499c6cdca722b60c04b5b1b78e058487a7085a8e0d6fb50809947ee573","affectsGlobalScope":true,"impliedFormat":1},{"version":"6920e1448680767498a0b77c6a00a8e77d14d62c3da8967b171f1ddffa3c18e4","affectsGlobalScope":true,"impliedFormat":1},{"version":"dc2df20b1bcdc8c2d34af4926e2c3ab15ffe1160a63e58b7e09833f616efff44","affectsGlobalScope":true,"impliedFormat":1},{"version":"515d0b7b9bea2e31ea4ec968e9edd2c39d3eebf4a2d5cbd04e88639819ae3b71","affectsGlobalScope":true,"impliedFormat":1},{"version":"45d8ccb3dfd57355eb29749919142d4321a0aa4df6acdfc54e30433d7176600a","affectsGlobalScope":true,"impliedFormat":1},{"version":"0dc1e7ceda9b8b9b455c3a2d67b0412feab00bd2f66656cd8850e8831b08b537","affectsGlobalScope":true,"impliedFormat":1},{"version":"ce691fb9e5c64efb9547083e4a34091bcbe5bdb41027e310ebba8f7d96a98671","affectsGlobalScope":true,"impliedFormat":1},{"version":"8d697a2a929a5fcb38b7a65594020fcef05ec1630804a33748829c5ff53640d0","affectsGlobalScope":true,"impliedFormat":1},{"version":"4ff2a353abf8a80ee399af572debb8faab2d33ad38c4b4474cff7f26e7653b8d","affectsGlobalScope":true,"impliedFormat":1},{"version":"93495ff27b8746f55d19fcbcdbaccc99fd95f19d057aed1bd2c0cafe1335fbf0","affectsGlobalScope":true,"impliedFormat":1},{"version":"6fc23bb8c3965964be8c597310a2878b53a0306edb71d4b5a4dfe760186bcc01","affectsGlobalScope":true,"impliedFormat":1},{"version":"ea011c76963fb15ef1cdd7ce6a6808b46322c527de2077b6cfdf23ae6f5f9ec7","affectsGlobalScope":true,"impliedFormat":1},{"version":"38f0219c9e23c915ef9790ab1d680440d95419ad264816fa15009a8851e79119","affectsGlobalScope":true,"impliedFormat":1},{"version":"69ab18c3b76cd9b1be3d188eaf8bba06112ebbe2f47f6c322b5105a6fbc45a2e","affectsGlobalScope":true,"impliedFormat":1},{"version":"4738f2420687fd85629c9efb470793bb753709c2379e5f85bc1815d875ceadcd","affectsGlobalScope":true,"impliedFormat":1},{"version":"2f11ff796926e0832f9ae148008138ad583bd181899ab7dd768a2666700b1893","affectsGlobalScope":true,"impliedFormat":1},{"version":"4de680d5bb41c17f7f68e0419412ca23c98d5749dcaaea1896172f06435891fc","affectsGlobalScope":true,"impliedFormat":1},{"version":"9fc46429fbe091ac5ad2608c657201eb68b6f1b8341bd6d670047d32ed0a88fa","affectsGlobalScope":true,"impliedFormat":1},{"version":"ac9538681b19688c8eae65811b329d3744af679e0bdfa5d842d0e32524c73e1c","affectsGlobalScope":true,"impliedFormat":1},{"version":"0a969edff4bd52585473d24995c5ef223f6652d6ef46193309b3921d65dd4376","affectsGlobalScope":true,"impliedFormat":1},{"version":"9e9fbd7030c440b33d021da145d3232984c8bb7916f277e8ffd3dc2e3eae2bdb","affectsGlobalScope":true,"impliedFormat":1},{"version":"811ec78f7fefcabbda4bfa93b3eb67d9ae166ef95f9bff989d964061cbf81a0c","affectsGlobalScope":true,"impliedFormat":1},{"version":"717937616a17072082152a2ef351cb51f98802fb4b2fdabd32399843875974ca","affectsGlobalScope":true,"impliedFormat":1},{"version":"d7e7d9b7b50e5f22c915b525acc5a49a7a6584cf8f62d0569e557c5cfc4b2ac2","affectsGlobalScope":true,"impliedFormat":1},{"version":"71c37f4c9543f31dfced6c7840e068c5a5aacb7b89111a4364b1d5276b852557","affectsGlobalScope":true,"impliedFormat":1},{"version":"576711e016cf4f1804676043e6a0a5414252560eb57de9faceee34d79798c850","affectsGlobalScope":true,"impliedFormat":1},{"version":"89c1b1281ba7b8a96efc676b11b264de7a8374c5ea1e6617f11880a13fc56dc6","affectsGlobalScope":true,"impliedFormat":1},{"version":"74f7fa2d027d5b33eb0471c8e82a6c87216223181ec31247c357a3e8e2fddc5b","affectsGlobalScope":true,"impliedFormat":1},{"version":"1a94697425a99354df73d9c8291e2ecd4dddd370aed4023c2d6dee6cccb32666","affectsGlobalScope":true,"impliedFormat":1},{"version":"063600664504610fe3e99b717a1223f8b1900087fab0b4cad1496a114744f8df","affectsGlobalScope":true,"impliedFormat":1},{"version":"934019d7e3c81950f9a8426d093458b65d5aff2c7c1511233c0fd5b941e608ab","affectsGlobalScope":true,"impliedFormat":1},{"version":"bf14a426dbbf1022d11bd08d6b8e709a2e9d246f0c6c1032f3b2edb9a902adbe","affectsGlobalScope":true,"impliedFormat":1},{"version":"e3f9fc0ec0b96a9e642f11eda09c0be83a61c7b336977f8b9fdb1e9788e925fe","affectsGlobalScope":true,"impliedFormat":1},{"version":"59fb2c069260b4ba00b5643b907ef5d5341b167e7d1dbf58dfd895658bda2867","affectsGlobalScope":true,"impliedFormat":1},{"version":"479553e3779be7d4f68e9f40cdb82d038e5ef7592010100410723ceced22a0f7","affectsGlobalScope":true,"impliedFormat":1},{"version":"368af93f74c9c932edd84c58883e736c9e3d53cec1fe24c0b0ff451f529ceab1","affectsGlobalScope":true,"impliedFormat":1},{"version":"33358442698bb565130f52ba79bfd3d4d484ac85fe33f3cb1759c54d18201393","affectsGlobalScope":true,"impliedFormat":1},{"version":"782dec38049b92d4e85c1585fbea5474a219c6984a35b004963b00beb1aab538","affectsGlobalScope":true,"impliedFormat":1},{"version":"70521b6ab0dcba37539e5303104f29b721bfb2940b2776da4cc818c07e1fefc1","affectsGlobalScope":true,"impliedFormat":1},{"version":"030e350db2525514580ed054f712ffb22d273e6bc7eddc1bb7eda1e0ba5d395e","affectsGlobalScope":true,"impliedFormat":1},{"version":"d153a11543fd884b596587ccd97aebbeed950b26933ee000f94009f1ab142848","affectsGlobalScope":true,"impliedFormat":1},{"version":"21d819c173c0cf7cc3ce57c3276e77fd9a8a01d35a06ad87158781515c9a438a","impliedFormat":1},{"version":"613b21ccdf3be6329d56e6caa13b258c842edf8377be7bc9f014ed14cdcfc308","affectsGlobalScope":true,"impliedFormat":1},{"version":"2d1319e6b5d0efd8c5eae07eb864a00102151e8b9afddd2d45db52e9aae002c4","affectsGlobalScope":true,"impliedFormat":1},{"version":"5929864ce17fba74232584d90cb721a89b7ad277220627cc97054ba15a98ea8f","impliedFormat":1},{"version":"24bd580b5743dc56402c440dc7f9a4f5d592ad7a419f25414d37a7bfe11e342b","impliedFormat":1},{"version":"25c8056edf4314820382a5fdb4bb7816999acdcb929c8f75e3f39473b87e85bc","impliedFormat":1},{"version":"c464d66b20788266e5353b48dc4aa6bc0dc4a707276df1e7152ab0c9ae21fad8","impliedFormat":1},{"version":"78d0d27c130d35c60b5e5566c9f1e5be77caf39804636bc1a40133919a949f21","impliedFormat":1},{"version":"c6fd2c5a395f2432786c9cb8deb870b9b0e8ff7e22c029954fabdd692bff6195","impliedFormat":1},{"version":"1d6e127068ea8e104a912e42fc0a110e2aa5a66a356a917a163e8cf9a65e4a75","impliedFormat":1},{"version":"5ded6427296cdf3b9542de4471d2aa8d3983671d4cac0f4bf9c637208d1ced43","impliedFormat":1},{"version":"6bdc71028db658243775263e93a7db2fd2abfce3ca569c3cca5aee6ed5eb186d","impliedFormat":1},{"version":"cadc8aced301244057c4e7e73fbcae534b0f5b12a37b150d80e5a45aa4bebcbd","impliedFormat":1},{"version":"385aab901643aa54e1c36f5ef3107913b10d1b5bb8cbcd933d4263b80a0d7f20","impliedFormat":1},{"version":"9670d44354bab9d9982eca21945686b5c24a3f893db73c0dae0fd74217a4c219","impliedFormat":1},{"version":"0b8a9268adaf4da35e7fa830c8981cfa22adbbe5b3f6f5ab91f6658899e657a7","impliedFormat":1},{"version":"11396ed8a44c02ab9798b7dca436009f866e8dae3c9c25e8c1fbc396880bf1bb","impliedFormat":1},{"version":"ba7bc87d01492633cb5a0e5da8a4a42a1c86270e7b3d2dea5d156828a84e4882","impliedFormat":1},{"version":"4893a895ea92c85345017a04ed427cbd6a1710453338df26881a6019432febdd","impliedFormat":1},{"version":"c21dc52e277bcfc75fac0436ccb75c204f9e1b3fa5e12729670910639f27343e","impliedFormat":1},{"version":"13f6f39e12b1518c6650bbb220c8985999020fe0f21d818e28f512b7771d00f9","impliedFormat":1},{"version":"9b5369969f6e7175740bf51223112ff209f94ba43ecd3bb09eefff9fd675624a","impliedFormat":1},{"version":"4fe9e626e7164748e8769bbf74b538e09607f07ed17c2f20af8d680ee49fc1da","impliedFormat":1},{"version":"24515859bc0b836719105bb6cc3d68255042a9f02a6022b3187948b204946bd2","impliedFormat":1},{"version":"ea0148f897b45a76544ae179784c95af1bd6721b8610af9ffa467a518a086a43","impliedFormat":1},{"version":"24c6a117721e606c9984335f71711877293a9651e44f59f3d21c1ea0856f9cc9","impliedFormat":1},{"version":"dd3273ead9fbde62a72949c97dbec2247ea08e0c6952e701a483d74ef92d6a17","impliedFormat":1},{"version":"405822be75ad3e4d162e07439bac80c6bcc6dbae1929e179cf467ec0b9ee4e2e","impliedFormat":1},{"version":"0db18c6e78ea846316c012478888f33c11ffadab9efd1cc8bcc12daded7a60b6","impliedFormat":1},{"version":"4d2b0eb911816f66abe4970898f97a2cfc902bcd743cbfa5017fad79f7ef90d8","impliedFormat":1},{"version":"bd0532fd6556073727d28da0edfd1736417a3f9f394877b6d5ef6ad88fba1d1a","impliedFormat":1},{"version":"89167d696a849fce5ca508032aabfe901c0868f833a8625d5a9c6e861ef935d2","impliedFormat":1},{"version":"e53a3c2a9f624d90f24bf4588aacd223e7bec1b9d0d479b68d2f4a9e6011147f","impliedFormat":1},{"version":"24b8685c62562f5d98615c5a0c1d05f297cf5065f15246edfe99e81ec4c0e011","impliedFormat":1},{"version":"93507c745e8f29090efb99399c3f77bec07db17acd75634249dc92f961573387","impliedFormat":1},{"version":"339dc5265ee5ed92e536a93a04c4ebbc2128f45eeec6ed29f379e0085283542c","impliedFormat":1},{"version":"4732aec92b20fb28c5fe9ad99521fb59974289ed1e45aecb282616202184064f","impliedFormat":1},{"version":"2e85db9e6fd73cfa3d7f28e0ab6b55417ea18931423bd47b409a96e4a169e8e6","impliedFormat":1},{"version":"c46e079fe54c76f95c67fb89081b3e399da2c7d109e7dca8e4b58d83e332e605","impliedFormat":1},{"version":"bf67d53d168abc1298888693338cb82854bdb2e69ef83f8a0092093c2d562107","impliedFormat":1},{"version":"81184fe8e67d78ac4e5374650f0892d547d665d77da2b2f544b5d84729c4a15d","affectsGlobalScope":true,"impliedFormat":1},{"version":"f52e8dacc97d71dcc96af29e49584353f9c54cb916d132e3e768d8b8129c928d","impliedFormat":1},{"version":"7394959e5a741b185456e1ef5d64599c36c60a323207450991e7a42e08911419","impliedFormat":1},{"version":"76103716ba397bbb61f9fa9c9090dca59f39f9047cb1352b2179c5d8e7f4e8d0","impliedFormat":1},{"version":"53eac70430b30089a3a1959d8306b0f9cfaf0de75224b68ef25243e0b5ad1ca3","affectsGlobalScope":true,"impliedFormat":1},{"version":"4314c7a11517e221f7296b46547dbc4df047115b182f544d072bdccffa57fc72","impliedFormat":1},{"version":"115971d64632ea4742b5b115fb64ed04bcaae2c3c342f13d9ba7e3f9ee39c4e7","impliedFormat":1},{"version":"c2510f124c0293ab80b1777c44d80f812b75612f297b9857406468c0f4dafe29","affectsGlobalScope":true,"impliedFormat":1},{"version":"a40826e8476694e90da94aa008283a7de50d1dafd37beada623863f1901cb7fb","impliedFormat":1},{"version":"a76037255d4e7af8b20d191a4d3ad13236fba352239d3d9d54868a98dbb222f5","affectsGlobalScope":true,"impliedFormat":1},{"version":"24642567d3729bcc545bacb65ee7c0db423400c7f1ef757cab25d05650064f98","impliedFormat":1},{"version":"e6f5a38687bebe43a4cef426b69d34373ef68be9a6b1538ec0a371e69f309354","impliedFormat":1},{"version":"a6bf63d17324010ca1fbf0389cab83f93389bb0b9a01dc8a346d092f65b3605f","impliedFormat":1},{"version":"e009777bef4b023a999b2e5b9a136ff2cde37dc3f77c744a02840f05b18be8ff","impliedFormat":1},{"version":"1e0d1f8b0adfa0b0330e028c7941b5a98c08b600efe7f14d2d2a00854fb2f393","impliedFormat":1},{"version":"ee1ee365d88c4c6c0c0a5a5701d66ebc27ccd0bcfcfaa482c6e2e7fe7b98edf7","affectsGlobalScope":true,"impliedFormat":1},{"version":"875928df2f3e9a3aed4019539a15d04ff6140a06df6cd1b2feb836d22a81eaca","affectsGlobalScope":true,"impliedFormat":1},{"version":"e9ad08a376ac84948fcca0013d6f1d4ae4f9522e26b91f87945b97c99d7cc30b","impliedFormat":1},{"version":"f65eecc63138013d13fefea9092e83c3043cb52a5e351d22ea194e81021c1cd5","impliedFormat":1},{"version":"4617299caf33afef24b5e074e6d20ce8f510dd212cebd75884ef27c64457a77b","impliedFormat":1},{"version":"fa56be9b96f747e93b895d8dc2aa4fb9f0816743e6e2abb9d60705e88d4743a2","impliedFormat":1},{"version":"8257c55ff6bff6169142a35fce6811b511d857b4ae4f522cdb6ce20fd2116b2c","impliedFormat":1},{"version":"6d386bc0d7f3afa1d401afc3e00ed6b09205a354a9795196caed937494a713e6","impliedFormat":1},{"version":"5990bd8b9bc91f6e90269685ff5a154eeda52c18238f89f0101fb4d08cd80476","affectsGlobalScope":true,"impliedFormat":1},{"version":"94c4187083503a74f4544503b5a30e2bd7af0032dc739b0c9a7ce87f8bddc7b9","impliedFormat":1},{"version":"b1b6ee0d012aeebe11d776a155d8979730440082797695fc8e2a5c326285678f","impliedFormat":1},{"version":"45875bcae57270aeb3ebc73a5e3fb4c7b9d91d6b045f107c1d8513c28ece71c0","impliedFormat":1},{"version":"3eb62baae4df08c9173e6903d3ca45942ccec8c3659b0565684a75f3292cffbb","affectsGlobalScope":true,"impliedFormat":1},{"version":"6f6abdaf8764ef01a552a958f45e795b5e79153b87ddad3af5264b86d2681b72","affectsGlobalScope":true,"impliedFormat":1},{"version":"3f16a7e4deafa527ed9995a772bb380eb7d3c2c0fd4ae178c5263ed18394db2c","impliedFormat":1},{"version":"c6b4e0a02545304935ecbf7de7a8e056a31bb50939b5b321c9d50a405b5a0bba","impliedFormat":1},{"version":"fab29e6d649aa074a6b91e3bdf2bff484934a46067f6ee97a30fcd9762ae2213","impliedFormat":1},{"version":"8145e07aad6da5f23f2fcd8c8e4c5c13fb26ee986a79d03b0829b8fce152d8b2","impliedFormat":1},{"version":"e1120271ebbc9952fdc7b2dd3e145560e52e06956345e6fdf91d70ca4886464f","impliedFormat":1},{"version":"15c5e91b5f08be34a78e3d976179bf5b7a9cc28dc0ef1ffebffeb3c7812a2dca","impliedFormat":1},{"version":"a8f06c2382a30b7cb89ad2dfc48fc3b2b490f3dafcd839dadc008e4e5d57031d","impliedFormat":1},{"version":"553870e516f8c772b89f3820576152ebc70181d7994d96917bb943e37da7f8a7","impliedFormat":1},{"version":"37ba7b45141a45ce6e80e66f2a96c8a5ab1bcef0fc2d0f56bb58df96ec67e972","impliedFormat":1},{"version":"93452d394fdd1dc551ec62f5042366f011a00d342d36d50793b3529bfc9bd633","impliedFormat":1},{"version":"745c4240220559bd340c8aeb6e3c5270a709d3565e934dc22a69c304703956bc","affectsGlobalScope":true,"impliedFormat":1},{"version":"2754d8221d77c7b382096651925eb476f1066b3348da4b73fe71ced7801edada","impliedFormat":1},{"version":"918d3b03a75858dcd5dbb275f19448b6b9a222aa8fc8471aca38c28a32ecb40f","affectsGlobalScope":true,"impliedFormat":1},{"version":"bef91efa0baea5d0e0f0f27b574a8bc100ce62a6d7e70220a0d58af6acab5e89","affectsGlobalScope":true,"impliedFormat":1},{"version":"282fd2a1268a25345b830497b4b7bf5037a5e04f6a9c44c840cb605e19fea841","impliedFormat":1},{"version":"5360a27d3ebca11b224d7d3e38e3e2c63f8290cb1fcf6c3610401898f8e68bc3","impliedFormat":1},{"version":"66ba1b2c3e3a3644a1011cd530fb444a96b1b2dfe2f5e837a002d41a1a799e60","impliedFormat":1},{"version":"7e514f5b852fdbc166b539fdd1f4e9114f29911592a5eb10a94bb3a13ccac3c4","impliedFormat":1},{"version":"7d6ff413e198d25639f9f01f16673e7df4e4bd2875a42455afd4ecc02ef156da","affectsGlobalScope":true,"impliedFormat":1},{"version":"6bd91a2a356600dee28eb0438082d0799a18a974a6537c4410a796bab749813c","affectsGlobalScope":true,"impliedFormat":1},{"version":"a5c09990a37469b0311a92ce8feeb8682e83918723aedbd445bd7a0f510eaaa3","impliedFormat":1},{"version":"ae25afbbf1ed5df63a177d67b9048bf7481067f1b8dc9c39212e59db94fc9fc6","impliedFormat":1},{"version":"ac5ed35e649cdd8143131964336ab9076937fa91802ec760b3ea63b59175c10a","impliedFormat":1},{"version":"89332fc3cc945c8df2bc0aead55230430a0dabd3277c39a43315e00330de97a6","affectsGlobalScope":true,"impliedFormat":1},{"version":"78dc0513cc4f1642906b74dda42146bcbd9df7401717d6e89ea6d72d12ecb539","impliedFormat":1},{"version":"171fd8807643c46a9d17e843959abdf10480d57d60d38d061fb44a4c8d4a8cc4","impliedFormat":1},{"version":"785b9d575b49124ce01b46f5b9402157c7611e6532effa562ac6aebec0074dfc","impliedFormat":1},{"version":"207bee54c60bfe26feca8ef79922f66fd091092a9d24aa12daea1b340fa7e0ee","affectsGlobalScope":true,"impliedFormat":1},{"version":"a660aa95476042d3fdcc1343cf6bb8fdf24772d31712b1db321c5a4dcc325434","impliedFormat":1},{"version":"282f98006ed7fa9bb2cd9bdbe2524595cfc4bcd58a0bb3232e4519f2138df811","impliedFormat":1},{"version":"6222e987b58abfe92597e1273ad7233626285bc2d78409d4a7b113d81a83496b","impliedFormat":1},{"version":"cbe726263ae9a7bf32352380f7e8ab66ee25b3457137e316929269c19e18a2be","impliedFormat":1},{"version":"8b96046bf5fb0a815cba6b0880d9f97b7f3a93cf187e8dcfe8e2792e97f38f87","impliedFormat":99},{"version":"bacf2c84cf448b2cd02c717ad46c3d7fd530e0c91282888c923ad64810a4d511","affectsGlobalScope":true,"impliedFormat":1},{"version":"402e5c534fb2b85fa771170595db3ac0dd532112c8fa44fc23f233bc6967488b","impliedFormat":1},{"version":"8885cf05f3e2abf117590bbb951dcf6359e3e5ac462af1c901cfd24c6a6472e2","impliedFormat":1},{"version":"4d979e3c12ffb6497d2b1dc5613130196d986fff764c4526360c0716a162e7e7","impliedFormat":1},{"version":"e61df3640a38d535fd4bc9f4a53aef17c296b58dc4b6394fd576b808dd2fe5e6","impliedFormat":1},{"version":"80781460eca408fe8d2937d9fdbbb780d6aac35f549621e6200c9bee1da5b8fe","impliedFormat":1},{"version":"4719c209b9c00b579553859407a7e5dcfaa1c472994bd62aa5dd3cc0757eb077","impliedFormat":1},{"version":"7ec359bbc29b69d4063fe7dad0baaf35f1856f914db16b3f4f6e3e1bca4099fa","impliedFormat":1},{"version":"b9261ac3e9944d3d72c5ee4cf888ad35d9743a5563405c6963c4e43ee3708ca4","impliedFormat":1},{"version":"c84fd54e8400def0d1ef1569cafd02e9f39a622df9fa69b57ccc82128856b916","impliedFormat":1},{"version":"a022503e75d6953d0e82c2c564508a5c7f8556fad5d7f971372d2d40479e4034","impliedFormat":1},{"version":"2ed6489ef46eb61442d067c08e87e3db501c0bfb2837eee4041a27bf3e792bb0","impliedFormat":1},{"version":"644491cde678bd462bb922c1d0cfab8f17d626b195ccb7f008612dc31f445d2d","impliedFormat":1},{"version":"d60fe6d59d4e19ecc65359490b8535e359ca4b760d2cdb56897ca75d09d41ba3","impliedFormat":1},{"version":"f45a2a8b1777ecb50ed65e1a04bb899d4b676529b7921bd5d69b08573a00c832","impliedFormat":1},{"version":"774b783046ba3d473948132d28a69f52a295b2f378f2939304118ba571b1355e","impliedFormat":1},{"version":"b5734e05c787a40e4f9efe71f16683c5f7dc3bdb0de7c04440c855bd000f8fa7","impliedFormat":1},{"version":"14ba97f0907144771331e1349fdccb5a13526eba0647e6b447e572376d811b6f","impliedFormat":1},{"version":"2a771d907aebf9391ac1f50e4ad37952943515eeea0dcc7e78aa08f508294668","impliedFormat":1},{"version":"7165050eddaed878c2d2cd3cafcaf171072ac39e586a048c0603712b5555f536","impliedFormat":1},{"version":"26e629be9bbd94ea1d465af83ce5a3306890520695f07be6eb016f8d734d02be","impliedFormat":99},{"version":"82e687ebd99518bc63ea04b0c3810fb6e50aa6942decd0ca6f7a56d9b9a212a6","impliedFormat":99},{"version":"7f698624bbbb060ece7c0e51b7236520ebada74b747d7523c7df376453ed6fea","impliedFormat":1},{"version":"8f07f2b6514744ac96e51d7cb8518c0f4de319471237ea10cf688b8d0e9d0225","impliedFormat":1},{"version":"9ae0ca65717af0d3b554a26fd333ad9c78ad3910ad4b22140ff02acb63076927","impliedFormat":99},{"version":"03f1d83d61696326ea29c8a1c15cbaccf61e92598d53f2ccae06078531f42448","impliedFormat":1},{"version":"2c8e55457aaf4902941dfdba4061935922e8ee6e120539c9801cd7b400fae050","impliedFormat":1},{"version":"3a9313fe5ace558b8b18e85f931da10b259e738775f411c061e5f15787b138eb","impliedFormat":1},{"version":"670a76db379b27c8ff42f1ba927828a22862e2ab0b0908e38b671f0e912cc5ed","impliedFormat":1},{"version":"9e0cf651e8e2c5b9bebbabdff2f7c6f8cedd91b1d9afcc0a854cdff053a88f1b","impliedFormat":1},{"version":"069bebfee29864e3955378107e243508b163e77ab10de6a5ee03ae06939f0bb9","impliedFormat":1},{"version":"f5e8546cfe500116aba8a6cb7ee171774b14a6db30d4bcd6e0aa5073e919e739","impliedFormat":99},{"version":"fc2a2bc057b5e206d8947e4fcb393a54b41770334bb73339137f2ef63436dceb","signature":"4b96dd19fd2949d28ce80e913412b0026dc421e5bf6c31d87c7b5eb11b5753b4"},{"version":"afe73051ff6a03a9565cbd8ebb0e956ee3df5e913ad5c1ded64218aabfa3dcb5","impliedFormat":1},{"version":"035a5df183489c2e22f3cf59fc1ed2b043d27f357eecc0eb8d8e840059d44245","impliedFormat":1},{"version":"a4809f4d92317535e6b22b01019437030077a76fec1d93b9881c9ed4738fcc54","impliedFormat":1},{"version":"5f53fa0bd22096d2a78533f94e02c899143b8f0f9891a46965294ee8b91a9434","impliedFormat":1},{"version":"cdcc132f207d097d7d3aa75615ab9a2e71d6a478162dde8b67f88ea19f3e54de","impliedFormat":1},{"version":"0d14fa22c41fdc7277e6f71473b20ebc07f40f00e38875142335d5b63cdfc9d2","impliedFormat":1},{"version":"c085e9aa62d1ae1375794c1fb927a445fa105fed891a7e24edbb1c3300f7384a","impliedFormat":1},{"version":"f315e1e65a1f80992f0509e84e4ae2df15ecd9ef73df975f7c98813b71e4c8da","impliedFormat":1},{"version":"5b9586e9b0b6322e5bfbd2c29bd3b8e21ab9d871f82346cb71020e3d84bae73e","impliedFormat":1},{"version":"3e70a7e67c2cb16f8cd49097360c0309fe9d1e3210ff9222e9dac1f8df9d4fb6","impliedFormat":1},{"version":"ab68d2a3e3e8767c3fba8f80de099a1cfc18c0de79e42cb02ae66e22dfe14a66","impliedFormat":1},{"version":"d96cc6598148bf1a98fb2e8dcf01c63a4b3558bdaec6ef35e087fd0562eb40ec","impliedFormat":1},{"version":"f8db4fea512ab759b2223b90ecbbe7dae919c02f8ce95ec03f7fb1cf757cfbeb","affectsGlobalScope":true,"impliedFormat":1},{"version":"f3d8c757e148ad968f0d98697987db363070abada5f503da3c06aefd9d4248c1","impliedFormat":1},{"version":"ed6b820c54de95b2510bb673490d61c7f2187f532a339d8d04981645a918961f","impliedFormat":1},{"version":"4cf58cd73f135e59d2268b4b792623bd8cc7ea887d96498f2a64d550beb930bb","impliedFormat":1},{"version":"36a2e4c9a67439aca5f91bb304611d5ae6e20d420503e96c230cf8fcdc948d94","affectsGlobalScope":true,"impliedFormat":1},{"version":"8a8eb4ebffd85e589a1cc7c178e291626c359543403d58c9cd22b81fab5b1fb9","impliedFormat":1},{"version":"aa17748c522bd586f8712b1a308ea23af59c309b2fd278f6d4f406647c72e659","affectsGlobalScope":true,"impliedFormat":1},{"version":"17ed71200119e86ccef2d96b73b02ce8854b76ad6bd21b5021d4269bec527b5f","impliedFormat":1},{"version":"ab82804a14454734010dcdcd43f564ff7b0389bee4c5692eec76ff5b30d4cf66","impliedFormat":1},{"version":"bae8d023ef6b23df7da26f51cea44321f95817c190342a36882e93b80d07a960","impliedFormat":1},{"version":"26a770cec4bd2e7dbba95c6e536390fffe83c6268b78974a93727903b515c4e7","impliedFormat":1}],"root":[186],"options":{"allowSyntheticDefaultImports":true,"composite":true,"module":99,"skipLibCheck":true,"strict":true},"referencedMap":[[181,1],[179,2],[191,2],[194,3],[193,2],[184,4],[180,1],[182,5],[183,1],[147,2],[187,6],[188,2],[189,7],[190,8],[199,9],[200,2],[93,10],[94,10],[95,11],[96,12],[97,13],[98,14],[49,2],[52,15],[50,2],[51,2],[99,16],[100,17],[101,18],[102,19],[103,20],[104,21],[105,21],[107,22],[106,23],[108,24],[109,25],[110,26],[92,27],[111,28],[112,29],[113,30],[114,31],[115,32],[116,33],[117,34],[118,35],[119,36],[120,37],[121,38],[122,39],[123,40],[124,40],[125,41],[126,2],[127,2],[128,42],[130,43],[129,44],[131,45],[132,46],[133,47],[134,48],[135,49],[136,50],[137,51],[54,52],[53,2],[146,53],[138,54],[139,55],[140,56],[141,57],[142,58],[143,59],[144,60],[145,61],[201,2],[202,2],[206,62],[203,2],[205,63],[207,2],[208,2],[209,64],[185,65],[192,2],[204,2],[154,2],[198,66],[196,67],[197,68],[171,69],[169,70],[170,71],[158,72],[159,70],[166,73],[157,74],[162,75],[172,2],[163,76],[168,77],[174,78],[173,79],[156,80],[164,81],[165,82],[160,83],[167,69],[161,84],[195,85],[149,86],[148,87],[155,2],[1,2],[47,2],[48,2],[9,2],[13,2],[12,2],[3,2],[14,2],[15,2],[16,2],[17,2],[18,2],[19,2],[20,2],[21,2],[4,2],[22,2],[5,2],[23,2],[27,2],[24,2],[25,2],[26,2],[28,2],[29,2],[30,2],[6,2],[31,2],[32,2],[33,2],[34,2],[7,2],[38,2],[35,2],[36,2],[37,2],[39,2],[8,2],[40,2],[45,2],[46,2],[41,2],[42,2],[43,2],[44,2],[2,2],[11,2],[10,2],[70,88],[80,89],[69,88],[90,90],[61,91],[60,92],[89,93],[83,94],[88,95],[63,96],[77,97],[62,98],[86,99],[58,100],[57,93],[87,101],[59,102],[64,103],[65,2],[68,103],[55,2],[91,104],[81,105],[72,106],[73,107],[75,108],[71,109],[74,110],[84,93],[66,111],[67,112],[76,113],[56,114],[79,105],[78,103],[82,2],[85,115],[178,116],[175,117],[153,118],[151,119],[150,2],[152,120],[176,2],[177,121],[186,122]],"latestChangedDtsFile":"./vite.config.d.ts","version":"5.6.3"}

================
File: tsconfig.tsbuildinfo
================
{"root":["./src/app.tsx","./src/main.tsx","./src/types.ts","./src/vite-env.d.ts","./src/__tests__/constraints.test.ts","./src/__tests__/parallelscheduler.test.ts","./src/__tests__/scoring.test.ts","./src/__tests__/simulatedannealing.test.ts","./src/__tests__/utils/assertions.ts","./src/__tests__/utils/builders.test.ts","./src/__tests__/utils/builders.ts","./src/components/classform.tsx","./src/components/gradegroupbuilder.tsx","./src/components/scheduleconstraints.tsx","./src/components/scheduledisplay.tsx","./src/components/schedulegenerator.tsx","./src/components/schedule/exportbutton.tsx","./src/components/schedule/monthview.tsx","./src/components/schedule/schedulecell.tsx","./src/components/schedule/scheduleheader.tsx","./src/components/ui/button.tsx","./src/components/ui/card.tsx","./src/components/ui/tooltip.tsx","./src/types/index.ts","./src/utils/cn.ts","./src/utils/export.ts","./src/utils/parallelscheduler.ts","./src/utils/schedule.ts","./src/utils/scheduleengine.ts","./src/utils/schedulerworker.ts","./src/utils/simulatedannealing.ts","./src/utils/storage.ts"],"errors":true,"version":"5.6.3"}

================
File: vite.config.d.ts
================
declare const _default: import("vite").UserConfig;
export default _default;

================
File: vite.config.js
================
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
export default defineConfig({
    plugins: [react()],
    server: {
        port: 5173,
        host: true,
        open: true,
    },
    css: {
        devSourcemap: true,
    },
});

================
File: vite.config.ts
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    host: true,
    open: true,
  },
  css: {
    devSourcemap: true,
  },
})
